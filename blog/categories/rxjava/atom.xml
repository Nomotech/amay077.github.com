<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rxjava | Experiments Never Fail]]></title>
  <link href="http://blog.amay077.net/blog/categories/rxjava/atom.xml" rel="self"/>
  <link href="http://blog.amay077.net/"/>
  <updated>2016-07-08T02:34:42+09:00</updated>
  <id>http://blog.amay077.net/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RxJava でズンドコキヨシ(window or buffer 使用)]]></title>
    <link href="http://blog.amay077.net/blog/2016/03/13/zundoko-with-rxjava/"/>
    <updated>2016-03-13T23:59:59+09:00</updated>
    <id>http://blog.amay077.net/blog/2016/03/13/zundoko-with-rxjava</id>
    <content type="html"><![CDATA[<p>調子に乗って RxJava でもやってみた。</p>

<!--more-->




<blockquote class="twitter-tweet" data-lang="ja"><p lang="ja" dir="ltr">Javaの講義、試験が「自作関数を作り記述しなさい」って問題だったから<br>「ズン」「ドコ」のいずれかをランダムで出力し続けて「ズン」「ズン」「ズン」「ズン」「ドコ」の配列が出たら「キ・ヨ・シ！」って出力した後終了って関数作ったら満点で単位貰ってた</p>&mdash; てくも (@kumiromilk) <a href="https://twitter.com/kumiromilk/status/707437861881180160">2016年3月9日</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


<ul>
<li><a href="http://qiita.com/amay077/items/85dfc4bd194f57c52c57">C# と Reactive Extensions でズンドコキヨシ</a></li>
</ul>


<p>がんばって <a href="http://reactivex.io/documentation/operators/window.html"><code>Observable.window</code></a> を使ってみた。</p>

<p>```java zondoko.java</p>

<p>// なんちゃってラムダ使用。あと Android。
public void doZondoko() {</p>

<pre><code>final Random random = new Random();
final List&lt;String&gt; PATTERN = Arrays.asList("ずん", "ずん", "ずん", "ずん", "どこ");
final String K = "キ・ヨ・シ！";

Observable.concat( // ※ の Observable&lt;List&lt;String&gt;&gt; を直列に連結
    Observable.interval(500, TimeUnit.MILLISECONDS)
        .map(_ -&gt; random.nextInt(2) == 0 ? "ずん" : "どこ") // ランダムに ずん or どこ
        .window(PATTERN.size(), 1) // 要素数5のWindowを1ずつズラしてく
        .map(window -&gt; window.toList())) // Observable&lt;Observable&lt;String&gt;&gt; を Observable&lt;List&lt;String&gt;&gt; に変換 ※
    .flatMap(window -&gt; {
        if (sequenceEqual(window, PATTERN)) { // パターンと一致していたら…
            final List&lt;String&gt; says = new ArrayList&lt;&gt;();
            says.addAll(window);
            says.add(K);                      // キ・ヨ・シ！を追加
            return Observable.concat(
                    Observable.just(says),
                    Observable.just(Collections.&lt;String&gt;emptyList())); // 終了判定用の空リスト
        } else {
            return Observable.just(window);
        }
    })
    .takeWhile(says -&gt; !says.isEmpty())  // 空リストになるまで繰り返す
    .subscribe(says -&gt; Log.d(TAG, dump(says)));
</code></pre>

<p>}</p>

<p>/<em>* リストとリストの要素一致 </em>/
private boolean sequenceEqual(List<String> listA, List<String> listB) {</p>

<pre><code>Iterator&lt;String&gt; iterA = listA.iterator();
Iterator&lt;String&gt; iterB = listB.iterator();

while (iterA.hasNext() &amp;&amp; iterB.hasNext()) {
    if (iterA.next() != iterB.next()) {
        return false;
    }
}
return (!iterA.hasNext() &amp;&amp; !iterB.hasNext());
</code></pre>

<p>}</p>

<p>/<em>* リスト内容をダンプ </em>/
private String dump(List<String> list) {</p>

<pre><code>final StringBuilder b = new StringBuilder();
for (String s : list) {
    if (!TextUtils.isEmpty(b.toString())) {
        b.append(", ");
    }
    b.append(s);
}

return b.toString();
</code></pre>

<p>}
```</p>

<blockquote><p>どこ, ずん, どこ, どこ, ずん<br/>
ずん, どこ, どこ, ずん, どこ<br/>
どこ, どこ, ずん, どこ, ずん<br/>
どこ, ずん, どこ, ずん, どこ<br/>
ずん, どこ, ずん, どこ, どこ<br/>
どこ, ずん, どこ, どこ, ずん<br/>
ずん, どこ, どこ, ずん, ずん<br/>
どこ, どこ, ずん, ずん, ずん<br/>
どこ, ずん, ずん, ずん, ずん<br/>
ずん, ずん, ずん, ずん, どこ, キ・ヨ・シ！</p></blockquote>

<p>「window(5, 1) &ndash;> toList &ndash;> concat してるならそれは <code>buffer(5, 1)</code> やんけ」というのを <a href="http://qiita.com/do6gop/items/c4941f6fb2bdc1c0c0f1">こちら</a> で知って、 <code>buffer</code> 版も書いてみた。</p>

<p>```java Zondoko_buffer.java
public void doZondoko() {</p>

<pre><code>final Random random = new Random();
final List&lt;String&gt; PATTERN = Arrays.asList("ずん", "ずん", "ずん", "ずん", "どこ");
final String K = "キ・ヨ・シ！";

Observable.interval(500, TimeUnit.MILLISECONDS)
    .map(_ -&gt; random.nextInt(2) == 0 ? "ずん" : "どこ") // ランダムに ずん or どこ
    .buffer(PATTERN.size(), 1) // 要素数5のBufferを1ずつズラしてく
    .flatMap(buf -&gt; {
        if (sequenceEqual(buf, PATTERN)) { // パターンと一致していたら…
            final List&lt;String&gt; says = new ArrayList&lt;&gt;();
            says.addAll(buf);
            says.add(K);                      // キ・ヨ・シ！を追加
            return Observable.concat(
                    Observable.just(says),
                    Observable.just(Collections.&lt;String&gt;emptyList())); // 終了判定用の空リスト
        } else {
            return Observable.just(buf);
        }
    })
    .takeWhile(says -&gt; !says.isEmpty())  // 空リストになるまで繰り返す
    .subscribe(says -&gt; Log.d(TAG, dump(says)));
</code></pre>

<p>}
```</p>

<ul>
<li><a href="http://qiita.com/B73W56H84/items/519e27a1aed5e6d5304f#%E3%81%82%E3%82%8F%E3%81%9B%E3%81%A6%E8%AA%AD%E3%81%BF%E3%81%9F%E3%81%84">さまざまなズンドコキヨシ</a></li>
<li><a href="http://qiita.com/shunsugai@github/items/971a15461de29563bf90">ズンドコキヨシまとめ</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RxJava の Observable を Android DataBinding の ObservableField に変換する]]></title>
    <link href="http://blog.amay077.net/blog/2016/02/27/convert-rxjava-observable-to-android-databinding-observablefield/"/>
    <updated>2016-02-27T01:19:03+09:00</updated>
    <id>http://blog.amay077.net/blog/2016/02/27/convert-rxjava-observable-to-android-databinding-observablefield</id>
    <content type="html"><![CDATA[<p>　Android DataBinding で View とバインドできるデータクラスは <code>BaseObservable</code> から派生したクラスか、<code>ObservableField&lt;T&gt;</code> 型のフィールドのみです。</p>

<!--more-->


<p>　RxJavaベースの API やモデルクラスを使用している場合、更新通知は <code>rx.Observable&lt;T&gt;</code> を <code>subscribe</code> することで受けられるわけですが、それを View にバインドするには、<code>ObservableField&lt;T&gt;</code> に変換してあげなければなりません。</p>

<p>　結果、下のような Utility 関数を作ることになります。</p>

<p>```java
/<em>*
 * rx.Observable から ObservableField への変換をおこなう
 </em>/
static public <T> ObservableField<T> toObservableField(Observable<T> source, CompositeSubscription subscriptions) {</p>

<pre><code>final ObservableField&lt;T&gt; field = new ObservableField&lt;T&gt;();

subscriptions.add(
        // TODO onError も拾ったほうがいい
        source.subscribe(new Action1&lt;T&gt;() {
            @Override
            public void call(T x) {
                field.set(x);
            }
        })
);

return field;
</code></pre>

<p>}
```</p>

<p>　しかしこの方法はスマートでないと感じます。
　どうせ <code>ObservableField</code> も同じような概念のオブジェクトで、View が購読開始-終了をしているにすぎないはずなので、同じタイミングで、<code>rx.Observable&lt;T&gt;</code> の subscribe/unsubscribe をさせてあげれば良いはずです。</p>

<p>　ということで作ってみたのがこの <code>rx.Observable&lt;T&gt;</code> を <code>ObservableField&lt;T&gt;</code> に変換するクラス。</p>

<p>```java
import android.databinding.ObservableField;</p>

<p>import java.util.HashMap;
import java.util.Map;</p>

<p>import rx.Observable;
import rx.Subscription;
import rx.functions.Action1;</p>

<p>public class RxField<T> extends ObservableField<T> {</p>

<pre><code>private final Observable&lt;T&gt; observable;
private final Map&lt;Integer, Subscription&gt; sucscriptionMap = new HashMap&lt;Integer, Subscription&gt;();

public RxField(Observable&lt;T&gt; observable) {
    super();
    this.observable = observable;
}

public RxField(Observable&lt;T&gt; observable, T defaultValue) {
    super(defaultValue);
    this.observable = observable;
}

@Override
public synchronized void addOnPropertyChangedCallback(OnPropertyChangedCallback callback) {
    super.addOnPropertyChangedCallback(callback);

    sucscriptionMap.put(callback.hashCode(), observable.subscribe(new Action1&lt;T&gt;() {
        @Override
        public void call(T value) {
            set(value);
        }
    }));
}

@Override
public synchronized void removeOnPropertyChangedCallback(OnPropertyChangedCallback callback) {
    if (sucscriptionMap.containsKey(callback.hashCode())) {
        final Subscription subscription = sucscriptionMap.get(callback.hashCode());
        subscription.unsubscribe();
        sucscriptionMap.remove(callback.hashCode());
    }

    super.removeOnPropertyChangedCallback(callback);
}

@Override
public void set(T value) {
    // TODO should be readonly, because cannot set value to observable
    super.set(value);
}

public Observable&lt;T&gt; tObservable() {
    return observable;
}
</code></pre>

<p>}
```</p>

<p>　<code>ObservableField</code> は、View から購読されると <code>addOnPropertyChangedCallback</code> が呼ばれ、購読解除されると <code>removeOnPropertyChangedCallback</code> が呼ばれます(るはずです)。</p>

<p>　なので、このタイミングで <code>rx.Observable&lt;T&gt;</code> を <code>subscribe()</code>、<code>subscription.unsubscribe()</code> してあげます。購読者(View)が複数になる可能性があるので、 subscription は Map で管理しています。</p>

<p>　で、<code>rx.Observable&lt;T&gt;</code> の値が変わった時(<code>onNext()</code>)に、<code>ObservableField</code> の <code>set(value)</code> を呼んであげれば、<code>ObservableField</code> 側の変更通知(<code>notifyChanged</code>)が飛んで、View が更新されます。</p>

<p>　使い方はこんな感じで → <a href="https://github.com/amay077/StopWatchSample/tree/qiita_20160226/StopWatchAppAndroid/app/src/main/java/com/amay077/stopwatchapp/viewmodel/MainViewModel.java#L51-L67">StopWatchSample/StopWatchAppAndroid/app/src/main/java/com/amay077/stopwatchapp/viewmodel/MainViewModel.java</a>
　</p>

<h2>双方向には対応してません</h2>

<p>　この実装は、<code>rx.Observable</code> の更新を <code>ObservableField</code> 通知するだけです。逆方向（<code>ObservableField</code> の変更を <code>rx.Observable</code> に適用する）は対応していません。そもそも <code>rx.Observable</code> は値を設定できないので、それをしたければ <code>rx.Observable</code> の代わりに <code>rx.Subject</code> が必要です。</p>

<p><a href="http://qiita.com/amay077/items/b5c788bb3ee9ff84d9b4">Android Data Binding + MVVMパターンのサンプルを書いてみた</a> で作成したアプリに、これを適用してみたので、ご参考まで。</p>

<ul>
<li><a href="https://github.com/amay077/StopWatchSample/tree/qiita_20160226/StopWatchAppAndroid">StopWatchSample/StopWatchAppAndroid &ndash; github</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RxJava で Observable の並列処理を直列化する]]></title>
    <link href="http://blog.amay077.net/blog/2016/02/08/serialize-operation-in-rxjava/"/>
    <updated>2016-02-08T01:16:02+09:00</updated>
    <id>http://blog.amay077.net/blog/2016/02/08/serialize-operation-in-rxjava</id>
    <content type="html"><![CDATA[<p><code>rx.Observable&lt;T&gt;</code> のオペレータは、通常は非同期で、並列に処理されます。</p>

<!--more-->


<p>例えば以下のような場合:</p>

<p>```java
public void start() {</p>

<pre><code>Observable.range(1, 5)
    .flatMap(x -&gt; fatTask(x))
    .subscribe(x -&gt; Log.d(TAG, "onNext - " + x));
</code></pre>

<p>}</p>

<p>private final Random rand = new Random();
private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(5);</p>

<p>// ランダムにスリープした後 x を onNext する
private Observable<Integer> fatTask(final int x) {</p>

<pre><code>return Observable.create(subscriber -&gt; {
    long sleep = (long) (rand.nextDouble() * 10000L);
    Log.d(TAG, "fatTask(" + x + ") - start.");

    executor.schedule(() -&gt; {
        subscriber.onNext(x);
        subscriber.onCompleted();
    }, sleep, TimeUnit.MILLISECONDS);
});
</code></pre>

<p>}
```</p>

<p>このプログラムの出力はこうなります。</p>

<blockquote><p>出力:<br/>
fatTask(1) &ndash; start.<br/>
fatTask(2) &ndash; start.<br/>
fatTask(3) &ndash; start.<br/>
fatTask(4) &ndash; start.<br/>
fatTask(5) &ndash; start.<br/>
onNext &ndash; 3<br/>
onNext &ndash; 5<br/>
onNext &ndash; 4<br/>
onNext &ndash; 2<br/>
onNext &ndash; 1<br/></p></blockquote>

<p>fatTask は 1,2,3,4,5 の順で <em>完了を待たずに</em> 呼びだされます。
が、それぞれ処理にかかる時間が異なるので、 <code>onNext</code> が呼ばれる順は 1〜 とは限りません。</p>

<p>ソースとなる Stream の順番を崩したくない場合は、 <code>fatTask(1)</code> が完了してから <code>fatTask(2)</code> を開始する、というように直列化しなければなりません。</p>

<h2>Observable.Concat(concatWith)</h2>

<p>これを行うのが <code>Observable.Concat</code> です(RxJava では <code>Observable.concatWith</code> のようですね)。
複数の <code>Observable</code> を順に（完了してから次へ）処理していきます。</p>

<h3>使い方</h3>

<p><code>toList</code> で一旦ただの <code>List</code> にしてから、<code>concatWith</code> で数珠つなぎにします。</p>

<p>```java
public void start() {</p>

<pre><code>Observable.range(1, 5)
    .toList()
    .flatMap(list -&gt; {
        // fatTask(1).contat(fatTask(2)).contat(fatTask(3))... 
        // にする（fold 使えれば…)
        Observable&lt;Integer&gt; task = null;
        for (int x : list) {
            if (task == null) {
                task = fatTask(x);
            } else {
                task = task.concatWith(fatTask(x));
            }
        }
        return task;
    })
    .subscribe(x -&gt; Log.d(TAG, "onNext - " + x));
</code></pre>

<p>}
```</p>

<p>このプログラムの出力はこうなります。</p>

<blockquote><p>出力<br/>
fatTask(1) &ndash; start.<br/>
onNext &ndash; 1<br/>
fatTask(2) &ndash; start.<br/>
onNext &ndash; 2<br/>
fatTask(3) &ndash; start.<br/>
onNext &ndash; 3<br/>
fatTask(4) &ndash; start.<br/>
onNext &ndash; 4<br/>
fatTask(5) &ndash; start.<br/>
onNext &ndash; 5<br/></p></blockquote>

<p><code>fatTask(1)</code> の完了を待ってから、次の <code>fatTask(2)</code> が実行されています。</p>

<p>※
Rx.NET では、</p>

<p><code>csharp
static IObservable&lt;T&gt; Concat&lt;T&gt;(IEnumerable&lt;IObservable&lt;T&gt;&gt; sources)
</code></p>

<p>で、複数の <code>IObservable</code> を一括で渡せるのですが、 RxJava にはないようで、、、。</p>

<p><code>java
static &lt;T&gt; Observable&lt;T&gt; concatEager(Iterable&lt;? extends Observable&lt;? extends T&gt;&gt; sources)
</code></p>

<p>というのがあったんですが、期待通りうごいてくれず、 Eager? なんでしょう？</p>

<h2>ソースが無限リストだったら？</h2>

<p><code>toList</code> で一旦ただの List にしているのが非常に気に入らないですね。
<code>range(1, 5)</code> が <code>interval(1, TimeUnit.SECONDS)</code> のように無限の Stream だったら使えません。</p>

<p>そこで、 <code>concat</code> には、こんな overload もあります。</p>

<p><code>java
static &lt;T&gt; Observable&lt;T&gt; concat(Observable&lt;? extends Observable&lt;? extends T&gt;&gt; observables)
</code></p>

<p>Observable<T> を通知する Observable？ ややこしいですがこう使います。</p>

<p>```java
public void start() {</p>

<pre><code>// 2. を concat する
Observable.concat( 
    // 1. Observable&lt;Long&gt;
    Observable.interval(1, TimeUnit.SECONDS) 
        // 2. Long を Observable&lt;Integer&gt; に変換 
        //    → Observable&lt;Observable&lt;Integer&gt;&gt; になる
        .map(x -&gt; fatTask(x.intValue()))) 
    .subscribe(x -&gt; Log.d(TAG, "onNext - " + x));
</code></pre>

<p>}
```</p>

<p>このプログラムの出力はこうなります。</p>

<blockquote><p>出力<br/>
fatTask(0) &ndash; start.<br/>
onNext &ndash; 0<br/>
fatTask(1) &ndash; start.<br/>
onNext &ndash; 1<br/>
fatTask(2) &ndash; start.<br/>
onNext &ndash; 2<br/>
…つづく<br/></p></blockquote>

<p>無限リストながら、並列処理せずに順序通り動いてくれます。</p>

<p><code>interval</code> の値を単純に <code>map</code> で <code>Observable&lt;Integer&gt;</code> に変換してやります。するとこれは <code>Observable&lt;Observable&lt;Integer&gt;&gt;</code> になり、<code>concat</code> 可能になります。 <code>flatMap</code> だと平坦化されちゃうのでただの <code>map</code> です。</p>

<h2>まとめ</h2>

<p>Observable は普通は非同期で並列処理。
非同期ながら直列化したい場合は <code>Observable.concat</code> でできます。</p>

<ol>
<li>GPS から緯度経度を取得</li>
<li>なんか重い計算を行う</li>
<li>結果をテキストファイルに書き出す</li>
</ol>


<p>みたいな処理をするとき 3. を 1. の順序と同じにしたいのでこれを使います。</p>

<p>はじめ自分は <code>flatMap</code> で繋いでいくだけですべて直列化されているのかなーと勘違いしていたので、これを知った時は目からウロコでした。</p>

<h2>参考</h2>

<ul>
<li><a href="http://www.introtorx.com/content/v1.0.10621.0/12_CombiningSequences.html">Intro to Rx &ndash; Combining sequences</a></li>
<li><a href="http://reactivex.io/documentation/operators/concat.html">ReactiveX &ndash; Concat operator</a></li>
<li><a href="http://blog.okazuki.jp/entry/20120219/1329663635">Reactive Extensions再入門 その４１「どんどん合成するよ」 &ndash; かずきのBlog@hatena</a></li>
<li><a href="https://twitter.com/neuecc/status/695604984763650050">https://twitter.com/neuecc/status/695604984763650050</a> &ndash; @neuecc さんありがとうございます！</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RxJava の ImmediateScheduler と TrampolineScheduler の違い]]></title>
    <link href="http://blog.amay077.net/blog/2016/02/05/difference-immediatescheduler-and-trumpolinescheduler/"/>
    <updated>2016-02-05T01:30:59+09:00</updated>
    <id>http://blog.amay077.net/blog/2016/02/05/difference-immediatescheduler-and-trumpolinescheduler</id>
    <content type="html"><![CDATA[<p>RxJava のスケジューラの中に <a href="http://reactivex.io/RxJava/javadoc/rx/schedulers/TrampolineScheduler.html"><code>TrampolineScheduler</code></a> というのがあり、<a href="https://twitter.com/amay077/status/693341525464346624">なんじゃこれ？</a>とつぶやいたところ、 <a href="http://reactivex.io/RxJava/javadoc/rx/schedulers/TrampolineScheduler.html">Rx.NET の <code>CurrentThreadScheduler</code> と同じっぽい</a> と教えてもらいました。</p>

<!--more-->


<p>その流れで、類似の Scheduler である <a href="http://reactivex.io/RxJava/javadoc/rx/schedulers/ImmediateScheduler.html">ImmediateScheduler</a> との違いについて語られているトピックを紹介してもらいました。</p>

<blockquote class="twitter-tweet" lang="ja"><p lang="ja" dir="ltr"><a href="https://twitter.com/amay077">@amay077</a> この辺読みとくと良いと思います（tranpolineというキーワードも登場します） <a href="https://t.co/A5TzOiobsC">https://t.co/A5TzOiobsC</a></p>&mdash; Atsushi Eno (@atsushieno) <a href="https://twitter.com/atsushieno/status/693396949643317248">2016, 1月 30</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


<h1>CurrentThreadScheduler vs ImmediateScheduler</h1>

<ul>
<li><a href="https://social.msdn.microsoft.com/Forums/en-US/7f75482f-eff2-4938-9491-47fe870989e8/currentthreadscheduler-vs-immediatescheduler?forum=rx">CurrentThreadScheduler vs ImmediateScheduler</a></li>
</ul>


<p>紹介してもらったこのディスカッションを、頑張って翻訳してみました（めちゃくちゃなとこは訂正願います）。
RxJava では <code>CurrentThreadScheduler</code> を <code>TrampolineScheduler</code> に読み替えてください。</p>

<p>－－訳ここから－－</p>

<h2>Ohad 氏の質問</h2>

<blockquote><p>Hi
ImmediateScheduler&rsquo;s Schedule method is pretty straightforward &ndash; it simply invokes the action.
In contrast, CurrentThreadScheduler seems more involved &ndash; it creates something called a trampoline, which in turn iterates over an action queue, sleeping between invocations of items in the queue and so forth</p></blockquote>

<p>やあ、
<code>ImmediateScheduler.Schedule</code> メソッドは単純をアクションを呼び出します。
対照的に、 <code>CurrentThreadScheduler</code> は複雑に見えます。トランポリンと呼ばれるものを作り、それはアクション・キューで、順次スリープの間に呼び出されます。</p>

<blockquote><p>I&rsquo;ve been trying to follow the code with reflector but I&rsquo;m having a hard time understanding the difference. As far as I can tell, CurrentThreadSchedule&rsquo;s schedule method calls Trampoline &rsquo;s Run method, which will end up blocking the current thread until the queued action is performed (on the current thread as well) &ndash; apparently just like in the case of ImmediateScheduler</p></blockquote>

<p>私はコードを追ってみましたが、理解するのに苦労しています。分かる範囲では、 <code>CurrentThreadSchedule.Schedule</code> メソッドは <code>Trampoline.Run</code> メソッドを呼び出しています。これは現在のスレッドを、キューのアクションが実行されるまで(カレントスレッドも同様に)ブロックしようとします。 &ndash; どうも <code>ImmediateScheduler</code> のようにみえます。</p>

<blockquote><p>I realize I&rsquo;m missing something, so an explanation would be really appreciated
Thanks !</p></blockquote>

<p>何か理解が足りないと思うので、説明してもらえると嬉しいです。</p>

<blockquote><p>EDIT &ndash; In the meantime I&rsquo;ve found a couple of resources that may shed light on the subject, if anyone&rsquo;s interested:</p></blockquote>

<p>２つのリソースを見つけました。何かの手がかりになれば。</p>

<p><a href="http://channel9.msdn.com/blogs/j.van.gogh/controlling-concurrency-in-rx">http://channel9.msdn.com/blogs/j.van.gogh/controlling-concurrency-in-rx</a></p>

<p><a href="http://community.bartdesmet.net/blogs/bart/archive/2009/11/08/jumping-the-trampoline-in-c-stack-friendly-recursion.aspx">http://community.bartdesmet.net/blogs/bart/archive/2009/11/08/jumping-the-trampoline-in-c-stack-friendly-recursion.aspx</a></p>

<h2>Dave 氏の回答</h2>

<blockquote><p>Hi,</p>

<p>The trampoline seems to serve three purposes:</p></blockquote>

<p>やあ、
トランポリンは３つの目的を持っているように見えます。</p>

<blockquote><p>1- Prevents dead-locks from scheduler reentrancy.</p></blockquote>

<p>1- スケジューラーの割り込みからデッドロックを防ぎます。</p>

<blockquote><p>2- Prevents infinite loops in observables that require recursion through scheduler reentrancy.</p></blockquote>

<p>2- スケジューラーの割り込みを使った再帰が必要な Observable の無限ループを防ぎます。</p>

<blockquote><p>3- Cooperative single-threaded multitasking; I guess it&rsquo;s similar to the proposed async/await feature in C# 5.0.  Calling CurrentThreadScheduler.Schedule is sort of like using await when the currently executing code was also scheduled via CurrentThreadScheduler.</p></blockquote>

<p>3- シングルスレッドでの「<a href="http://www.sophia-it.com/content/%E3%83%8E%E3%83%B3%E3%83%97%E3%83%AA%E3%82%A8%E3%83%B3%E3%83%97%E3%83%86%E3%82%A3%E3%83%96%E3%83%9E%E3%83%AB%E3%83%81%E3%82%BF%E3%82%B9%E3%82%AF">協調的マルチタスキング</a>」; 私は C# 5.0 に提案されている async/await に近いものだと思います。<code>CurrentThreadScheduler.Schedule</code> の呼び出しは、現在実行中のコードも <code>CurrentThreadScheduler</code> でスケジュールされていたときに await を使用するようなものです。（訳注: C# の async/await は協調的マルチタスキングではないと思います。これは async/await 登場以前に予想で書かれたものかと。</p>

<blockquote><p>In the observable world, calling Subscribe should be an asynchronous operation.  There&rsquo;s a problem if the scheduling of an observable dead-locks or blocks the current thread indefinitely because it attempts to execute immediately and never completes.</p></blockquote>

<p>Observable の世界では、<code>Subscribe</code> の呼び出しは、非同期処理で行わなければなりません。Observable のスケジューリングがデッドロックまたはカレントスレッドを無期限にブロックする場合、すぐに実行しようとしても完了しないので、問題になります。</p>

<blockquote><p>Ignore the type of scheduler for a moment and consider a scheduled action that eventually, through some sequence of method calls, uses the same scheduler to schedule another action.</p></blockquote>

<p>ちょっとこのスケジューラを無視して、いずれは、いくつかのシーケンスは別のアクションをスケジュールするために、同じスケジューラを使用することを考えてみてください。</p>

<blockquote><p>With the ImmediateScheduler, the inner action is executed immediately.</p></blockquote>

<p><code>ImmediateScheduler</code> では、”内側のアクション” はすぐに実行されます。</p>

<blockquote><ul>
<li>If the outer action acquires some resource on which the inner action depends, and the inner action cannot acquire this resource until it&rsquo;s released by the outer action, then these actions dead-lock.</li>
</ul>
</blockquote>

<ul>
<li>外側のアクションが、内側のアクションが依存しているリソースを取得した場合、
内側のアクションは外側のアクションがリソースを開放するまでそれを取得できず、これらのアクションはデッドロックします。</li>
</ul>


<blockquote><ul>
<li>If the outer action depends upon the inner action, and the inner action depends upon the outer action, then this could result in an infinite loop that never yields control to other actions.</li>
</ul>
</blockquote>

<ul>
<li>外側のアクションは内部アクションに依存し、内部アクションは外側の行動に依存している場合、他のアクションに制御が移らない無限ループになります。</li>
</ul>


<blockquote><p>For example: Observable.Return(1).Repeat().Take(1)</p></blockquote>

<p>例: <code>Observable.Return(1).Repeat().Take(1)</code></p>

<blockquote><p>By default, Return uses the ImmediateScheduler to call OnNext(1) then OnCompleted().  Repeat does not introduce any concurrency, so it sees OnCompleted immediately and then immediately resubscribes to Return.  Because there&rsquo;s no trampoline in Return, this pattern repeats itself, blocking the current thread indefinitely.  Calling Subscribe on this observable never returns.  See <a href="https://social.msdn.microsoft.com/Forums/en-US/f9c1a7a6-d6a3-44fd-ba8c-e6845b1717b2/possible-bug-repeat-observables-using-immediate-scheduler?forum=rx">this discussion</a> for more information.</p></blockquote>

<p>既定では、<code>Return</code> は <code>ImmediateScheduler</code> を使って <code>OnNext(1)</code> そして <code>OnCompleted()</code> を呼び出します。 <code>Repeat</code> はどんな並列性も使用しません、なのですぐに <code>OnCompleted</code> を検知して、すぐに <code>Return</code> を再購読します。なぜなら、 <code>Return</code> にはトランポリンがないので、このパターンは自分自身を繰り返し、無期限に現在のスレッドをブロックし続けます。この Observable を <code>Subscribe</code> すると処理が返ってきません。詳細については、<a href="https://social.msdn.microsoft.com/Forums/en-US/f9c1a7a6-d6a3-44fd-ba8c-e6845b1717b2/possible-bug-repeat-observables-using-immediate-scheduler?forum=rx">この説明</a>を参照してください。</p>

<blockquote><p>With the CurrentThreadScheduler, the inner action is scheduled (queued) for execution when the outer action ends.  Conceptually, inner actions are bounced on the trampoline until the current thread is ready to execute them.</p></blockquote>

<p><code>CurrentThreadScheduler</code> では、内側のアクションは、外側のアクションが終了された時に実行されるようにスケジュールされます。コンセプトとしては、内側のアクションは、現在のスレッドが実行可能になるまでトランポリンの上で跳ねます。</p>

<blockquote><ul>
<li>If the outer action acquires some resource on which the inner action depends, and the inner action cannot acquire this resource until it&rsquo;s released by the outer action, then these actions do not dead-lock because the inner action is not executed until the outer action completes.</li>
</ul>
</blockquote>

<ul>
<li>外側のアクションが、内側のアクションが依存しているリソースを取得し、内側のアクションは外側のアクションによってそれらが解放されるまで取得できない場合、これらのアクションはデッドロックしません、なぜなら。内側のアクションは外側のアクションが終了するまで実行されないためです。</li>
</ul>


<blockquote><ul>
<li>If the outer action recurses when the inner action completes, then there won&rsquo;t be an immediately infinite loop because the inner action does not complete until the outer action completes first.</li>
</ul>
</blockquote>

<ul>
<li>外側のアクションが内側のアクションが終了した時に再帰的な場合、無限ループになりません。なぜなら、内側のアクションは外側のアクションが完了するまで完了しないためです。</li>
</ul>


<blockquote><p>For example: Observable.Return(1, Scheduler.CurrentThread).Repeat().Take(1)</p></blockquote>

<p>例: <code>Observable.Return(1, Scheduler.CurrentThread).Repeat().Take(1)</code></p>

<blockquote><p>Here, Return is using the CurrentTheadScheduler to call OnNext(1) then OnCompleted().  Repeat does not introduce any concurrency, so it sees OnCompleted immediately and then immediately resubscribes to Return; however, this second subscription to Return schedules its (inner) actions on the trampoline because it&rsquo;s still executing on the OnCompleted callback from the first scheduled (outer) action, thus the repetition does not occur immediately.  This allows Repeat to return a disposable to Take, which eventually calls OnCompleted, cancels the repetition by disposing Repeat, and ultimately the call from Subscribe returns.</p></blockquote>

<p>ここでは、 <code>Return</code> は <code>CurrentTheadScheduler</code> を使って <code>OnNext(1)</code> そして <code>OnCompleted()</code> を呼び出します。 <code>Repeat</code> はどんな並列性も使用しません、なのですぐに <code>OnCompleted</code> を検知して、すぐに <code>Return</code> を再購読します。しかし、この２回目の <code>Return</code> の購読（内側のアクション）はトランポリンの上にあります、なぜなら、最初にスケジュールされたアクション（外側のアクション）の <code>OnCompleted</code> コールバックの上でまだ実行中であるからです、なので繰り返しはすぐに発生しません。
これは、<code>Repeat</code> は <code>Take</code> に disposable(subscription) を返すことができます、それはやがて <code>OnCompleted</code> を呼び出し、<code>Subscribe</code> の返値から <code>Repeat</code> の破棄により繰り返しをキャンセルします。</p>

<blockquote><p>Keep in mind that the examples with Return and Repeat do not introduce any concurrency.  When you call Subscribe, it will not return until the observable completes regardless of which of these schedulers you choose.  With the ImmediateScheduler, Take calls OnCompleted but it cannot cancel the repetition, so Subscribe blocks indefinitely.  Alternatively, the CurrentThreadScheduler allows for cooperative single-threaded multitasking between the Return and Repeat operators, thus allowing Take to cancel the repetition without having to introduce any concurrency.</p></blockquote>

<p>覚えておいて欲しいのは、 <code>Return</code> → <code>Repeat</code> はどんな並列性も使用しないことです。<code>Subscribe</code> を呼び出すと、あなたが選択した Scheduler に関係なく、Observable が終了するまで処理を返しません。 <code>ImmediateScheduler</code> では、<code>Take</code> は <code>OnCompleted</code> を呼び出しますが、繰り返しをキャンセルできません。なので <code>Subscribe</code> は無期限にブロックしてしまいます。代わりに <code>CurrentThreadScheduler</code> は <code>Return</code> と <code>Repeat</code> 操作の間、協調的マルチタスキングが可能になります、なので、並行性を使用することなく、繰り返しをキャンセルすることができます。</p>

<p>－－訳ここまで－－</p>

<h1>つまり？</h1>

<p><code>ImmediateScheduler</code> が処理をただ単に(割り込んで)実行するだけであるのに対し、 <code>CurrentScheduler</code>(<code>TrampolineScheduler</code>) は、擬似的なマルチタスクを行う（懐かしの VB の <a href="http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1112681621"><code>DoEvents</code></a> かぁ？）ことでデッドロックを防いでいる、と理解しました。</p>

<p>Dave 氏の回答にあった例</p>

<p><code>csharp
Observable.Return(1).Repeat().Take(1).Subscribe(...);
Debug.WriteLine("Hoge");
</code></p>

<p>を実行すると、確かに処理が帰ってこない、<code>Debug.WriteLine</code> へ進まないんです。</p>

<p>これはヤバい、<code>ImmediateScheduler</code> マジやべえと。
で、 RxJava でも同じだよねえと、</p>

<p><code>java
// just が ImmediateScheduler 使うのか不安だったから subscribeOn しているよ
Observable.just(1).subscribeOn(Schedulers.immediate()).repeat().take(1).subscribe(...);
Log.debug(TAG, "Hoge");
</code></p>

<p>と書いて実行してみたら、処理が帰ってくる！ <code>Log.debug</code> も実行される！
なんだこの違いは？改善されているのか、試し方が悪いのか。。。</p>

<p>なんだかモヤモヤした終わりかたですが、今回は <code>ImmediateScheduler</code> はちょっと要注意だというところまでです。</p>

<blockquote><p>In the observable world, calling Subscribe should be an asynchronous operation.</p></blockquote>

<p>との言葉通り、Rx.NET/RxJava を使うときは非同期にしたい事が全てだと思いますが、オペレータによっては既定で <code>ImmediateScheduler</code> を使うものもあるので、必ず <code>subscribeOn/observeOn</code> をするクセをつけておいた方がいいのかな？と思いました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Data Binding + MVVMパターンのサンプルを書いてみた]]></title>
    <link href="http://blog.amay077.net/blog/2016/01/28/creating-android-databinding-with-mvvm-pattern-sample/"/>
    <updated>2016-01-28T23:59:59+09:00</updated>
    <id>http://blog.amay077.net/blog/2016/01/28/creating-android-databinding-with-mvvm-pattern-sample</id>
    <content type="html"><![CDATA[<p><code>notifyPropertyChanged</code> とか、<a href="https://ufcpp.wordpress.com/2009/12/28/inotifypropertychanged-%E3%81%AE%E5%AE%9F%E8%A3%85/">どこかで見たことのある</a>機能が満載の <a href="http://developer.android.com/intl/ja/tools/data-binding/guide.html">Android Data Binding</a> ですが、登場以来あまり追えてなかったのでやっとサンプルをつくってみました。</p>

<!--more-->


<p>といっても</p>

<ul>
<li><a href="http://qiita.com/amay077/items/8464a22e3063642112ed">RxJava + MVVM パターンで作るストップウォッチアプリ &ndash; Qiita</a></li>
</ul>


<p>で作ったストップウォッチアプリを Data Binding 化しただけです。</p>

<p><a href="http://qiita.com/amay077/items/8464a22e3063642112ed#model-viewmodel-viewmvvm-%E3%81%A7%E8%80%83%E3%81%88%E3%82%8B">前回</a> との違いを図に示します。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/rxjava_mvvm_stopwatch_03.png" alt="" /></p>

<ul>
<li>View-ViewModel で全面的に使用していた <code>rx.Observable&lt;T&gt;</code> の代わりに、<code>ObservableField&lt;T&gt;</code> を使用。</li>
<li>View側で「オレオレDataBinding」を実装していた箇所を、Android の Data Binding に置き換え。つまりバインディングの定義はレイアウトxmlへ記述。</li>
<li>Model は相変わらず <code>rx.Observable&lt;T&gt;</code> のまま。なので ViewModel で <code>rx.Observable&lt;T&gt;</code> → <code>ObservableField&lt;T&gt;</code> へ変換。</li>
<li>メソッドとのバインドに <code>Command</code> を使用していたが、Android Data Binding の <a href="http://developer.android.com/intl/ja/tools/data-binding/guide.html#binding_events">Binding Events</a> に置き換え。</li>
<li>ListView とデータ群のバインディングの方法が分からなかったので、<a href="http://developer.android.com/intl/ja/tools/data-binding/guide.html#custom_setters">カスタムBinding</a>で対応。(listItem のバインディングじゃなくて、リストの件数の増減を反映させるやつ。)</li>
<li>ArrayAdapter 使ってたんだけどこいつは Binding に対応していない？ので Adapter を自作。</li>
</ul>


<h2>MainActivity のバインディングの定義</h2>

<p><code>activity_main.xml</code> はこんな感じ。</p>

<p><code>@{ }</code> で  <code>MainViewModel</code> に用意した <code>ObservableField&lt;T&gt;</code> または、イベントハンドラとバインドしてます。</p>

<p>```xml activity_main.xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
&lt;layout xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code>xmlns:tools="http://schemas.android.com/tools"
xmlns:app="http://schemas.android.com/apk/res-auto"&gt;

&lt;data&gt;
    &lt;variable name="viewModel"
        type="com.amay077.stopwatchapp.viewmodel.MainViewModel"/&gt;
&lt;/data&gt;
&lt;LinearLayout
    android:layout_width="match_parent"
    android:layout_height="match_parent" android:paddingLeft="@dimen/activity_horizontal_margin"
    android:orientation="vertical"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    android:paddingBottom="@dimen/activity_vertical_margin" tools:context=".MainActivity"&gt;

    &lt;TextView android:id="@+id/textTime"
        tools:text="00:00.000"
        android:text="@{viewModel.formattedTime}"
        android:textSize="50sp"
        android:gravity="center_horizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" /&gt;

    &lt;Button
        android:id="@+id/buttonStartStop"
        android:text="@{viewModel.runButtonTitle}"
        android:onClick="@{viewModel.onClickStartOrStop}"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" /&gt;
    &lt;Button
        android:id="@+id/buttonLap"
        android:text="Lap"
        android:enabled="@{viewModel.isRunning}"
        android:onClick="@{viewModel.onClickLap}"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" /&gt;
    &lt;Switch
        android:id="@+id/switchVisibleMillis"
        android:checked="@{viewModel.isVisibleMillis}"
        android:onClick="@{viewModel.onClickToggleVisibleMillis}"
        android:text="小数点以下を表示"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" /&gt;

    &lt;ListView
        android:id="@+id/listLaps"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:formattedLaps="@{viewModel}" /&gt;
&lt;/LinearLayout&gt;
</code></pre>

<p></layout>
```</p>

<p>ListView で <code>app:formattedLaps="@{viewModel}"</code> としているところだけが特殊で、これは <code>MainActivity.java</code> に定義したカスタムSetter を呼び出します。</p>

<p><code>MainActivity.java</code> はこんな感じ。</p>

<p>```java MainActivity.java
public class MainActivity extends AppCompatActivity {</p>

<pre><code>private /* final */  MainViewModel _viewModel;
private CompositeSubscription _subscriptions = new CompositeSubscription();

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    final ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);

    _viewModel = new MainViewModel(this.getApplicationContext());
    binding.setViewModel(_viewModel);

    // ■ViewModel からの Message の受信（省略）
}

/**
 * ListView と ViewModel のカスタムバインディング
 *
 * TODO 本当は viewModel.formattedLaps とバインドしたい
 */
@BindingAdapter("formattedLaps")
public static void setFormattedLaps(ListView listView, final MainViewModel viewModel) {
    final LapAdapter adapter = new LapAdapter(listView.getContext());
    listView.setAdapter(adapter);

    // formattedLaps が変化した時に呼ばれるイベントで、Adapterを洗い替え。
    viewModel.formattedLaps.addOnPropertyChangedCallback(new android.databinding.Observable.OnPropertyChangedCallback() {
        @Override
        public void onPropertyChanged(android.databinding.Observable sender, int propertyId) {
            adapter.clear();
            adapter.addAll(viewModel.formattedLaps.get());
        }
    });

    // バインド時に値を更新
    adapter.clear();
    adapter.addAll(viewModel.formattedLaps.get());
}

@Override
protected void onDestroy() {
    _viewModel.unsubscribe();
    super.onDestroy();
}
</code></pre>

<p>}
```</p>

<p>オレオレBindingがごっそり消えてスッキリ。
<code>setFormattedLaps</code> がカスタムSetterで、この中で <code>MainViewModel.formatterLaps</code> を監視し、値が変わったら Adapter を総入れ替えしてます。が、これが正しいやり方かわからない。
<a href="https://android.googlesource.com/platform/frameworks/data-binding/+/android-6.0.0_r7/extensions/baseAdapters/src/main/java/android/databinding/adapters">extensions/baseAdapters/src/main/java/android/databinding/adapters</a> にはそれらしいのがないでござるよ。。。</p>

<h2>ViewModel 側</h2>

<p>この辺みてください。大したことはやってないです。（急に雑になったw）</p>

<ul>
<li><a href="https://github.com/amay077/StopWatchSample/blob/android_data_binding_v1_20160128/StopWatchAppAndroid/app/src/main/java/com/amay077/stopwatchapp/viewmodel/MainViewModel.java">StopWatchSample/MainViewModel.java</a></li>
<li><a href="https://github.com/amay077/StopWatchSample/blob/android_data_binding_v1_20160128/StopWatchAppAndroid/app/src/main/java/com/amay077/stopwatchapp/viewmodel/ObservableUtil.java">StopWatchSample/ObservableUtil.java</a></li>
</ul>


<p><code>ObservableUtil.toObservableField</code> とか、もうどっかの誰かがやってそうだし、事実上標準の何かが出てきそうな気がすごくします。</p>

<h2>おまけ</h2>

<h3>Messenger を RxJava ベースにした</h3>

<ul>
<li><a href="http://qiita.com/yyaammaa/items/57d8baa1e80346e67e47">OttoからRxJavaへの移行ガイド &ndash; Qiita</a></li>
<li><a href="http://qiita.com/kubode/items/a4ece37834446c9a39c8">Android &ndash; RxJavaでEventBusを作った &ndash; Qiita</a></li>
</ul>


<p>らしいので、自作してた <code>Messenger</code> を <a href="https://github.com/amay077/StopWatchSample/blob/android_data_binding_v1_20160128/StopWatchAppAndroid/app/src/main/java/com/amay077/stopwatchapp/frameworks/messengers/Messenger.java">RxJava ベースにしてみました</a>。
ViewModel→Viewの通知
にしか使ってないので、あまり <code>rx.Observable&lt;T&gt;</code> にする旨味はなかったですね。あ、<code>ofType</code> って便利ですね。</p>

<h2>まとめ</h2>

<p>今回作ったアプリの全ソースは</p>

<ul>
<li><a href="https://github.com/amay077/StopWatchSample/tree/android_data_binding_v1_20160128/StopWatchAppXamarin/StopWatchApp.Android">StopWatchApp.Android</a></li>
</ul>


<p>です。</p>

<p>.NETアプリケーション開発では、ViewModel を View にバインドすることが殆どなので、典型的な例としてやってみました。</p>

<p>レイアウトに直接バインドを定義できるので、コードビハインド(Javaのソース)はスッキリしますが、個人的にはあまり好きではありません。
コードビハインドに(<code>textTime.SetBinding(v =&gt; v.Text, viewModel.Time)</code> みたく)書いた方が、定義情報がまとまっていて管理しやすい、デバッグしやすいと思うからです。（同じ理由で、xmlに直接記述する <a href="http://developer.android.com/intl/ja/tools/data-binding/guide.html#expression_language">Expression Language</a> も好きではありません。）
が、今のところ、Android Data Binding では、レイアウトXMLでしかバインディングを定義できないようですね。</p>

<p>ともあれ、<a href="https://github.com/gueei/AndroidBinding">AndroidBinding</a> とか Butter Knife はこれで駆逐されていく（前者はすでに息してなさそうですが）と思うので、新しいアプリ開発では積極的に使っていこうかなと思います。</p>

<h2>参考</h2>

<ul>
<li><a href="http://developer.android.com/intl/ja/tools/data-binding/guide.html">Data Binding Guide | Android Developers</a></li>
<li><a href="http://qiita.com/izumin5210/items/2784576d86ce6b9b51e6#after-listview">Android &ndash; Butter Knife、今までありがとう。 Data Binding、これからよろしく。 &ndash; Qiita</a></li>
<li><a href="http://tech.recruit-mp.co.jp/mobile/android-data-binding/">[Android] – Data Bindingつかってみた – NET BIZ DIV. TECH BLOG</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
