<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Objective-C | Experiments Never Fail]]></title>
  <link href="http://amay077.github.io/blog/categories/objective-c/atom.xml" rel="self"/>
  <link href="http://amay077.github.io/"/>
  <updated>2014-03-07T16:25:20+09:00</updated>
  <id>http://amay077.github.io/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Objective-C と Java と C# でクロージャ的な書き方の比較]]></title>
    <link href="http://amay077.github.io/blog/2014/01/29/closure-like-statement-comparison-with-objc-java-csharp/"/>
    <updated>2014-01-29T15:52:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/01/29/closure-like-statement-comparison-with-objc-java-csharp</id>
    <content type="html"><![CDATA[<p>クロージャとかラムダとか匿名** とか名前はいろいろですけど、各言語の書き方と動き（特に変数の扱い）について比べてみました。</p>

<p>ついでに非同期処理の例にもなってしまいました。</p>

<!--more-->


<h3>Objective-C</h3>

<p>Blocks を使います。</p>

<p>```objc Obj-C
int x = 1;
__block int y = 2;</p>

<p>dispatch_queue_t q_global = dispatch_get_global_queue(0, 0);
dispatch_async(q_global, ^{</p>

<pre><code>x = 10; // できない(コンパイルエラー
y = 20; // できる

int z = x + y;

[self dispValue:z]; // self の参照カウンタが+1される
</code></pre>

<p>});
```</p>

<p>普通に宣言した変数を Block の中で使うと、自動的に「キャプチャ」され、変数の複製される。この変数には、 Block 内では代入できずコンパイルエラーとなる。
<code>__block</code> を付けた変数は、Block 内外で同じ実体を参照でき、代入もできる。
<code>self</code> やプロパティを Block 内で使用すると参照カウンタがインクリメントされ、明示的に release しないとリークする。
あるいは、Block 外で <code>__weak</code> を付けた変数に代入しておくと、これは参照カウンタがインクリメントされない。</p>

<h3>Java 6 (Android ベースなので…)</h3>

<p>匿名クラスです。</p>

<p>```java Java
int x = 1;
final int y = 2;</p>

<p>ExecutorService executor = Executors.newSingleThreadExecutor();
executor.submit(new Runnable() {</p>

<pre><code>@Override
public void run() {
    y = 20; // できない(コンパイルエラー
    int z = x + y; // できない(コンパイルエラー

    String typeName = this.getClass().getInterfaces()[0].getName(); // Runnable になる
}
</code></pre>

<p>});
```</p>

<p>Java は匿名クラスの実装中に使える変数はかなり制限がある。
普通に宣言した変数は、匿名クラス内では使えない(コンパイルエラー)。
<code>final</code> を付けて宣言した変数は、匿名クラス内では参照のみ可能。ちょうど Objective-C の通常変数を Block 内で使った時と同じ。
Obj-C の <code>self</code> にあたる <code>this</code> は匿名クラス内では、その匿名クラスを示す。</p>

<h3>C＃</h3>

<p>ラムダ式です。</p>

<p>```csharp C#
int x = 1;
const int y = 2;
Task.Factory.StartNew(() =>
{</p>

<pre><code>x = 10; // OK
y = 20; // これはダメ、const だから。
var z = x + y;

var typeName = this.GetType().Name;
</code></pre>

<p>});
```</p>

<p>C# はかなりゆる〜い印象。
普通に宣言した変数を、ラムダ式の中でも自由に read/write できてしまう。write できちゃうのはこわい。
<code>this</code> は、ラムダ式の外側のクラスを示す。
　</p>

<h2>所感</h2>

<p>個人的には、Java のガチガチなのが好きかも。できる事が限定されているのでミスしにくい。
Objective-C は、ローカル変数は良いけど、self とか使っちゃうミス起こしそう。
C# は、普通に書き換えられて超不安、という感じ。なるべく const 使うようにしたい。
　
　
　</p>

<p>しかし記述量は C# が一番少ないですね、Xamarin いいよ Xamarin。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C の Dictionary は、キーに基本データ型が使えないのね ]]></title>
    <link href="http://amay077.github.io/blog/2014/01/28/cannot-using-int-type-in-objc-dictionary/"/>
    <updated>2014-01-28T15:49:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/01/28/cannot-using-int-type-in-objc-dictionary</id>
    <content type="html"><![CDATA[<p>Obj-C 慣れないもので、こんな所でハマってた。
くやしいので他の言語と比較しておく。
当然ながら Dictionary に限った話でない（はず）。</p>

<!--more-->


<h3>Objective-C</h3>

<p><code>obj-c Objective-C
NSMutableDictionary* dic = [[NSMutableDictionary alloc] init];
[dic setObject:@"hoge" forKey:[NSNumber numberWithInt:1]]; // これは OK
[dic setObject:@"huga" forKey:@1]; // これも OK (@1 は NSNumber のリテラル構文なので)
[dic setObject:@"piyo" forKey:2]; // これはダメ（落ちる
</code></p>

<p>キーと値が他の言語と逆なのにまずハマって、
キーに int型 の値を入れてたのに気づかずまたハマった。
せめてコンパイルエラーにして欲しいよ。
言語仕様上、型指定できないのでキーも値もどんな型でも突っ込めちゃう、こわい。</p>

<h3>Java</h3>

<p><code>java Java
Map&lt;Integer, String&gt; dic = new HashMap&lt;Integer, String&gt;();
Map&lt;int, String&gt; dic = new HashMap&lt;int, String&gt;(); // これはダメ(コンパイルできない)
dic.put(Integer.valueOf(1), "hoge"); // OK
dic.put(2, "piyo"); // これも OK（へー
</code></p>

<p>int と Integer ってのがあって、int を使って HashMap を宣言できない。
これはコンパイル時に分かるので良いけど、int と Integer の変換が必要なことがしばしば。</p>

<h3>C＃</h3>

<p><code>csharp C#
var dic = new Dictionary&lt;int, string&gt;(); // 型推論＆Generic
dic.Add(1, "hoge"); // OK
dic.Add(2, "piyo");
dic.Add(3, "huga");
</code></p>

<p>一番スッキリ書けますね。
　
　
　</p>

<p>…Xamarin いいよ、Xamarin</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARC のメモリ解放タイミングを調べた]]></title>
    <link href="http://amay077.github.io/blog/2013/09/02/when-release-memory-by-arc/"/>
    <updated>2013-09-02T21:55:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/09/02/when-release-memory-by-arc</id>
    <content type="html"><![CDATA[<p>一つの関数内で容量の大きなファイルを読み込み加工する処理を連続して行っていたらメモリが足りなくなった。</p>

<!--more-->


<p>ARC ではスコープを外れ(て参照カウンタがゼロになっ)たオブジェクトは、すぐに破棄されると思っていたのでしばらくハマった。</p>

<h2>問題のソース(ARC使用)</h2>

<p>ローカルでもWebでも何でもいいけど、ファイルから無視できない程度の容量のデータの読み込みを繰り返す処理。</p>

<p>```obj-c
- (IBAction)buttonDownWithArc:(id)sender {</p>

<pre><code>NSString* path = @".../bigdata.img";

for (int i = 0; i &lt; 10000; i++) {
    NSData* data = [NSData dataWithContentsOfFile:path];
    [NSThread sleepForTimeInterval:0.5];
    data = nil;
}
</code></pre>

<p>}
```</p>

<p>これを Instruments でプロファイルするとこうなる。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/arc_memory_release_timing_01.png" alt="img" /></p>

<p>じゃんじゃんメモリ確保してしまう（汗
ARC で <code>data</code> は <code>nil</code> にしてるからスコープ外れた時にメモリ解放されると思っていたのだが。</p>

<p>ちなみにこの関数の処理が終了すると、メモリが解放される。</p>

<h2>非ARC でやってみた</h2>

<p>メモリ管理をマニュアルでやったらどうなるかを確認した。</p>

<p>```obj-c
- (IBAction)buttonDownNoArc:(id)sender {</p>

<pre><code>NSString* path = @".../bigdata.img";

for (int i = 0; i &lt; 10000; i++) {
    NSData* data = [NSData dataWithContentsOfFile:path];
    [NSThread sleepForTimeInterval:0.5];
    [data dealloc];
    data = nil;
}
</code></pre>

<p>}
```</p>

<p>この時のメモリ確保状況は、期待した通りになった。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/arc_memory_release_timing_02.png" alt="img" /></p>

<p>メモリ使用量が線形に<strong>増えない</strong>ことが分かる。ARC 利用時にもこうなるようにしたい。</p>

<p>状況は、スコープ内変数の破棄が、関数を抜ける時に遅延されている。
ARC 周りの情報をいろいろ漁っていて、AutoReleasePool との関わりが怪しいと予想した。</p>

<ul>
<li><a href="http://blog.natsuapps.com/2011/11/ios5-arc-overview.html">[iOS5] ARC (Automatic Reference Counting) : Overview - iOS 開発ブログ Natsu's note </a></li>
</ul>


<p>より引用：</p>

<blockquote><h3>retain, release, autorelease, deallocはコンパイラのお仕事</h3>

<p>ARCを利用する場合、コンパイラが</p>

<ul>
<li>retain, release, autoreleaseを挿入してくれる（自分で呼んではいけない。コンパイラエラーになる）。</li>
<li>deallocを適切な位置に挿入してくれる（deallocのオーバーライドは可能。ただし[super dealloc]は不可能）。</li>
</ul>


<p>ことになります。</p></blockquote>

<p>コンパイラにより関数単位で <code>@autoreleasepool {  }</code> が挿入されているとしたら、最初の図のような動きになるはず。ということは、for ループの中に @autorelease を持ってったらどうか？</p>

<h2>ARC + @autoreleasepool 版</h2>

<p>for の中の処理を <code>@autoreleasepool { }</code> で括ってみた。</p>

<p>```obj-c
- (IBAction)buttonDownWithArcAndAutoRelease:(id)sender {</p>

<pre><code>for (int i = 0; i &lt; 100; i++) {
    @autoreleasepool {
        NSData* data = [NSData dataWithContentsOfFile:_path];
        [NSThread sleepForTimeInterval:0.5];
    }
}
</code></pre>

<p>}
```</p>

<p>すると、</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/arc_memory_release_timing_03.png" alt="img" /></p>

<p>やたー、期待する動きになったぞ。</p>

<h2>まとめ</h2>

<p>とここまで調べて、しばらく Obj-C さわってなかったので埃をかぶっていた</p>

<ul>
<li><a href="http://www.amazon.co.jp/gp/product/4844331094?ie=UTF8&amp;camp=1207&amp;creative=8411&amp;creativeASIN=4844331094&amp;linkCode=shr&amp;tag=oku2008-22">エキスパートObjective-Cプログラミング -iOS/OS Xのメモリ管理とマルチスレッド-</a></li>
</ul>


<p>を引っ張り出してきて読んだら、P.25 にまさにその事が書かれていて泣いた。</p>

<blockquote><p>とはいえ、autorelease されたオブジェクトが大量に発生した場合、NSAutoReleasePool のオブジェクトが破棄されない限り、それらのオブジェクトは release されないので、メモリ不足に陥る場合があります。典型的な例は、大量の画像をリサイズしながら読み込む場合でしょう。…</p>

<pre><code>   for (int i = 0; i &lt; 画像数; i++) {
       /*
        * 画像読み込み処理
        * autoreleaseされたオブジェクトが大量発生。
        * NSAutoReleasePoolのオブジェクトが破棄されないため
        * いずれメモリ不足発生！
        */           
   }
</code></pre></blockquote>

<p>勉強しなおします。。。</p>
]]></content>
  </entry>
  
</feed>
