<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Objective-C | Experiments Never Fail]]></title>
  <link href="http://amay077.github.io/blog/categories/objective-c/atom.xml" rel="self"/>
  <link href="http://amay077.github.io/"/>
  <updated>2014-07-07T13:18:32+09:00</updated>
  <id>http://amay077.github.io/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS4.x 対応のソースコードから「新しいAPI」を使っている箇所を探す]]></title>
    <link href="http://amay077.github.io/blog/2014/05/14/find-new-api-in-ios4-supported-code/"/>
    <updated>2014-05-14T15:26:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/05/14/find-new-api-in-ios4-supported-code</id>
    <content type="html"><![CDATA[<p>　アプリを iOS4.x でも動作させたい場合、Xcode のプロジェクト設定で Deployment Target を "4.x" (4.3とか) に設定します。
一方で Base SDK は最新のものしか選べません、今だと "7.1"。</p>

<!--more-->


<p>　この状態だと、コード中で iOS5以降に追加された API を使っていると、iOS4.x端末では当然クラッシュします。</p>

<p>　Target を 4.x にしてるんだから、クラッシュしそうなコードがあったら Xcode が検出して警告して欲しいんですが、そういう機能はないみたいです。(実はあるのでしょうか？ Android だと警告どころかビルドエラーになるので、iOSアプリ開発は大変不便だな、と思ってしまいます。Obj-C は JavaScript みたいなもんだから仕方がない、のは分かりますが)</p>

<p>　 <a href="http://oclint.org/">OCLint</a> という静的コード解析ツールを見つけましたが、機能をざっと見ても、APIバージョンをチェックするものはなさそうです。（試したことはありません）</p>

<p>　しかし「動かしてみないと分からない」のは不安すぎるので、なんとかして「新しいAPIを使っていないか？」をチェックする方法を考えて、行ってみました。</p>

<h2>新しいAPIを使っている箇所を見つける方法</h2>

<h3>A. iOS Developer Center に API の更新内容がまとめられたページがあります。</h3>

<ul>
<li><a href="https://developer.apple.com/library/ios/releasenotes/General/iOS50APIDiff/index.html#//apple_ref/doc/uid/TP40011042">iOS 4.3 to iOS 5.0 API Differences</a></li>
<li><a href="https://developer.apple.com/LIBRARY/ios/releasenotes/General/iOS60APIDiffs/index.html">iOS 5.1 to iOS 6.0 API Differences</a></li>
<li><a href="https://developer.apple.com/LIBRARY/IOS/releasenotes/General/iOS70APIDiffs/index.html">iOS 6.1 to iOS 7.0 API Differences</a></li>
</ul>


<h3>B. これらのページから「変更のあった API のリスト」を抽出します。</h3>

<p>具体的には以下のようなリストを作ります。</p>

<blockquote><p>Added vImageAlphaBlend_ARGB8888
Added vImageAlphaBlend_ARGBFFFF
…</p></blockquote>

<p>この作業は自動化したいのですが、お試しなので手動でテキストエディタと <strong>EXCEL</strong> を駆使して作成しました。</p>

<h3>C. あとは、自分のソースコードに対して、順次 grep をかけるスクリプトを作ります。</h3>

<p>修正リストの中には、 <code>-[ALAsset setImageData:metadata:completionBlock:]</code> のように名前付き引数だったりする API もあるので、正規表現でなるべくヒットするように置換します。</p>

<p><code>sh find_new_api.sh
grep -nr "ALAsset.*setImageData.*metadata.*completionBlock:.*;" ./src/*
grep -nr "vImageAlphaBlend_ARGB8888.*;" ./src/*
grep -nr "vImageAlphaBlend_ARGBFFFF.*;" ./src/*
…
</code></p>

<h3>D. このスクリプトを実行して何か出たら、そこが「新しいAPIを使ってる箇所」です。</h3>

<h2>まとめ</h2>

<h3>注意点</h3>

<ul>
<li>クラス自体が追加されているものも、メソッドの追加として探しているので、他のクラスと誤認することがあります。</li>
<li>正規表現が完全に正しいかよくわかりません（ソースコードに改行含む場合とか）</li>
</ul>


<p>簡単で、不格好な方法ですが、十分に機能してくれますし、開発者の知識やテストだけに頼るのに比べれば随分と安心できます。</p>

<p>APIの更新情報を JSON か何かで提供してくれたら、もうちょっと楽なんですけども。。。</p>

<p>iOSアプリの開発者のみなさんは、どうやって iOS の下位バージョン互換性を担保しているのでしょうか？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS アプリでアラート出してボタンが押されるまで待つ？方法を Objective-C と Xamarin.iOS で比べてみた]]></title>
    <link href="http://amay077.github.io/blog/2014/03/10/using-uialertview-objc-vs-xamarin/"/>
    <updated>2014-03-10T22:09:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/03/10/using-uialertview-objc-vs-xamarin</id>
    <content type="html"><![CDATA[<p>なんか割とニーズがあるみたいで。</p>

<!--more-->


<ul>
<li><a href="http://teapipin.blog10.fc2.com/blog-entry-224.html">【Objective-C】アラート（UIAlertView）でボタンを押すまで次の処理を待つ方法 - creativi.tea</a></li>
<li><a href="http://cocoadays.blogspot.jp/2011/05/ios.html">Cocoaの日々: [iOS] 非同期処理を同期処理に変える</a></li>
<li><a href="http://qiita.com/edo_m18/items/cb1d9061d91e572b58eb">[Objective-C] UIAlertViewを同期処理する - Qiita </a></li>
</ul>


<h2>Objective-C の場合</h2>

<p><code>UIAlertView</code> は、結果を受け取るのが deletgate で、 Objective-C では、(Blocks を使わなければ) 受け取りが別メソッドになってしまう、しかも複数のアラートの結果が同じメソッドに飛んでくるので、tag値で分岐…とかいろいろで、ホントに使うのが面倒ですね。</p>

<p>さらに、「アラートの結果を受け取ってから、次の処理を行う」という処理を素直に記述したいと思うと、上で示したような「アラートを表示して、結果が得られるまで while で待つ」というなんとも不格好なコードになってしまいます。下にも書いてみました。（あ、メンバ変数も使わざるを得ないし。）</p>

<p>```objective-c HogeViewController.m
@implementation HogeViewController {</p>

<pre><code>NSInteger _buttonIndex;
</code></pre>

<p>}</p>

<ul>
<li>(IBAction)buttonTouchUp:(id)sender
{
  UIAlertView *alert = [[UIAlertView alloc] initWithTitle:nil

<pre><code>                          message:NSLocalizedString(@"なにか押して",@"")
                         delegate:self
                cancelButtonTitle:@"Cancel"
                otherButtonTitles:@"OK", nil];
</code></pre>

<p>  [alert show];</p>

<p>  // ボタンが押されるまで待つ
  <em>buttonIndex = -1;
  while (</em>buttonIndex == -1) {</p>

<pre><code>  [[NSRunLoop currentRunLoop]
   runUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.5f]]; // 0.5秒
</code></pre>

<p>  }</p>

<p>  label1.text = [NSString stringWithFormat:@"%d 番目のボタンを押したね", (int)_buttonIndex];
}</p></li>
</ul>


<p>-(void)alertView:(UIAlertView*)alertView clickedButtonAtIndex:(NSInteger)buttonIndex
{</p>

<pre><code>_buttonIndex = buttonIndex;
</code></pre>

<p>}
```</p>

<p><code>[NSRunLoop runUntilDate]</code> なんて VB6 の <code>DoEvents</code> ですもんねなつかしい。</p>

<h2>Xamarin.iOS(C#) の場合</h2>

<p>Objective-C ではややこしかった「アラートを出す→ボタンを押す→次の処理へ」という流れ、 Xamarin.iOS と C# ならこんなにシンプルに書けます。</p>

<p>```csharp HogeViewController.cs
async void OnButtonTouch(object sender, EventArgs e)
{</p>

<pre><code>var buttonIndex = await MsgBox("", "なにか押して", "Cancel", "OK");
label1.Text = buttonIndex.ToString() + "番目を押したね";  
</code></pre>

<p>}</p>

<p>static Task<int> MsgBox(string title, string message,</p>

<pre><code>string cancelButtonTitle, params string[] buttons)
</code></pre>

<p>{</p>

<pre><code>var comp = new TaskCompletionSource&lt;int&gt;();

var alert = new UIAlertView(title, message, null, cancelButtonTitle, buttons);
alert.Clicked += (_, e) =&gt; comp.TrySetResult(e.ButtonIndex);
alert.Show();

return comp.Task;
</code></pre>

<p>}
```</p>

<p>VB6 が懐かしくて <code>MsgBox</code> ってメソッドにしちゃいましたよ。</p>

<p><code>MsgBox</code> は、Task を返す <strong>非同期な</strong> メソッドです。この非同期処理が終了するのは、<code>TaskCompletionSource.TrySetResult</code> が呼び出された時、つまりアラートのボタンが押された時です。この非同期処理の戻り値はもちろん押したボタンのインデックスです。</p>

<p>非同期メソッドである <code>MsgBox</code> を呼び出す側には、キーワード <code>await</code> が付いています。
これをつけると、次行以降の処理は、非同期の MsgBox が完了した後、順次実行されます、つまり待っているわけではなく、どちらかというと、 <strong>処理を後続に付け足す</strong> 感じ。
さらに、この後続処理はUIスレッドで実行されるので、UIパーツへのアクセスも問題ありません。</p>

<p><code>async</code> はメソッド内で <code>await</code> を使うときにつけるお約束。</p>

<p>async/await は一見、ただの同期処理に見えるので理解して使う必要がありますが、Objective-C のコードに比べて、とても簡潔に、流れるように書くことができるのが分かると思います。</p>

<p><strong>C# の非常に強力な言語機能は、<a href="https://xamarin.com/">Xamarin</a> を選択する大きな理由の一つです。</strong></p>

<h2>参考</h2>

<ul>
<li><a href="http://stackoverflow.com/questions/4613071/messagebox-show-and-dialogresult-equivalent-in-monotouch">c# - Messagebox.Show and DialogResult equivalent in MonoTouch - Stack Overflow</a></li>
<li><a href="http://ufcpp.wordpress.com/2012/11/12/asyncawait%e3%81%a8%e5%90%8c%e6%99%82%e5%ae%9f%e8%a1%8c%e5%88%b6%e5%be%a1/">async/awaitと同時実行制御 | ++C++; // 未確認飛行 C ブログ</a></li>
<li><a href="http://www.slideshare.net/bleistift/asyncawait2">async/await不要論</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C と Java と C# でクロージャ的な書き方の比較]]></title>
    <link href="http://amay077.github.io/blog/2014/01/29/closure-like-statement-comparison-with-objc-java-csharp/"/>
    <updated>2014-01-29T15:52:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/01/29/closure-like-statement-comparison-with-objc-java-csharp</id>
    <content type="html"><![CDATA[<p>クロージャとかラムダとか匿名** とか名前はいろいろですけど、各言語の書き方と動き（特に変数の扱い）について比べてみました。</p>

<p>ついでに非同期処理の例にもなってしまいました。</p>

<!--more-->


<h3>Objective-C</h3>

<p>Blocks を使います。</p>

<p>```objc Obj-C
int x = 1;
__block int y = 2;</p>

<p>dispatch_queue_t q_global = dispatch_get_global_queue(0, 0);
dispatch_async(q_global, ^{</p>

<pre><code>x = 10; // できない(コンパイルエラー
y = 20; // できる

int z = x + y;

[self dispValue:z]; // self の参照カウンタが+1される
</code></pre>

<p>});
```</p>

<p>普通に宣言した変数を Block の中で使うと、自動的に「キャプチャ」され、変数の複製される。この変数には、 Block 内では代入できずコンパイルエラーとなる。
<code>__block</code> を付けた変数は、Block 内外で同じ実体を参照でき、代入もできる。
<code>self</code> やプロパティを Block 内で使用すると参照カウンタがインクリメントされ、明示的に release しないとリークする。
あるいは、Block 外で <code>__weak</code> を付けた変数に代入しておくと、これは参照カウンタがインクリメントされない。</p>

<h3>Java 6 (Android ベースなので…)</h3>

<p>匿名クラスです。</p>

<p>```java Java
int x = 1;
final int y = 2;</p>

<p>ExecutorService executor = Executors.newSingleThreadExecutor();
executor.submit(new Runnable() {</p>

<pre><code>@Override
public void run() {
    y = 20; // できない(コンパイルエラー
    int z = x + y; // できない(コンパイルエラー

    String typeName = this.getClass().getInterfaces()[0].getName(); // Runnable になる
}
</code></pre>

<p>});
```</p>

<p>Java は匿名クラスの実装中に使える変数はかなり制限がある。
普通に宣言した変数は、匿名クラス内では使えない(コンパイルエラー)。
<code>final</code> を付けて宣言した変数は、匿名クラス内では参照のみ可能。ちょうど Objective-C の通常変数を Block 内で使った時と同じ。
Obj-C の <code>self</code> にあたる <code>this</code> は匿名クラス内では、その匿名クラスを示す。</p>

<h3>C＃</h3>

<p>ラムダ式です。</p>

<p>```csharp C#
int x = 1;
const int y = 2;
Task.Factory.StartNew(() =>
{</p>

<pre><code>x = 10; // OK
y = 20; // これはダメ、const だから。
var z = x + y;

var typeName = this.GetType().Name;
</code></pre>

<p>});
```</p>

<p>C# はかなりゆる〜い印象。
普通に宣言した変数を、ラムダ式の中でも自由に read/write できてしまう。write できちゃうのはこわい。
<code>this</code> は、ラムダ式の外側のクラスを示す。
　</p>

<h2>所感</h2>

<p>個人的には、Java のガチガチなのが好きかも。できる事が限定されているのでミスしにくい。
Objective-C は、ローカル変数は良いけど、self とか使っちゃうミス起こしそう。
C# は、普通に書き換えられて超不安、という感じ。なるべく const 使うようにしたい。
　
　
　</p>

<p>しかし記述量は C# が一番少ないですね、Xamarin いいよ Xamarin。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C の Dictionary は、キーに基本データ型が使えないのね ]]></title>
    <link href="http://amay077.github.io/blog/2014/01/28/cannot-using-int-type-in-objc-dictionary/"/>
    <updated>2014-01-28T15:49:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/01/28/cannot-using-int-type-in-objc-dictionary</id>
    <content type="html"><![CDATA[<p>Obj-C 慣れないもので、こんな所でハマってた。
くやしいので他の言語と比較しておく。
当然ながら Dictionary に限った話でない（はず）。</p>

<!--more-->


<h3>Objective-C</h3>

<p><code>obj-c Objective-C
NSMutableDictionary* dic = [[NSMutableDictionary alloc] init];
[dic setObject:@"hoge" forKey:[NSNumber numberWithInt:1]]; // これは OK
[dic setObject:@"huga" forKey:@1]; // これも OK (@1 は NSNumber のリテラル構文なので)
[dic setObject:@"piyo" forKey:2]; // これはダメ（落ちる
</code></p>

<p>キーと値が他の言語と逆なのにまずハマって、
キーに int型 の値を入れてたのに気づかずまたハマった。
せめてコンパイルエラーにして欲しいよ。
言語仕様上、型指定できないのでキーも値もどんな型でも突っ込めちゃう、こわい。</p>

<h3>Java</h3>

<p><code>java Java
Map&lt;Integer, String&gt; dic = new HashMap&lt;Integer, String&gt;();
Map&lt;int, String&gt; dic = new HashMap&lt;int, String&gt;(); // これはダメ(コンパイルできない)
dic.put(Integer.valueOf(1), "hoge"); // OK
dic.put(2, "piyo"); // これも OK（へー
</code></p>

<p>int と Integer ってのがあって、int を使って HashMap を宣言できない。
これはコンパイル時に分かるので良いけど、int と Integer の変換が必要なことがしばしば。</p>

<h3>C＃</h3>

<p><code>csharp C#
var dic = new Dictionary&lt;int, string&gt;(); // 型推論＆Generic
dic.Add(1, "hoge"); // OK
dic.Add(2, "piyo");
dic.Add(3, "huga");
</code></p>

<p>一番スッキリ書けますね。
　
　
　</p>

<p>…Xamarin いいよ、Xamarin</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARC のメモリ解放タイミングを調べた]]></title>
    <link href="http://amay077.github.io/blog/2013/09/02/when-release-memory-by-arc/"/>
    <updated>2013-09-02T21:55:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/09/02/when-release-memory-by-arc</id>
    <content type="html"><![CDATA[<p>一つの関数内で容量の大きなファイルを読み込み加工する処理を連続して行っていたらメモリが足りなくなった。</p>

<!--more-->


<p>ARC ではスコープを外れ(て参照カウンタがゼロになっ)たオブジェクトは、すぐに破棄されると思っていたのでしばらくハマった。</p>

<h2>問題のソース(ARC使用)</h2>

<p>ローカルでもWebでも何でもいいけど、ファイルから無視できない程度の容量のデータの読み込みを繰り返す処理。</p>

<p>```obj-c
- (IBAction)buttonDownWithArc:(id)sender {</p>

<pre><code>NSString* path = @".../bigdata.img";

for (int i = 0; i &lt; 10000; i++) {
    NSData* data = [NSData dataWithContentsOfFile:path];
    [NSThread sleepForTimeInterval:0.5];
    data = nil;
}
</code></pre>

<p>}
```</p>

<p>これを Instruments でプロファイルするとこうなる。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/arc_memory_release_timing_01.png" alt="img" /></p>

<p>じゃんじゃんメモリ確保してしまう（汗
ARC で <code>data</code> は <code>nil</code> にしてるからスコープ外れた時にメモリ解放されると思っていたのだが。</p>

<p>ちなみにこの関数の処理が終了すると、メモリが解放される。</p>

<h2>非ARC でやってみた</h2>

<p>メモリ管理をマニュアルでやったらどうなるかを確認した。</p>

<p>```obj-c
- (IBAction)buttonDownNoArc:(id)sender {</p>

<pre><code>NSString* path = @".../bigdata.img";

for (int i = 0; i &lt; 10000; i++) {
    NSData* data = [NSData dataWithContentsOfFile:path];
    [NSThread sleepForTimeInterval:0.5];
    [data dealloc];
    data = nil;
}
</code></pre>

<p>}
```</p>

<p>この時のメモリ確保状況は、期待した通りになった。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/arc_memory_release_timing_02.png" alt="img" /></p>

<p>メモリ使用量が線形に<strong>増えない</strong>ことが分かる。ARC 利用時にもこうなるようにしたい。</p>

<p>状況は、スコープ内変数の破棄が、関数を抜ける時に遅延されている。
ARC 周りの情報をいろいろ漁っていて、AutoReleasePool との関わりが怪しいと予想した。</p>

<ul>
<li><a href="http://blog.natsuapps.com/2011/11/ios5-arc-overview.html">[iOS5] ARC (Automatic Reference Counting) : Overview - iOS 開発ブログ Natsu's note </a></li>
</ul>


<p>より引用：</p>

<blockquote><h3>retain, release, autorelease, deallocはコンパイラのお仕事</h3>

<p>ARCを利用する場合、コンパイラが</p>

<ul>
<li>retain, release, autoreleaseを挿入してくれる（自分で呼んではいけない。コンパイラエラーになる）。</li>
<li>deallocを適切な位置に挿入してくれる（deallocのオーバーライドは可能。ただし[super dealloc]は不可能）。</li>
</ul>


<p>ことになります。</p></blockquote>

<p>コンパイラにより関数単位で <code>@autoreleasepool {  }</code> が挿入されているとしたら、最初の図のような動きになるはず。ということは、for ループの中に @autorelease を持ってったらどうか？</p>

<h2>ARC + @autoreleasepool 版</h2>

<p>for の中の処理を <code>@autoreleasepool { }</code> で括ってみた。</p>

<p>```obj-c
- (IBAction)buttonDownWithArcAndAutoRelease:(id)sender {</p>

<pre><code>for (int i = 0; i &lt; 100; i++) {
    @autoreleasepool {
        NSData* data = [NSData dataWithContentsOfFile:_path];
        [NSThread sleepForTimeInterval:0.5];
    }
}
</code></pre>

<p>}
```</p>

<p>すると、</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/arc_memory_release_timing_03.png" alt="img" /></p>

<p>やたー、期待する動きになったぞ。</p>

<h2>まとめ</h2>

<p>とここまで調べて、しばらく Obj-C さわってなかったので埃をかぶっていた</p>

<ul>
<li><a href="http://www.amazon.co.jp/gp/product/4844331094?ie=UTF8&amp;camp=1207&amp;creative=8411&amp;creativeASIN=4844331094&amp;linkCode=shr&amp;tag=oku2008-22">エキスパートObjective-Cプログラミング -iOS/OS Xのメモリ管理とマルチスレッド-</a></li>
</ul>


<p>を引っ張り出してきて読んだら、P.25 にまさにその事が書かれていて泣いた。</p>

<blockquote><p>とはいえ、autorelease されたオブジェクトが大量に発生した場合、NSAutoReleasePool のオブジェクトが破棄されない限り、それらのオブジェクトは release されないので、メモリ不足に陥る場合があります。典型的な例は、大量の画像をリサイズしながら読み込む場合でしょう。…</p>

<pre><code>   for (int i = 0; i &lt; 画像数; i++) {
       /*
        * 画像読み込み処理
        * autoreleaseされたオブジェクトが大量発生。
        * NSAutoReleasePoolのオブジェクトが破棄されないため
        * いずれメモリ不足発生！
        */           
   }
</code></pre></blockquote>

<p>勉強しなおします。。。</p>
]]></content>
  </entry>
  
</feed>
