<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: mvvm | Experiments Never Fail]]></title>
  <link href="http://blog.amay077.net/blog/categories/mvvm/atom.xml" rel="self"/>
  <link href="http://blog.amay077.net/"/>
  <updated>2016-07-10T19:53:33+09:00</updated>
  <id>http://blog.amay077.net/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android Data Binding + MVVMパターンのサンプルを書いてみた]]></title>
    <link href="http://blog.amay077.net/blog/2016/01/28/creating-android-databinding-with-mvvm-pattern-sample/"/>
    <updated>2016-01-28T23:59:59+09:00</updated>
    <id>http://blog.amay077.net/blog/2016/01/28/creating-android-databinding-with-mvvm-pattern-sample</id>
    <content type="html"><![CDATA[<p><code>notifyPropertyChanged</code> とか、<a href="https://ufcpp.wordpress.com/2009/12/28/inotifypropertychanged-%E3%81%AE%E5%AE%9F%E8%A3%85/">どこかで見たことのある</a>機能が満載の <a href="http://developer.android.com/intl/ja/tools/data-binding/guide.html">Android Data Binding</a> ですが、登場以来あまり追えてなかったのでやっとサンプルをつくってみました。</p>

<!--more-->


<p>といっても</p>

<ul>
<li><a href="http://qiita.com/amay077/items/8464a22e3063642112ed">RxJava + MVVM パターンで作るストップウォッチアプリ &ndash; Qiita</a></li>
</ul>


<p>で作ったストップウォッチアプリを Data Binding 化しただけです。</p>

<p><a href="http://qiita.com/amay077/items/8464a22e3063642112ed#model-viewmodel-viewmvvm-%E3%81%A7%E8%80%83%E3%81%88%E3%82%8B">前回</a> との違いを図に示します。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/rxjava_mvvm_stopwatch_03.png" alt="" /></p>

<ul>
<li>View-ViewModel で全面的に使用していた <code>rx.Observable&lt;T&gt;</code> の代わりに、<code>ObservableField&lt;T&gt;</code> を使用。</li>
<li>View側で「オレオレDataBinding」を実装していた箇所を、Android の Data Binding に置き換え。つまりバインディングの定義はレイアウトxmlへ記述。</li>
<li>Model は相変わらず <code>rx.Observable&lt;T&gt;</code> のまま。なので ViewModel で <code>rx.Observable&lt;T&gt;</code> → <code>ObservableField&lt;T&gt;</code> へ変換。</li>
<li>メソッドとのバインドに <code>Command</code> を使用していたが、Android Data Binding の <a href="http://developer.android.com/intl/ja/tools/data-binding/guide.html#binding_events">Binding Events</a> に置き換え。</li>
<li>ListView とデータ群のバインディングの方法が分からなかったので、<a href="http://developer.android.com/intl/ja/tools/data-binding/guide.html#custom_setters">カスタムBinding</a>で対応。(listItem のバインディングじゃなくて、リストの件数の増減を反映させるやつ。)</li>
<li>ArrayAdapter 使ってたんだけどこいつは Binding に対応していない？ので Adapter を自作。</li>
</ul>


<h2>MainActivity のバインディングの定義</h2>

<p><code>activity_main.xml</code> はこんな感じ。</p>

<p><code>@{ }</code> で  <code>MainViewModel</code> に用意した <code>ObservableField&lt;T&gt;</code> または、イベントハンドラとバインドしてます。</p>

<p>```xml activity_main.xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
&lt;layout xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code>xmlns:tools="http://schemas.android.com/tools"
xmlns:app="http://schemas.android.com/apk/res-auto"&gt;

&lt;data&gt;
    &lt;variable name="viewModel"
        type="com.amay077.stopwatchapp.viewmodel.MainViewModel"/&gt;
&lt;/data&gt;
&lt;LinearLayout
    android:layout_width="match_parent"
    android:layout_height="match_parent" android:paddingLeft="@dimen/activity_horizontal_margin"
    android:orientation="vertical"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    android:paddingBottom="@dimen/activity_vertical_margin" tools:context=".MainActivity"&gt;

    &lt;TextView android:id="@+id/textTime"
        tools:text="00:00.000"
        android:text="@{viewModel.formattedTime}"
        android:textSize="50sp"
        android:gravity="center_horizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" /&gt;

    &lt;Button
        android:id="@+id/buttonStartStop"
        android:text="@{viewModel.runButtonTitle}"
        android:onClick="@{viewModel.onClickStartOrStop}"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" /&gt;
    &lt;Button
        android:id="@+id/buttonLap"
        android:text="Lap"
        android:enabled="@{viewModel.isRunning}"
        android:onClick="@{viewModel.onClickLap}"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" /&gt;
    &lt;Switch
        android:id="@+id/switchVisibleMillis"
        android:checked="@{viewModel.isVisibleMillis}"
        android:onClick="@{viewModel.onClickToggleVisibleMillis}"
        android:text="小数点以下を表示"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" /&gt;

    &lt;ListView
        android:id="@+id/listLaps"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:formattedLaps="@{viewModel}" /&gt;
&lt;/LinearLayout&gt;
</code></pre>

<p></layout>
```</p>

<p>ListView で <code>app:formattedLaps="@{viewModel}"</code> としているところだけが特殊で、これは <code>MainActivity.java</code> に定義したカスタムSetter を呼び出します。</p>

<p><code>MainActivity.java</code> はこんな感じ。</p>

<p>```java MainActivity.java
public class MainActivity extends AppCompatActivity {</p>

<pre><code>private /* final */  MainViewModel _viewModel;
private CompositeSubscription _subscriptions = new CompositeSubscription();

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    final ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);

    _viewModel = new MainViewModel(this.getApplicationContext());
    binding.setViewModel(_viewModel);

    // ■ViewModel からの Message の受信（省略）
}

/**
 * ListView と ViewModel のカスタムバインディング
 *
 * TODO 本当は viewModel.formattedLaps とバインドしたい
 */
@BindingAdapter("formattedLaps")
public static void setFormattedLaps(ListView listView, final MainViewModel viewModel) {
    final LapAdapter adapter = new LapAdapter(listView.getContext());
    listView.setAdapter(adapter);

    // formattedLaps が変化した時に呼ばれるイベントで、Adapterを洗い替え。
    viewModel.formattedLaps.addOnPropertyChangedCallback(new android.databinding.Observable.OnPropertyChangedCallback() {
        @Override
        public void onPropertyChanged(android.databinding.Observable sender, int propertyId) {
            adapter.clear();
            adapter.addAll(viewModel.formattedLaps.get());
        }
    });

    // バインド時に値を更新
    adapter.clear();
    adapter.addAll(viewModel.formattedLaps.get());
}

@Override
protected void onDestroy() {
    _viewModel.unsubscribe();
    super.onDestroy();
}
</code></pre>

<p>}
```</p>

<p>オレオレBindingがごっそり消えてスッキリ。
<code>setFormattedLaps</code> がカスタムSetterで、この中で <code>MainViewModel.formatterLaps</code> を監視し、値が変わったら Adapter を総入れ替えしてます。が、これが正しいやり方かわからない。
<a href="https://android.googlesource.com/platform/frameworks/data-binding/+/android-6.0.0_r7/extensions/baseAdapters/src/main/java/android/databinding/adapters">extensions/baseAdapters/src/main/java/android/databinding/adapters</a> にはそれらしいのがないでござるよ。。。</p>

<h2>ViewModel 側</h2>

<p>この辺みてください。大したことはやってないです。（急に雑になったw）</p>

<ul>
<li><a href="https://github.com/amay077/StopWatchSample/blob/android_data_binding_v1_20160128/StopWatchAppAndroid/app/src/main/java/com/amay077/stopwatchapp/viewmodel/MainViewModel.java">StopWatchSample/MainViewModel.java</a></li>
<li><a href="https://github.com/amay077/StopWatchSample/blob/android_data_binding_v1_20160128/StopWatchAppAndroid/app/src/main/java/com/amay077/stopwatchapp/viewmodel/ObservableUtil.java">StopWatchSample/ObservableUtil.java</a></li>
</ul>


<p><code>ObservableUtil.toObservableField</code> とか、もうどっかの誰かがやってそうだし、事実上標準の何かが出てきそうな気がすごくします。</p>

<h2>おまけ</h2>

<h3>Messenger を RxJava ベースにした</h3>

<ul>
<li><a href="http://qiita.com/yyaammaa/items/57d8baa1e80346e67e47">OttoからRxJavaへの移行ガイド &ndash; Qiita</a></li>
<li><a href="http://qiita.com/kubode/items/a4ece37834446c9a39c8">Android &ndash; RxJavaでEventBusを作った &ndash; Qiita</a></li>
</ul>


<p>らしいので、自作してた <code>Messenger</code> を <a href="https://github.com/amay077/StopWatchSample/blob/android_data_binding_v1_20160128/StopWatchAppAndroid/app/src/main/java/com/amay077/stopwatchapp/frameworks/messengers/Messenger.java">RxJava ベースにしてみました</a>。
ViewModel→Viewの通知
にしか使ってないので、あまり <code>rx.Observable&lt;T&gt;</code> にする旨味はなかったですね。あ、<code>ofType</code> って便利ですね。</p>

<h2>まとめ</h2>

<p>今回作ったアプリの全ソースは</p>

<ul>
<li><a href="https://github.com/amay077/StopWatchSample/tree/android_data_binding_v1_20160128/StopWatchAppXamarin/StopWatchApp.Android">StopWatchApp.Android</a></li>
</ul>


<p>です。</p>

<p>.NETアプリケーション開発では、ViewModel を View にバインドすることが殆どなので、典型的な例としてやってみました。</p>

<p>レイアウトに直接バインドを定義できるので、コードビハインド(Javaのソース)はスッキリしますが、個人的にはあまり好きではありません。
コードビハインドに(<code>textTime.SetBinding(v =&gt; v.Text, viewModel.Time)</code> みたく)書いた方が、定義情報がまとまっていて管理しやすい、デバッグしやすいと思うからです。（同じ理由で、xmlに直接記述する <a href="http://developer.android.com/intl/ja/tools/data-binding/guide.html#expression_language">Expression Language</a> も好きではありません。）
が、今のところ、Android Data Binding では、レイアウトXMLでしかバインディングを定義できないようですね。</p>

<p>ともあれ、<a href="https://github.com/gueei/AndroidBinding">AndroidBinding</a> とか Butter Knife はこれで駆逐されていく（前者はすでに息してなさそうですが）と思うので、新しいアプリ開発では積極的に使っていこうかなと思います。</p>

<h2>参考</h2>

<ul>
<li><a href="http://developer.android.com/intl/ja/tools/data-binding/guide.html">Data Binding Guide | Android Developers</a></li>
<li><a href="http://qiita.com/izumin5210/items/2784576d86ce6b9b51e6#after-listview">Android &ndash; Butter Knife、今までありがとう。 Data Binding、これからよろしく。 &ndash; Qiita</a></li>
<li><a href="http://tech.recruit-mp.co.jp/mobile/android-data-binding/">[Android] – Data Bindingつかってみた – NET BIZ DIV. TECH BLOG</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RxJava + MVVM パターンで作るストップウォッチアプリ]]></title>
    <link href="http://blog.amay077.net/blog/2015/12/24/creating-stopwatchapp-using-rxjava-and-mvvm-patternn/"/>
    <updated>2015-12-24T23:59:59+09:00</updated>
    <id>http://blog.amay077.net/blog/2015/12/24/creating-stopwatchapp-using-rxjava-and-mvvm-patternn</id>
    <content type="html"><![CDATA[<p>　これは <a href="http://qiita.com/advent-calendar/2015/rxjava">RxJava Advent Calendar 2015 24日目</a> の記事です。</p>

<p>先日、</p>

<ul>
<li><a href="http://ytabuchi.hatenablog.com/entry/2015/12/20/012007">JXUGC #9 Xamarin.Forms Mvvm 実装方法 Teachathon を開催しました &ndash; Xamarin 日本語情報</a></li>
</ul>


<p>というイベントがありまして、エクセルソフトの田淵さんが作成したストップウォッチのアプリケーション(注:田淵さんはプログラマではないｗ)を、MVVM識者の方々が「MVVMとしてはこうあるべきだ」と叩きまくる、という恐ろしい?ものでした。</p>

<!--more-->


<p>私はこの勉強会には参加できなかったのですが、ストリーミングとか見て、</p>

<blockquote class="twitter-tweet" lang="ja"><p lang="ja" dir="ltr">僕もストップウォッチ作ってみるかー</p>&mdash; ジェットあめいカスタム (@amay077) <a href="https://twitter.com/amay077/status/677561989359472640">2015, 12月 17</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>などとつぶやいたらご指名されてしまいました(^^)
このイベントは Xamarin を使ったアプリ製作でしたが、せっかくなので <strong>RxJava + MVVM</strong> で作ってみました。
(ご指名に応えないといけないのでその後 Xamarin版も製作)</p>

<h1>ストップウォッチアプリの仕様</h1>

<p>上記リンクからの引用です。</p>

<ul>
<li>Start/Stop ボタン、Lap ボタン</li>
<li>StartするとラップボタンはEnable.ストップするとDisable

<ul>
<li>スタートしてからの経過時間をXX'XX.XXXみたいな感じで表示</li>
</ul>
</li>
<li>履歴をListViewで残す</li>
<li>ストップしたら結果をダイアログで出して分岐？</li>
<li>今までのラップよりMin, Maxなどをダイアログに表示して次のページに遷移 ←ここ勝手に Toast に仕様変更しましたｗ</li>
<li>スイッチの切り替えで、ミリ秒の桁を表示/非表示</li>
</ul>


<p>こんな機能を満たすサンプルを</p>

<ol>
<li>RxJava を使った Android アプリ(Java言語)</li>
<li>Reactive Extensions, ReactiveProperty を使った Android アプリ(Xamarin, C#言語)</li>
<li>Reactive Extensions, ReactiveProperty を使った iOS アプリ(Xamarin, C#言語)</li>
</ol>


<p>でそれぞれ作ってみました。</p>

<h1>とりあえず、作ったもの</h1>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/rxjava_mvvm_stopwatch_00.gif" alt="つくったもの" /></p>

<p>左は Android-Java製、右は Xamarin.iOS製です。(Xamarin.Android製は省略)</p>

<h1>1. RxJava を使った Android アプリ(Java言語)</h1>

<h2>Model-ViewModel-View(MVVM) で考える</h2>

<p>構成図っぽいものを描くとこんな感じになります。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/rxjava_mvvm_stopwatch_01.png" alt="クラス図的なの" /></p>

<h3>Model</h3>

<p>　この仕様だと、ストップウォッチの一通りの機能を満たすクラスが Model になります。これを <code>StopWatchModel</code> という名前にしました。</p>

<p>  <strong>「ロジック」は、すべてこの層（このクラス）に書きます。</strong>
　
　例えば、ストップウォッチのタイマーを実行するには、 RxJava で <code>Observable.interval</code> としますが、これを ViewModel層に書いたら「負け」です。
　
また、ストップウォッチの実行は、画面の表示/破棄と連動しなくてよい(画面遷移しても計測し続けるべき)なので、StopWatchModel の生存期間は、アプリケーションの起動時から終了まで、という事になります。</p>

<p>　RxJava を全面的に使いたいので、 StopWatchModel のプロパティは全て <code>Observable&lt;T&gt;</code> にしました。RxJava を使わなかったらプロパティではなくコールバックですね。
　何かメソッドを実行したら、その結果は全て <code>Observable&lt;T&gt;</code> を通じて通知される仕組みです。なので原則として Model のメソッドの戻り値は <code>void</code> です。</p>

<h3>ViewModel</h3>

<p>　しつこいようですが <strong>ここにロジックを書いたら負け</strong> です。
個人としては、条件分岐もしたくない、変数宣言もしたくない、くらいのつもりでいます。もし書いてしまったら「それはModelの方が適切ではないか？」を検討します。</p>

<p>　ViewModel の役割は、Model のプロパティ(コールバック)を、View用に変換して流すこと、Viewのための機能をコマンドとして公開することです。</p>

<p>　例えば、仕様の内、</p>

<blockquote><p>スイッチの切り替えで、ミリ秒の桁を表示/非表示</p></blockquote>

<p>　が、「View用に変換」の良い例になります。
　私の実装では、ミリ秒の桁を表示するか否かの bool 値を、format関数の書式文字列に変換しています。(View側で format して表示しています。)
　↓のような感じです。</p>

<p>```java
/<em>* 時間の表示フォーマット </em>/
public final Observable<String> timeFormat; // field</p>

<p>this.timeFormat = _stopWatch.isVisibleMillis.map(visible &ndash;></p>

<pre><code>visible ? "mm:ss.SSS" : "mm:ss");
</code></pre>

<p>```</p>

<p>RxJava で「変換」とくれば、 <code>map</code> など、 <code>Observable</code> の投影系のメソッドの出番となります。</p>

<p>ViewModel が公開するプロパティも、基本的には <code>Observable&lt;T&gt;</code> になりました。(これはこのアプリの仕様上、OneWayバインディング＜=Modelによるデータの変化をViewに表示する＞だけで済んだためです。TwoWayバインディング＜=Viewからのデータの入力を受け付ける＞が必要な場合は、<code>Subject</code>など、データをセットできる機能が必要になります。)</p>

<p>コマンドとは、Modelのメソッドを呼ぶためのものですが、それに加えて「そのコマンドが実行可能か？」を示すフラグも持ちます。さらにこのフラグも <code>Observable&lt;boolean&gt;</code> で表します。
こうする事で、「機能が利用可能な時のみボタンを Enable にする」のようなバインディングが可能になります。今回の仕様で言えば</p>

<blockquote><p>StartするとラップボタンはEnable.ストップするとDisable</p></blockquote>

<p>に該当します。</p>

<p>コマンドのインターフェースは↓のようになります。</p>

<p>```java
public interface Command {</p>

<pre><code>/** このコマンドが実行可能かを示すフラグの更新を通知するObservable */
Observable&lt;Boolean&gt; canExecuteObservable();

/** このコマンドの処理を実装する */
void execute();
</code></pre>

<p>}
```</p>

<p>今回は、このインターフェースを ViewModel で匿名クラスを作ることで実装しました。↓のような感じです。この <code>commandLap</code> をラップボタンとバインドさせます。</p>

<p>```java
/<em>* 経過時間の記録 </em>/
public final Command commandLap = new Command() {</p>

<pre><code>@Override
public Observable&lt;Boolean&gt; canExecuteObservable() {
    return _stopWatch.isRunning; // 実行中のみ記録可能
}

@Override
public void execute() {
    _stopWatch.lap();
}
</code></pre>

<p>};
```</p>

<p>あ、ViewModel は View とは疎結合に作ります。Viewを参照してはいけないのはもちろん、<code>TextView</code> や <code>Activity</code> などが import されていたら「負け」です。</p>

<p>他には、Viewの状態を保持する役割も担いますが、本アプリの仕様では、それに該当する処理はありませんでした。</p>

<h3>View</h3>

<p>　View層で行うことは、画面要素のレイアウトとViewModelとのバインディングです。それ以外の事は行いません。.NETの世界では、View層において値の変換を行う機能=ValueConverterが存在しますが、ValueConverterを使うべきかViewModelで行うべきかでよく議論になります。
　
　バインディングの実体は、ViewModelのプロパティである <code>Observable&lt;T&gt;</code> を <code>subscribe</code> して、Viewのプロパティにセットしているだけです。前述の通り今回は TwoWay は無いので楽です。TwoWay が出てくるとバインディングのフレームワークにお願いした方がよいです。
　
　例えば、 <code>Observalbe&lt;String&gt;</code> と TextViewのtextプロパティのバインディングは、下のようになります。</p>

<p>```java
public TextViewBinder toTextOneWay(Observable<String> prop) {</p>

<pre><code>_subscriptions.add(
    prop.observeOn(AndroidSchedulers.mainThread())
    .subscribe(x -&gt; _textView.setText(x)));

return this; // メソッドチェーンで連続して呼べるようにしてるだけ
</code></pre>

<p>}
```</p>

<p>.NETの世界では、このバインディングを画面定義ファイル(.xaml)に直接記述できます。
Androidでも一部のライブラリや、<a href="http://developer.android.com/intl/ja/tools/data-binding/guide.html">今後公式にデータバインディングがサポートされる模様</a>ですが、xml でのバンディングの記述は、デバッグしづらくなるので個人的にはそれほどメリットを感じないです。デザイナーとの分業と言っても別な理由で不可能なケースが多いと思います。</p>

<h2>画面遷移や Toast の表示は誰の責務？</h2>

<p>大抵の MVVMフレームワーク に備わっている <code>Messenger</code> という機能を使います。Android界隈の人には「EventBus」と言った方がわかりやすいかも知れません。</p>

<p>ViewModelが「画面遷移を要求するメッセージ」を投げ、それをViewが受信して画面遷移を行います。</p>

<p>```java メッセージ送信側(MainViewModel.java)
public final Command commandNextView = new Command() {</p>

<pre><code>@Override
public void execute() {
    // LapActivity へ遷移させる
    // ほんとは LapViewModel.class を指定すべき(LapActivity は使いたくない)
    messenger.send(new StartActivityMessage(LapActivity.class));
}
</code></pre>

<p>};
```</p>

<p>```java メッセージ受信側(MainActivity.java)
// 画面遷移のメッセージ受信
_viewModel.messenger.register(StartActivityMessage.class.getName(), new Action1<Message>() {</p>

<pre><code>@Override
public void call(final Message message) {
    runOnUiThread(new Runnable() {
        @Override
        public void run() {
            final StartActivityMessage m = (StartActivityMessage)message;
            Intent intent = new Intent(MainActivity.this, m.activityClass);
            MainActivity.this.startActivity(intent);
        }
    });
}
</code></pre>

<p>});
```</p>

<p>今回は簡単な Messenger を実装しました。VM->Vの通知にしか使わないのでVM毎に一つ持つようにしています。</p>

<h1>2.3. Reactive Extensions, ReactiveProperty を使った Android/iOS アプリ(Xamarin, C#言語)</h1>

<p><a href="https://xamarin.com/">Xamarin</a> は、 C# で Android/iOS が作れるプロダクトです。
RubyMotion のように、CocoaTouch や Android SDK の API をラップし、同じ名称のクラス,メソッドで C# から呼び出せるようにしています。</p>

<ul>
<li><a href="http://ytabuchi.hatenablog.com/">Xamarin 日本語情報</a></li>
<li><a href="http://qiita.com/amay077/items/2e86b44e5f274a34b2e9">マカーの人が Xamarin について勘違いしていそうな５つのこと &ndash; Qiita</a></li>
</ul>


<p>.NETのオープンソース実装である mono 由来の製品であり、また Microsoft とのパートナーシップも結んでいることから、.NET の資産の多くが利用可能です。</p>

<p>何が言いたいかと言うと、RxJava も MVVM パターンも、元は .NET のアプリケーション開発の分野で発案・成熟してきた考え方であり、豊富な.NET製ライブラリ(今回だと Reactive Extensions と ReactiveProperty)を使って Android/iOS アプリを開発できる、という事です。</p>

<h2>Model-ViewModel-View(MVVM) で考える</h2>

<p>Xamarin でも MVVM の役割はまったく同じですが、
<strong>「Model-ViewModel を Android/iOS で使いまわせる」</strong>
という大きなメリットがあります。</p>

<p>Model と ViewModel からは、プラットフォームに依存するコードは排除できます(すべきです)。
Xamarin(というか .NET) ではプラットフォーム非依存の処理をライブラリ化できます(これを PCL=Portable Class Library と言います)。</p>

<p>Android と iOS でそれぞれに実装が必要なのは、View と、そのバインディングのみです。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/rxjava_mvvm_stopwatch_02.png" alt="クラス図的なの" /></p>

<h2>Reactive Extensions について</h2>

<p>本家<a href="https://github.com/Reactive-Extensions/Rx.NET">Rx.NET</a>です。RxJava はこの Reactive Extensions を Java にポートしたものです。
RxJava には、いくつか便利なメソッドが追加されています(<code>compose</code> とか)が、殆ど同じです。
また、 C# はラムダ式を標準でサポートしていることから、 retrolambda などに頼らなくても見やすいコードが書けるのは言うまでもないでしょう。</p>

<h2>ReactiveProperty について</h2>

<p><a href="https://github.com/runceel/ReactiveProperty/blob/master/README-ja.md">ReactiveProperty</a> は、Rxの機能を活かしてMVVMパターンの実装を手助けしてくれるライブラリです。</p>

<ul>
<li><a href="http://blog.okazuki.jp/entry/2015/02/22/212827">MVVMとリアクティブプログラミングを支援するライブラリ「ReactiveProperty v2.0」オーバービュー &ndash; かずきのBlog@hatena</a></li>
</ul>


<p>Java版ストップウォッチでは、<code>StopWatchModel</code> や ViewModel のプロパティを全て <code>Observable&lt;T&gt;</code> としましたが、 Xamarin版では <code>ReactiveProperty&lt;T&gt;</code> としています。 <code>ReactiveProperty&lt;T&gt;</code> は <code>Observable&lt;T&gt;</code> から継承しているので、それほど大差はありませんが、<code>Subject</code> のように値の設定をサポートしていたり、バリデーション、エラー通知の仕組みが備わっています。</p>

<p>また、ReactiveProperty は、 Android の View要素とのバインディング機能も持ちます。これを使うとバインディングが以下のように書けます。</p>

<p>```csharp
// TextView(textTime) と viewModel.Time のバインド
FindViewById<TextView>(Resource.Id.textTime)</p>

<pre><code>.SetBinding(v =&gt; v.Text, 
    _viewModel.Time.Select(x =&gt; x.ToString())
    .ObserveOnUIDispatcher()
    .ToReactiveProperty());
</code></pre>

<p>```</p>

<p>iOS のバインディングはありませんが、 <del>ソースの一部を持ってくる事で、殆ど解決します</del> <a href="https://twitter.com/okazuki/status/679256704689684480">ツイートしたら取り込んでもらえました(^^)</a> 。</p>

<h1>作ったアプリのソース</h1>

<ul>
<li><a href="https://github.com/amay077/StopWatchSample">amay077/StopWatchSample</a></li>
</ul>


<p>それぞれ、</p>

<ol>
<li><a href="https://github.com/amay077/StopWatchSample/tree/master/StopWatchAppAndroid">RxJava を使った Android アプリ(Java言語)</a></li>
<li><a href="https://github.com/amay077/StopWatchSample/tree/master/StopWatchAppXamarin/StopWatchApp.Android">Reactive Extensions, ReactiveProperty を使った Android アプリ(Xamarin, C#言語)</a></li>
<li><a href="https://github.com/amay077/StopWatchSample/tree/master/StopWatchAppXamarin/StopWatchApp.iOS">Reactive Extensions, ReactiveProperty を使った iOS アプリ(Xamarin, C#言語)</a></li>
<li><a href="https://github.com/amay077/StopWatchSample/tree/master/StopWatchAppXamarin/StopWatchApp.Core">Xamarin版アプリの Model, ViewModel</a></li>
</ol>


<p>にあります。</p>

<p>Java版は、</p>

<ul>
<li><a href="https://github.com/amay077/StopWatchSample/blob/master/StopWatchAppAndroid/app/src/main/java/com/amay077/stopwatchapp/models/StopWatchModel.java">StopWatchModel.java</a></li>
<li><a href="https://github.com/amay077/StopWatchSample/blob/master/StopWatchAppAndroid/app/src/main/java/com/amay077/stopwatchapp/viewmodel/MainViewModel.java">MainViewModel.java</a></li>
<li><a href="https://github.com/amay077/StopWatchSample/blob/master/StopWatchAppAndroid/app/src/main/java/com/amay077/stopwatchapp/views/MainActivity.java">MainActivity.java</a></li>
</ul>


<p>を見るとだいたい分かると思います。</p>

<p>また、Java版 と Xamarin版では、</p>

<ul>
<li><a href="https://github.com/amay077/StopWatchSample/blob/master/StopWatchAppAndroid/app/src/main/java/com/amay077/stopwatchapp/models/StopWatchModel.java">StopWatchModel.java</a> と <a href="https://github.com/amay077/StopWatchSample/blob/master/StopWatchAppXamarin/StopWatchApp.Core/Models/StopWatchModel.cs">StopWatchModel.cs</a></li>
<li><a href="https://github.com/amay077/StopWatchSample/blob/master/StopWatchAppAndroid/app/src/main/java/com/amay077/stopwatchapp/viewmodel/MainViewModel.java">MainViewModel.java</a> と <a href="https://github.com/amay077/StopWatchSample/blob/master/StopWatchAppXamarin/StopWatchApp.Core/ViewModels/MainViewModel.cs">MainViewModel.cs</a></li>
<li><a href="https://github.com/amay077/StopWatchSample/blob/master/StopWatchAppAndroid/app/src/main/java/com/amay077/stopwatchapp/views/MainActivity.java">MainActivity.java</a> と <a href="https://github.com/amay077/StopWatchSample/blob/master/StopWatchAppXamarin/StopWatchApp.Android/Views/MainActivity.cs">MainActivity.cs</a> と <a href="https://github.com/amay077/StopWatchSample/blob/master/StopWatchAppXamarin/StopWatchApp.iOS/Views/MainViewController.cs">MainViewController.cs</a></li>
</ul>


<p>あたりを見比べるといいと思います。</p>

<h1>まとめ</h1>

<p>MVVM と RxJava はとても相性がよいと感じました。</p>

<p>Model → ViewModel → View と通知を伝搬させるのに、そのまま <code>Observable&lt;T&gt;</code> を繋げればよいのですから。加工が必要なら <code>map</code> などのオペレータを挟むだけ。
これがコールバックだったら…恐ろしくて想像したくありません。</p>

<p>Model が使用するDB層やWebAPIなども RxJava をサポートしていたら、もっと便利になると思います。(Realm は RxJava サポートが追加されたようですね！)</p>

<p>View &ndash; ViewModel のデータバインディングにも RxJava は有効ですが、こちらは、Android公式の Data Binding がどう実装されるかで未来が変わってきそうです。</p>

<p>Android-Java には、まだメジャーな MVVMフレームワークが無いので、登場が待たれるところです。</p>

<h1>おまけ：反省など</h1>

<h2>View か ViewModel か Model か問題</h2>

<p>下は View に書かれている「現在時刻と表示書式文字列のどちらかが更新されたら、時刻をフォーマットして流す」という Observable です。</p>

<p>```java
// フォーマットされた時間を表す Observable（time と timeFormat のどちらかが変更されたら更新）
final Observable<String> formattedTime = Observable.combineLatest(</p>

<pre><code>    _viewModel.time,
    _viewModel.timeFormat, (Long time, String format) -&gt; {
        final SimpleDateFormat sdf = new SimpleDateFormat(format, Locale.getDefault());
        return sdf.format(new Date(time));
    });
</code></pre>

<p>```</p>

<p>これは、ViewModel に用意すべきだったかも知れません。いやいや、フォーマットされた時間を通知する機能が Model にあってもおかしくないとも言えます。
実際、 <code>LapActivity</code> でも同じコードを書いているので D.R.Y原則にも反します。やっぱ Model に持たせるべきだったと反省。</p>

<h2>Model に戻り値が void でないメソッドを作っちゃった問題</h2>

<blockquote><p>原則として Model のメソッドの戻り値は void です</p></blockquote>

<p>の原則に反して、戻り値で最速、最遅ラップ値を返してしまいました。
Toast表示のためだけに取得できればいいやと思いこうしたのですが、これでは「最速、最遅ラップを常に画面に表示する」という仕様変更があっただけで破綻します。これは悪手でした、反省。</p>

<p>だいたいラップの最大、最小の取得は、 <code>Observable&lt;List&lt;Long&gt;&gt; laps</code>  を <code>map</code> で変換すればよいだけの話ですね。LINQ あるいは Stream API が使えれば <code>List&lt;Long&gt;</code> から min/max を取得するのも簡単ですし。</p>

<h2>Timer を 1ms 間隔にしちゃった問題</h2>

<p><code>Observable.interval(1ms)</code> ってやっちゃいましたが、START の時間を覚えておいて、LAP, STOP された時に、現在時刻との差分を取ればよかったですね。基本的なムダで反省。</p>

<p><a href="http://www.moonmile.net/blog/archives/7627">JXUG で話した MVVM の活用の解説を | Moonmile Solutions Blog</a> より</p>

<blockquote><p>Lap ボタンを押したタイミングで DateTime.Now を取得すればよいわけで、何も定期的に内部データを更新する必要はありません</p></blockquote>

<p>その通りですね。。。</p>

<h2>UIスレッドへの変換をだれがやるのか問題</h2>

<p>今回は、以下のように、自作したバインディングの中で <code>observeOn(AndroidSchedulers.mainThread())</code> 行っています。</p>

<p>```java
public TextViewBinder toTextOneWay(Observable<String> prop) {</p>

<pre><code>_subscriptions.add(
    prop.observeOn(AndroidSchedulers.mainThread())
        .subscribe(x -&gt; _textView.setText(x)));

return this;
</code></pre>

<p>}
```</p>

<p>これを ViewModel で行うこと(ViewModel が公開する Observable は必ずUIスレッドで実行されるというルール)もできます。
が、セオリーが分かっていません。とりあえず View側で observeOn しとけば安全かなと思って上記のようにしているだけです。使用するMVVMフレームワークの仕様にも依存しそうです。</p>

<h2>StopWatchModel のプロパティは Hot？ それとも Cold？</h2>

<p>StopWatchModel の各プロパティである <code>Observable&lt;T&gt;</code> は、 <strong><code>subscribe</code> をトリガーに値が流れ始めるものではないので Hot</strong> ですね。</p>

<p>また、<code>BehaviorSubject</code> を使っているので、 <code>subscribe</code> 時には、その時点の最新の値が流れてきます。</p>

<p>シングルトンの <code>StopWatchModel</code> に対して、 <code>MainActivity</code> に続いて <code>LapActivity</code> でも購読した時に、正しくラップタイム群が表示できるのは、<code>BehaviorSubject</code> であるためですね。</p>

<p><code>refCount</code> してないけど、ちゃんと破棄されているのかは未確認。。。</p>

<h2>Observalbe&lt;List&lt;T>></h2>

<p>ラップタイム群を通知するプロパティは <code>Observalbe&lt;List&lt;T&gt;&gt;</code> にしています。
この場合、List の中身を変更されても通知されないので  <code>Collections.unmodifiableList</code> で変更不可にしてから onNext で通知しています。LAPボタンが押される度に List を作りなおしている感じになります。</p>

<p>ListView とのバインディングも同じで、onNext を受信する度に、ListView を洗い替えしています。
このムダが嫌、大量データでパフォーマンスに問題が出る場合は、.NET にある <a href="https://msdn.microsoft.com/ja-jp/library/ms668604(v=vs.110"><code>ObservableCollection&lt;T&gt;</code></a>.aspx) のような仕組みを作る必要があります。(Rx.NET, RxJava では管轄外かな？)</p>

<p><code>ObservableCollection&lt;T&gt;</code> は、リストへの追加、削除、変更をアイテム毎に通知／監視できます(「 <em>項目X</em> が <em>2番目</em> に <em>追加</em> された」のような)。適切な通知とバインディングを実装すれば、ListView の差分更新が可能です（面倒ですが）。</p>

<h1>参考</h1>

<ul>
<li><a href="http://ugaya40.hateblo.jp/entry/model-mistake">MVVMのModelにまつわる誤解 &ndash; the sea of fertility</a></li>
<li><a href="http://www.moonmile.net/blog/archives/7627">JXUG で話した MVVM の活用の解説を | Moonmile Solutions Blog</a> &ndash; タイマを View/ViewModel/Model に持つそれぞれの理由が解説されています。</li>
<li><a href="http://qiita.com/hide92795/items/f7205c8171826cc2153b">RxJava &ndash; Rxで知っておくと便利なSubjectたち &ndash; Qiita</a></li>
<li><a href="http://qiita.com/amay077/items/4bb6b09a1911b074f50c">RxJava &ndash; Hot Observable と ConnectableObservable について &ndash; Qiita</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveX と MVVM と DataBinding の関係について図にしてみた]]></title>
    <link href="http://blog.amay077.net/blog/2014/10/30/reactivex-mvvm-databindings-relations/"/>
    <updated>2014-10-30T01:17:39+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/10/30/reactivex-mvvm-databindings-relations</id>
    <content type="html"><![CDATA[<ul>
<li><a href="http://connpass.com/event/8680/">ReactiveCocoa Tokyo #rac_tokyo &ndash; connpass</a></li>
<li><a href="http://connpass.com/event/9061/">RxJava Night #rxjnight &ndash; connpass</a></li>
<li><a href="http://mozaic.fm/post/100741841543/10-node-js-sideshow">#10 node.js sideshow | mozaic.fm</a></li>
</ul>


<!--more-->


<p>などなどをいろいろ眺めておりまして（東京うらやましい）、Reactive Extensions とか MVVM とかいろいろ熱い！楽しい！と思っているわけですが、いろいろなライブラリがあって、それらのカバーする範囲がいまいち明確になってない気がしたので、自分なりに整理してみました。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/reactive_mvvm_databindings_relations_01.png" alt="" /></p>

<p>MVVM っていうと、Messenger とか DIコンテナ的なものとかもあるわけですが、主に DataBinding と Rx の違いにフィーチャーしたかったので除外しました。</p>

<p>　DataBinding は、<a href="http://www.atmarkit.co.jp/ait/articles/1008/03/news097_3.html">DependencyProperty</a> や <a href="http://blog.falafel.com/learning-xamarin-custom-renderers-in-xamarin-forms/">BindableProperty</a> みたいなものがあるかどうかという感じで考えていて、「XAMLとかのマークアップでバインディング指定できなければならない」という考えではないです。</p>

<p>　View, DataBinding, ViewModel, ReactiveX の各ブロックは基本的にはどの組み合わせでもよくて（特に ReactiveX は他とは別の世界のものなので）、しかし中には ReactiveProperty のように ReactiveX に依存しつつ ViewModel の機能を提供するものがあったり、ReactiveCocoa のように「全部入り」のものがあったりします。また、View と ViewModel を繋ぐためにはなんらかの DataBinding が必要です。</p>

<p>という理解なんですが、あってますかね？</p>

<p>　私は Xamarin 推しの人なので、 <strong>Xamarin.Forms + ReactiveProperty が、MVVM+Rx のパワーをフル活用できて、しかも iOS/Android で大部分のコードが共有できるという最強の組み合わせなんですよ！</strong> というのを言いたいわけです。</p>

<h2>Links</h2>

<ul>
<li>Xamarin.Forms &ndash; <a href="http://xamarin.com/forms">Build a Native Android UI &amp; iOS UI with Xamarin.Forms &ndash; Xamarin</a></li>
<li>Prism &ndash; <a href="http://compositewpf.codeplex.com/releases/view/117297">patterns &amp; practices: Prism &ndash; Download: Prism 5.0 for .NET 4.5</a></li>
<li>MVVM Light Toolkit &ndash; <a href="https://mvvmlight.codeplex.com/">MVVM Light Toolkit &ndash; Home</a></li>
<li>Reactive Extensions &ndash; <a href="https://rx.codeplex.com/">Rx (Reactive Extensions) &ndash; Home</a></li>
<li>ReactiveProperty &ndash; <a href="https://reactiveproperty.codeplex.com/">ReactiveProperty &ndash; MVVM Extensions for Rx &ndash; Home</a></li>
<li>ReactiveUI &ndash; <a href="https://github.com/reactiveui/reactiveui">reactiveui/ReactiveUI</a></li>
<li>MvvmCross &ndash; <a href="https://github.com/MvvmCross/MvvmCross">MvvmCross/MvvmCross</a></li>
<li>RxJava &ndash; <a href="https://github.com/ReactiveX/RxJava">ReactiveX/RxJava</a></li>
<li>RxAndroid &ndash; <a href="https://github.com/ReactiveX/RxAndroid">ReactiveX/RxAndroid</a></li>
<li>android-binding &ndash; <a href="https://github.com/gueei/AndroidBinding">gueei/AndroidBinding</a></li>
<li>ReactiveCocoa &ndash; <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa/ReactiveCocoa</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MVVMフレームワーク「ReactiveUI」を Xamarin.iOS で使ってみる]]></title>
    <link href="http://blog.amay077.net/blog/2014/02/27/using-reactiveui-on-xamarin-ios/"/>
    <updated>2014-02-27T21:34:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/02/27/using-reactiveui-on-xamarin-ios</id>
    <content type="html"><![CDATA[<p>ReactiveUI は、Reactive Extensions を全面的に取り入れた クロスプラットフォームな MVVMフレームワークです。</p>

<!--more-->


<ul>
<li><a href="http://www.reactiveui.net/">ReactiveUI</a></li>
</ul>


<p>作者は GitHub の中の人 <a href="http://twitter.com/xpaulbettsx">Paul Betts</a> 氏、<a href="http://xamarin.com/mvp">Xamarin の MVP</a> でもあります。</p>

<p>元々は WPF, Silverlight, WinRT, Windows Phone に対応していましたが、Xamarin.iOS や Xamarin.Android, Xamarin.Mac にも <a href="http://blog.paulbetts.org/index.php/2013/03/12/reactiveui-4-5-is-released/">対応が進んで来た</a> ので、使ってみる事にしました。</p>

<p>Visual Studio + WPF 等なら、nuget から取得できて楽なんでしょうけども、なにせ Mac なので、Xamarin Studio のみでいきます。</p>

<h2>とりあえず使ってみる</h2>

<p>Github が公開した <a href="http://log.paulbetts.org/open-source-githubs-xamarin-starter-apps/">GitHub&rsquo;s Xamarin starter apps</a>, これに ReactiveUI も含まれているので、こちらを Clone して Xamarin Studio で開いてビルド、すぐ動きます。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/using_reactiveui_01.png" alt="" /></p>

<p>これ、ViewModel側で UUID を生成して、View側の Label にバインドしているのですが、何ともシンプル過ぎて…。</p>

<p>それでもこのフレームワークの構成を知るには十分です。</p>

<h2>ReactiveUI に必要なもの</h2>

<p>ソリューションツリーを見ると次の4つのプロジェクトがあります。</p>

<ul>
<li>Starter-Core-Android</li>
<li>Starter-Core-iOS</li>
<li>Starter-Android</li>
<li>Starter-iOS</li>
</ul>


<h3>ViewModel-Model層</h3>

<p>Starter-Core-xxx は、ディレクトリ的には同じ場所にあり、Android用とiOS用のプロジェクトファイル(.csproj)が用意してあるだけです。ここはアプリケーションの ViewModel-Model層になります。PCL化はされていないようですね(その内、とサイトに書いてありました)。</p>

<p>サンプルで用意されてる ViewModel を見てみます。</p>

<p>```csharp TestViewModel.cs
using System;
using ReactiveUI;
using System.Runtime.Serialization;</p>

<p>namespace Starter.Core.ViewModels
{</p>

<pre><code>[DataContract]
public class TestViewModel : ReactiveObject
{
    string _TheGuid;
    [DataMember] public string TheGuid {
        get { return _TheGuid; }
        set { this.RaiseAndSetIfChanged(ref _TheGuid, value); }
    }

    public TestViewModel()
    {
        TheGuid = Guid.NewGuid().ToString();
    }
}
</code></pre>

<p>}
```</p>

<p>MvvmCross とか、他の MVVM-FW とだいたい同じですね(そりゃそうだ)。
基底クラスの <code>ReactiveObject</code> が、BaseViewModel的な役割をします。(が、Reactive を冠しているだけに、随所で Rx の力が発揮される、はずです←まだ分かってない)</p>

<p>このコードでは、TestViewModel の生成と同時に、Guid を生成して、<code>TheGuid</code> プロパティに設定しています。</p>

<h3>View層</h3>

<p>Starter-Android, Starter-iOS はそれぞれの View層になります。</p>

<p>Starter-iOS の TestViewController.cs を見てみます。</p>

<p>```csharp TestViewController.cs
namespace Starter.Views
{</p>

<pre><code>public partial class TestViewController : ReactiveViewController, IViewFor&lt;TestViewModel&gt;
{
    [省略]

    public override async void ViewDidLoad()
    {
        base.ViewDidLoad();
        this.OneWayBind(ViewModel, vm =&gt; vm.TheGuid, v =&gt; v.TheGuid.Text);

        ViewModel = await BlobCache.LocalMachine.GetOrCreateObject("TestViewModel", () =&gt; {
            return new TestViewModel();
        });
    }

    TestViewModel _ViewModel;
    public TestViewModel ViewModel {
        get { return _ViewModel; }
        set { this.RaiseAndSetIfChanged(ref _ViewModel, value); }
    }

    [省略]
}
</code></pre>

<p>}
```</p>

<p><code>UIViewController</code> ではなく <code>ReactiveViewController</code> から派生させてます。この辺もよくあるやり方。<code>IViewFor</code> は、今はスルーで。</p>

<p>バインドは <code>this.OneWayBind</code> で。
ViewModel の TheGuid プロパティを、View の TheGuidラベルの Text プロパティへ単方向(OneWay)バインドしてます。</p>

<p>TestViewModel の生成は、ここでは Akavache というストレージライブラリの生成を待ってから行っていますが、Akavache を使わない場合は普通に <code>this.ViewModel = new TestViewModel()</code> で OK でしょう。</p>

<p>これで、TestViewModelの生成 → Guidの生成 → vm.TheGuidプロパティへ設定 → vm より TheGuid の変更が通知される → View側のBindingが変更を検知 → Viewのラベルを書き換える、という流れになります。</p>

<h2>ちょっと拡張してみる</h2>

<h3>双方向バインディング</h3>

<p>ViewModel→View だけでなく、View→ViewModel もやってみましょう。</p>

<p>まず TestViewModel にプロパティを追加します。
プロパティは <code>MyName</code> とします。
初期値として &ldquo;Enter your name&rdquo; とでも設定しましょうか。</p>

<p>```csharp TestViewModel.cs
namespace Starter.Core.ViewModels
{</p>

<pre><code>[DataContract]
public class TestViewModel : ReactiveObject
{
    string _TheGuid;
    [DataMember] public string TheGuid {
        get { return _TheGuid; }
        set { this.RaiseAndSetIfChanged(ref _TheGuid, value); }
    }

    string _myName;
    [DataMember] public string MyName {
        get { return _myName; }
        set { this.RaiseAndSetIfChanged(ref _myName, value); }
    }

    public TestViewModel()
    {
        TheGuid = Guid.NewGuid().ToString();

        this.MyName = "Enter your name";
    }
}
</code></pre>

<p>}
```</p>

<p>次に Interface Builder で TestViewController に、UITextField と UILabel を追加し、Outlet を &ldquo;MyText&rdquo;, &ldquo;MyLabel&rdquo; とします。これで Xamarin.iOS から <code>MyText</code>, <code>MyLabel</code> でインスタンスにアクセスできるはず、ですよね。</p>

<p><code>MyText</code>, <code>MyLabel</code> に、vm.MyName をバインドします。</p>

<p>```csharp TestViewController.cs
namespace Starter.Views
{</p>

<pre><code>public partial class TestViewController : ReactiveViewController, IViewFor&lt;TestViewModel&gt;
{
    [省略]

    public override async void ViewDidLoad()
    {
        base.ViewDidLoad();
        this.OneWayBind(ViewModel, vm =&gt; vm.TheGuid, v =&gt; v.TheGuid.Text);

        this.Bind(ViewModel, vm=&gt; vm.MyName, v =&gt; v.MyText.Text);
        this.OneWayBind(ViewModel, vm =&gt; vm.MyName, v =&gt; v.MyLabel.Text);

        ViewModel = await BlobCache.LocalMachine.GetOrCreateObject("TestViewModel", () =&gt; {
            return new TestViewModel();
        });
    }

    [省略]
}
</code></pre>

<p>}
```</p>

<p>編集できる <code>MyText</code> は <code>this.Bind</code> を使って双方向バインドします。プロパティの値を表示するだけの <code>MyLabel</code> は、 <code>this.OneWayBind</code> で。</p>

<p>これで動かしてみます。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/using_reactiveui_02.gif" alt="" /></p>

<p>UITextField への入力が、vm.MyName へ適用され、その変更を MyLabel に表示させる、という流れです。</p>

<p>今日はこの辺で。まだ全然 Reactive じゃないですが、次回以降、Command の実装やバインディングについて試してみようと思います。</p>

<p>ここまでのコードは、</p>

<ul>
<li><a href="https://github.com/amay077/starter-mobile/tree/N_plus_1">https://github.com/amay077/starter-mobile/tree/N_plus_1</a></li>
</ul>


<p>に置いておきます。徐々に進化させていこうと思います。</p>
]]></content>
  </entry>
  
</feed>
