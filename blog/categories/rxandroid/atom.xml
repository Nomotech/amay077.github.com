<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rxandroid | Experiments Never Fail]]></title>
  <link href="http://blog.amay077.net/blog/categories/rxandroid/atom.xml" rel="self"/>
  <link href="http://blog.amay077.net/"/>
  <updated>2014-11-14T19:35:44+09:00</updated>
  <id>http://blog.amay077.net/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[「チェックAがONならば、項目Bは入力必須とする」という Validation を RxJava + RxAndroid でやる]]></title>
    <link href="http://blog.amay077.net/blog/2014/11/10/complex-validation-with-rxjava-and-rxandroid/"/>
    <updated>2014-11-10T01:32:20+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/11/10/complex-validation-with-rxjava-and-rxandroid</id>
    <content type="html"><![CDATA[<p>　例えばショッピングサイトとかの発送先指定のフォーム『登録されている住所とは違う住所に送りたい時、「別の住所に送る」をチェックする、すると「住所2」が必須入力となり、入力するまで次へ進めない』的なちょっと込み入ったValidationをReactive ExtensionsのJava版、<a href="https://github.com/ReactiveX/RxJava">RxJava</a>と<a href="https://github.com/ReactiveX/RxAndroid">RxAndroid</a>でやってみました。</p>

<!--more-->


<h1>動作イメージ</h1>

<p>　まずいきなり動作結果から。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/complex_validation_with_rxjava_and_rxandroid.gif" alt="" /></p>

<ul>
<li>住所1は入力必須。</li>
<li>住所2は「住所2へ配送する」がチェックされている場合のみ、入力必須。</li>
<li>必須項目が入力されていない場合はボタンを押せない</li>
</ul>


<p>こんな仕様です。</p>

<h1>実装</h1>

<p>```java
@Override
protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
setContentView(R.layout.activity_my);

// 「注文を確定する」ボタン
final Button buttonSubmit = (Button)findViewById(R.id.buttonSubmit);

// チェックボックスのON/OFFをObservable化
final Observable&lt;Boolean&gt; useSecondaryAddress =
        ViewObservable.input((CheckBox) findViewById(R.id.checkUseSecondary), true)
        .map(new Func1&lt;OnCheckedChangeEvent, Boolean&gt;() {
            @Override
            public Boolean call(OnCheckedChangeEvent onCheckedChangeEvent) {
                return onCheckedChangeEvent.value;
            }
        });

// 住所1をObservable化
final Observable&lt;OnTextChangeEvent&gt; primaryAddress =
        ViewObservable.text((EditText) findViewById(R.id.editPrimaryAddress), true);
// 住所2をObservable化
final Observable&lt;OnTextChangeEvent&gt; secondaryAddress =
        ViewObservable.text((EditText) findViewById(R.id.editSecondaryAddress), true);

// チェックボックスと住所2の必須条件をObservable化
final Observable&lt;Boolean&gt; secondaryIsValid = 
    Observable.combineLatest(useSecondaryAddress, secondaryAddress,
        new Func2&lt;Boolean, OnTextChangeEvent, Boolean&gt;() {
            @Override
            public Boolean call(Boolean useSecondary, OnTextChangeEvent secondaryAddress) {
                if (!useSecondary) {
                    return true;
                }

                return !TextUtils.isEmpty(secondaryAddress.text);
            }
        });


// 全部まとめると、
//  住所1は入力必須、
//  住所2はチェックボックスがONの時だけ入力必須
//  必須条件を満たしていたらtrueを流す
final Observable&lt;Boolean&gt; isValidAll = Observable.combineLatest(primaryAddress, secondaryIsValid,
        new Func2&lt;OnTextChangeEvent, Boolean, Boolean&gt;() {
            @Override
            public Boolean call(OnTextChangeEvent primaryAddress, Boolean isValidSecondary) {
                if (!isValidSecondary) {
                    return false;
                }

                return !TextUtils.isEmpty(primaryAddress.text);
            }
        });


// 購読、監視
isValidAll.subscribe(new Observer&lt;Boolean&gt;() {
    @Override
    public void onNext(final Boolean isValid) {
        // 必須条件を満たしていたら「注文を確定する」を有効にする
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                buttonSubmit.setEnabled(isValid);
            }
        });
    }

    @Override
    public void onCompleted() {
    }

    @Override
    public void onError(Throwable e) {
    }
});
</code></pre>

<p>}
```</p>

<p>　<code>ViewObservable.xxx</code> で、UI要素をObservable化します。これはRxAndroidの機能。これでテキストの変更とか、チェックボックスの変更のたびに、<code>OnNext</code>が発生するようになります。</p>

<p>　Validationでは、RxJavaの機能である <code>Observable.combineLatest</code>がキモで、こいつに2つのObservableを渡してやると、その片方が値が変化した時に、<code>T3 call(T1 a, T2 b)</code> が呼ばれます。T1、T2 は渡すObservableの型、T3は後続へ流す型で、Validationなので<code>Boolean</code>です。
上記 <code>secondaryIsValid</code> の実装では、「住所2に配送する」のチェックボックスと「住所2」のテキストボックスの2つのObservableを渡していて、</p>

<ul>
<li>「住所2に配送する」がOFFなら <code>true</code> を返す</li>
<li>「住所2に配送する」がONで、且つ「住所2」が空でなければ <code>true</code> を返す</li>
</ul>


<p>としています。</p>

<p>　次に、<code>isValidAll</code> の実装では、「住所1」と <code>secondaryIsValid</code> を渡していて、</p>

<ul>
<li><code>secondaryIsValid</code> が <code>false</code> なら <code>false</code> を返す</li>
<li><code>secondaryIsValid</code> が <code>true</code> で、且つ「住所1」が空でなければ <code>true</code> を返す</li>
</ul>


<p>という実装です。</p>

<p>　んで、こいつ(<code>isValidAll</code>)を購読(<code>subscribe</code>)すると、<code>onNext</code> にValidationの結果が通知されるので、ボタンの<code>Enabled</code>を切り替えます。</p>

<p>　conbimeLatest は、本家Rxなら obsA.CombineLatest(obsB, (tA, tB) => tX).CombineLatest(obsC, (tX, tC) => tY)&hellip; とチェインして書けるのですが、RxJava の combineLatest はなぜか static メソッドしかなくてチェインできません、残念。</p>

<h1>まとめ</h1>

<p>　このレベルだと、すべてのUI要素に変更通知を仕込んで共通な関数を呼ぶ、的な実装で問題ないですが、要素や条件が増えてくると大変です。</p>

<p>　Observable と combineLatest を使うと、制約の一部を(Observableに)部分化できて、それらを組み合わせるのも自由自在(Observableだから)。</p>

<p>Javaなのでかなり長ったらしくて読みづらいコードになってしまいました。</p>

<p><strong><a href="http://xamarin.com/">Xamarin.Android</a> + <a href="https://rx.codeplex.com/">本家Reactive Extensions</a> + <a href="https://reactiveproperty.codeplex.com/">ReactiveProporty</a> なら、相当スッキリするんだけどなあー</strong></p>
]]></content>
  </entry>
  
</feed>
