<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | Experiments Never Fail]]></title>
  <link href="http://amay077.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://amay077.github.io/"/>
  <updated>2014-07-04T13:21:59+09:00</updated>
  <id>http://amay077.github.io/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[LINQ to Objects と Java8-Stream API の対応表]]></title>
    <link href="http://amay077.github.io/blog/2014/03/20/linq-to-objects-vs-java8-stream-api/"/>
    <updated>2014-03-20T15:15:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/03/20/linq-to-objects-vs-java8-stream-api</id>
    <content type="html"><![CDATA[<p>Java8 で <code>filter</code> や <code>map</code> が使えるようになったー！
というわけで .NET の LINQ to Objects との対応表を作ってみました。</p>

<!--more-->


<ul>
<li>LINQ - <a href="http://msdn.microsoft.com/ja-jp/library/system.linq.enumerable(v=vs.110">Enumerable クラス (System.Linq)</a>.aspx)</li>
<li>Java8 - <a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Stream (Java Platform SE 8 )</a></li>
</ul>


<p>の比較です。</p>

<p>Java の方は</p>

<ul>
<li><a href="http://download.java.net/jdk8/docs/api/java/util/stream/Collectors.html">Collectors (Java Platform SE 8 )</a></li>
</ul>


<p>も使います。</p>

<p>まだ試したものは少ないので間違ってるかもしれない ＆ カテゴライズが適当 なので、編集リクエストしてもらえるとありがたいです。</p>

<table>
<thead>
<tr>
<th></th>
<th> 機能 </th>
<th> LINQ </th>
<th> Java8 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> <strong>【基本的なやつ】</strong> </td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td> 抽出 </td>
<td> Where </td>
<td> filter </td>
</tr>
<tr>
<td></td>
<td> 射影 </td>
<td> Select </td>
<td> map </td>
</tr>
<tr>
<td></td>
<td> 並べ替え </td>
<td> OrderBy / OrderByDescending </td>
<td> sorted </td>
</tr>
<tr>
<td></td>
<td> 後続を並べ替え </td>
<td> ThenBy / ThenByDescending </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> 平坦化して射影 </td>
<td> SelectMany </td>
<td> flatMap </td>
</tr>
<tr>
<td></td>
<td> <strong>【抽出系】</strong> </td>
<td>  </td>
<td>  </td>
</tr>
<tr>
<td></td>
<td> ｎ件飛ばす </td>
<td> Skip </td>
<td> skip </td>
</tr>
<tr>
<td></td>
<td> 条件を満たすまで飛ばす </td>
<td> SkipWhile </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> ｎ件まで流す </td>
<td> Take </td>
<td> limit </td>
</tr>
<tr>
<td></td>
<td> 条件を満たすまで流す </td>
<td> TakeWhile </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> <strong>【合成系】</strong> </td>
<td>  </td>
<td>  </td>
</tr>
<tr>
<td></td>
<td> 連結 </td>
<td> Concat </td>
<td> concat </td>
</tr>
<tr>
<td></td>
<td> 積集合 </td>
<td> Intersect </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> 和集合 </td>
<td> Union </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> 差集合 </td>
<td> Except </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> 内部結合 </td>
<td> Join </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> 外部結合</td>
<td> GroupJoin </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> 並びを逆にする </td>
<td> Reverse </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> 2つの値を揃えて流す </td>
<td> Zip </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> <strong>【グループ化、集計系】</strong> </td>
<td>  </td>
<td>  </td>
</tr>
<tr>
<td></td>
<td> 重複を無くす </td>
<td> Distinct </td>
<td> distinct </td>
</tr>
<tr>
<td></td>
<td> 畳み込み </td>
<td> Aggregate </td>
<td> reduce </td>
</tr>
<tr>
<td></td>
<td> グループ化 </td>
<td> GroupBy </td>
<td> Collectors.groupingBy </td>
</tr>
<tr>
<td></td>
<td> 平均 </td>
<td> Average </td>
<td> IntStream.average /  Collectors.summarizingXXX </td>
</tr>
<tr>
<td></td>
<td> 件数 </td>
<td> Count / LongCount </td>
<td> count </td>
</tr>
<tr>
<td></td>
<td> 最大 </td>
<td> Max </td>
<td> max </td>
</tr>
<tr>
<td></td>
<td> 最小 </td>
<td> Min </td>
<td> min </td>
</tr>
<tr>
<td></td>
<td> 合計 </td>
<td> Sum </td>
<td> IntStream.sum / Collectors.summarizingXXX</td>
</tr>
<tr>
<td></td>
<td> 先頭 </td>
<td> First / FirstOrDefault </td>
<td> findFirst </td>
</tr>
<tr>
<td></td>
<td> 終端 </td>
<td> Last / LastOrDefault </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> とりあえず値を得る </td>
<td> </td>
<td> findAny </td>
</tr>
<tr>
<td></td>
<td> 集計用の汎用関数？ </td>
<td> </td>
<td> collect </td>
</tr>
<tr>
<td></td>
<td> 1件の値を得る </td>
<td> Single / SingleOrDefault </td>
<td> </td>
</tr>
<tr>
<td></td>
<td> 空なら既定値を返す </td>
<td> DefaultIfEmpty </td>
<td> </td>
</tr>
<tr>
<td></td>
<td> 全データが条件にマッチするか？ </td>
<td> All </td>
<td> allMatch </td>
</tr>
<tr>
<td></td>
<td> いずれかのデータが条件にマッチするか？ </td>
<td> Any </td>
<td> anyMatch </td>
</tr>
<tr>
<td></td>
<td> いずれかのデータも条件にマッチしないか？ </td>
<td> </td>
<td> noneMatch </td>
</tr>
<tr>
<td></td>
<td> <strong>【生成系】</strong> </td>
<td>  </td>
<td>  </td>
</tr>
<tr>
<td></td>
<td> 空っぽ </td>
<td> Empty </td>
<td> empty </td>
</tr>
<tr>
<td></td>
<td> 範囲を生成 </td>
<td> Range </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> 繰り返す </td>
<td> Repeat </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> 無限リスト生成 </td>
<td> </td>
<td> generate / iterate </td>
</tr>
<tr>
<td></td>
<td> <strong>【その他】</strong> </td>
<td>  </td>
<td>  </td>
</tr>
<tr>
<td></td>
<td> </td>
<td> SequenceEqual </td>
<td> </td>
</tr>
<tr>
<td></td>
<td> 列挙 </td>
<td> ToList().ForEach </td>
<td> forEach </td>
</tr>
<tr>
<td></td>
<td> なんか Action を挟む(デバッグ用？) </td>
<td> </td>
<td> peek </td>
</tr>
</tbody>
</table>


<p>ううむ、合成系の機能はほとんどないようです…ので自力でやるしか。
以下、サンプル。</p>

<h2>サンプル</h2>

<p>LINQ の方は Mac+Mono(Xamarin) で試しています（ぼそり</p>

<h3>抽出(Where)、並べ替え(OrderBy)、射影(Select)</h3>

<p>0〜9 を、偶数値だけ抽出して、降順にソートして、値を10倍して、出力。</p>

<p><code>csharp C#
Enumerable.Range(0, 10)
  .Where(x =&gt; x % 2 == 0)
  .OrderByDescending(x =&gt; x)
  .Select(x =&gt; x * 10)
  .ToList().ForEach(Console.WriteLine);
</code></p>

<p><code>java Java
Arrays.asList(0,1,2,3,4,5,6,7,8,9).stream()
  .filter(x -&gt; x % 2 == 0)
  .sorted((x, y) -&gt; y - x)
  .map(x -&gt; x * 10)
  .forEach(System.out::println);
</code></p>

<p><code>
80 60 40 20 0
</code></p>

<h3>平坦化して射影(SelectMany)</h3>

<p>1〜5のリストから、「n×10から始まるn件」のリストを生成。(結果見たほうが分かりやすいな（<sup>_<sup>;)</sup></sup></p>

<p><code>csharp C#
Enumerable.Range(1, 5)
  .SelectMany(x =&gt; Enumerable.Range(10 * x, x))
  .ToList().ForEach(Console.WriteLine);
</code></p>

<p><code>java Java
Arrays.asList(1,2,3,4,5).stream()
  .flatMap(x -&gt; IntStream.range(x * 10, x * 10 + x).boxed())
  .forEach(System.out::println);
</code></p>

<p><code>
10
20 21
30 31 32
40 41 42 43
50 51 52 53 54
</code></p>

<h3>抽出系(Take, Skip)</h3>

<p>1〜10のリストの3件飛ばして、5件取得。</p>

<p><code>csharp C#
Enumerable.Range(1, 10)
  .Skip(3)
  .Take(5)
  .ToList().ForEach(Console.WriteLine);
</code></p>

<p><code>java Java
// 無限リストでも limit あるから大丈夫
Stream.iterate(1, x-&gt; x++)
  .skip(3)
  .limit(5)
  .forEach(System.out::println);
</code></p>

<p><code>
4 5 6 7 8
</code></p>

<p>LINQ には件数でなく条件を指定できる <code>TakeWhile</code> <code>SkipWhile</code> がありますが、Java にはなさそうなので <code>filter</code> で代用しないといけなさそう。</p>

<p><code>csharp C#
Enumerable.Range(1, 10)
  .SkipWhile(x =&gt; x &lt; 4)
  .TakeWhile(x =&gt; x &lt; 9)
  .ToList().ForEach(Console.WriteLine);
</code></p>

<h3>連結(Concat)</h3>

<p>2つのリストをつなげる</p>

<p><code>csharp C#
new int[] { 1, 2, 3 }.Concat(new int[]{ 30, 20, 10 })
.ToList().ForEach(Console.WriteLine);
</code></p>

<p><code>java Java
Stream.concat(
  Arrays.asList(1,2,3).stream(),
  Arrays.asList(30,20,10).stream())
.forEach(System.out::println);
</code></p>

<p>なんで static メソッドやねん…。</p>

<p><code>
1 2 3 30 20 10
</code></p>

<h3>積集合(Intersect)、和集合(Union)、差集合(Except)</h3>

<p>積集合：2つのリストから重複をなくす。
和集合：2つのリストをマージする。
差集合：リスト1を基準にリスト2との差分を得る。</p>

<p>```csharp C#
var list1 = new int[]{1,2,3,4,5,6};
var list2 = new int[]{8,7,6,5,4};</p>

<p>list1.Intersect(list2)
  .ToList().ForEach(Console.WriteLine);</p>

<p>list1.Union(list2)
  .ToList().ForEach(Console.WriteLine);</p>

<p>list1.Except(list2)
  .ToList().ForEach(Console.WriteLine);
```</p>

<p>```java Java
// 自力で実現かよｗ
list1.stream().filter(x -> list2.stream().anyMatch(y -> y == x))
  .forEach(System.out::println);</p>

<p>Stream.concat(list1.stream(),
  list2.stream().filter(x -> list1.stream().noneMatch(y -> y == x)))
  .forEach(System.out::println);</p>

<p>list1.stream().filter(x -> list2.stream().noneMatch(y -> y == x))
  .forEach(System.out::println);
```</p>

<p><code>
4 5 6 // 積
1 2 3 4 5 6 8 7 // 和
1 2 3 // 差
</code></p>

<h3>内部結合(Join)</h3>

<p>商品マスタと売上テーブルを INNER JOIN する的な。</p>

<p>```csharp C#
var master = new [] {</p>

<pre><code>new { Id = 1, Name = "Apple" },
new { Id = 2, Name = "Grape" }
</code></pre>

<p>};</p>

<p>var sales = new [] {</p>

<pre><code>new { Id = 1, Sales = 100 },
new { Id = 2, Sales = 200 },
new { Id = 2, Sales = 300 },
new { Id = 3, Sales = 400 },
</code></pre>

<p>};</p>

<p>master.Join(sales,
  outer=>outer.Id,
  inner=>inner.Id,
  (o, i) => new { o.Name, i.Sales })
.ToList().ForEach(Console.WriteLine);
```</p>

<p>```java Java
// 自力
List&lt;Pair&lt;Integer, String>> master = Arrays.asList(
  new Pair&lt;>(1, "Apple"),
  new Pair&lt;>(2, "Grape")
);</p>

<p>List&lt;Pair&lt;Integer, Integer>> sales = Arrays.asList(
  new Pair&lt;>(1, 100),
  new Pair&lt;>(2, 200),
  new Pair&lt;>(2, 300),
  new Pair&lt;>(3, 400)
);</p>

<p>master.stream()
  .flatMap(outer -> sales.stream()</p>

<pre><code>.filter(inner -&gt; outer.getKey() == inner.getKey())
.map(z-&gt; new Pair&lt;String, Integer&gt;(outer.getValue(), z.getValue())))
</code></pre>

<p>  .forEach(System.out::println);
```</p>

<p><code>
{ Name = Apple, Sales = 100 }
{ Name = Grape, Sales = 200 }
{ Name = Grape, Sales = 300 }
</code></p>

<h3>外部結合(GroupJoin)</h3>

<p>商品マスタと売上テーブルを OUTER JOIN する的な。結合先のテーブルに行が見つからなかったものは null になる。</p>

<p>```csharp C#
var master = new [] {</p>

<pre><code>new { Id = 1, Name = "Apple" },
new { Id = 2, Name = "Grape" },
new { Id = 5, Name = "Orange" },
</code></pre>

<p>};</p>

<p>var sales = new [] {  // Orange は無い</p>

<pre><code>new { Id = 1, Sales = 100},
new { Id = 2, Sales = 200},
new { Id = 3, Sales = 400},
</code></pre>

<p>};</p>

<p>master.GroupJoin(sales,
  outer=>outer.Id,
  inner=>inner.Id,
  (o, i) => new { o.Name, FirstOfSales = i.Select(</p>

<pre><code>x=&gt;(int?)x.Sales).FirstOrDefault() }) // 無かったら null にしたいので null許容型にしてから FirstOrDefault
</code></pre>

<p>.ToList().ForEach(Console.WriteLine);
```</p>

<p>たぶん普通は First じゃなくて Sum とか使うんだろう。</p>

<p>```java Java
// これも自力
List&lt;Pair&lt;Integer, String>> master = Arrays.asList(
  new Pair&lt;>(1, "Apple"),
  new Pair&lt;>(2, "Grape"),
  new Pair&lt;>(5, "Orange")
);</p>

<p>List&lt;Pair&lt;Integer, Integer>> sales = Arrays.asList(
  new Pair&lt;>(1, 100),
  new Pair&lt;>(2, 200),
  new Pair&lt;>(2, 300),
  new Pair&lt;>(3, 400)
);</p>

<p>master.stream().map(outer->new Pair&lt;String, Optional<Integer>>(outer.getValue(),
  sales.stream()</p>

<pre><code>.filter(inner-&gt;inner.getKey() == outer.getKey()) // Id でフィルタ
  .map(x-&gt;x.getValue()) // Sales だけに射影
  .findFirst())) // 同一Id中の先頭
</code></pre>

<p>  .forEach(System.out::println);
```</p>

<p>```
[.NET]
{ Name = Apple, FirstOfSales = 100 }
{ Name = Grape, FirstOfSales = 200 }
{ Name = Orange, FirstOfSales = } // 相手が居ないやつは null になる</p>

<p>[Java]
Apple=Optional[100]
Grape=Optional[200]
Orange=Optional.empty // Option だから empty になるのは良い
```</p>

<h3>2つの値を揃えて流す(Zip)</h3>

<p>２つのリストの値をひとつずつセットにして流す。</p>

<p>```csharp C#
var arr1 = new int[] { 1, 2, 3, 4, 5 };
var arr2 = new string[] { "hoge", "fuga", "piyo" };</p>

<p>arr1.Zip(arr2, (x, y) =>  new {x, y})</p>

<pre><code>.ToList()
.ForEach(Console.WriteLine);
</code></pre>

<p>```</p>

<p><code>java Java
// FIXME どうやるの？ Streams.zip はどこいった？
</code></p>

<p><code>
{ x = 1, y = hoge }
{ x = 2, y = fuga }
{ x = 3, y = piyo }
</code></p>

<h3>重複を無くす(Distinct)</h3>

<p>重複する数値リストから重複をなくす。</p>

<p><code>csharp C#
new int[]{1,3,4,3,2,4}
  .Distinct()
  .ToList().ForEach(Console.WriteLine);
</code></p>

<p><code>java Java
Arrays.asList(1,3,4,3,2,4).stream()
  .distinct()
  .forEach(System.out::println);
</code></p>

<p><code>
1 3 4 2
</code></p>

<h3>畳み込み</h3>

<p>いろいろな集計の素、畳み込み。言語により fold とか reduce とか aggregate とか、いろいろな呼び名がありますね。
よい例が浮かなかったので Max を実装してみました。</p>

<p>```csharp C#
var max = new int[]{1,5,3,7,2,4}</p>

<pre><code>.Aggregate(Int32.MinValue, (x, y) =&gt; Math.Max(x, y));
</code></pre>

<p>Console.WriteLine(max);
```</p>

<p><code>java Java
int max = Arrays.asList(1,5,3,7,2,4).stream()
  .reduce(Integer.MIN_VALUE, (x, y) -&gt; Math.max(x, y));
System.out.println(max);
</code></p>

<p><code>
7
</code></p>

<h3>グループ化</h3>

<p>リストの要素をキーにしてグループ化する。Salesは合計を計算する。</p>

<p>```csharp C#
var sales = new [] {</p>

<pre><code>new { Id = 1, Sales = 100 },
new { Id = 2, Sales = 200 },
new { Id = 2, Sales = 300 },
new { Id = 3, Sales = 400 },
</code></pre>

<p>};</p>

<p>sales.GroupBy(x=>x.Id, (Id, groupedSales) => new {Id,</p>

<pre><code>SumOfSales = groupedSales.Sum( element =&gt; element.Sales) // Sales は合計する
</code></pre>

<p>  })
  .ToList().ForEach(Console.WriteLine);
```</p>

<p>（LINQ ではありませんが、 <code>List.LookUp</code> を使って実現することもできるようです → <a href="http://qiita.com/amay077/items/9d2941283c4a5f61f302#comment-82388821b902ad7999b0">コメント:2014/03/22 00:29</a>）</p>

<p>```java Java
// javafx に Pair があったので Tuple 代わりに使っちゃった
List&lt;Pair&lt;Integer, Integer>> list1 = Arrays.asList(
  new Pair&lt;>(1, 100),
  new Pair&lt;>(2, 200),
  new Pair&lt;>(2, 300),
  new Pair&lt;>(3, 400)
);</p>

<p>list1.stream().collect(Collectors.groupingBy(x -> x.getKey()))
  .entrySet().stream() // group化の結果が Map なので、エントリを Stream 化
  .map(x -> new Pair&lt;Integer, Integer>(</p>

<pre><code>x.getKey(), // Key が Id に相当
x.getValue().stream().collect(Collectors.summingInt(y-&gt;y.getValue())))) // Value が List なのでまた Stream 化して合計を得る
</code></pre>

<p>  .forEach(System.out::println);</p>

<p>// Collectors.groupingBy 使わずに Map.merge を使ったほうが分かりやすい気も。。。
list1.stream().collect(
  () -> new HashMap&lt;Integer, Integer>(),
  (map, item) -> map.merge(item.getKey(), item.getValue(), (x, y) -> x + y), // 同じキーの値を加算してく
  (left, right) -> left.putAll(right))
  .forEach((k, v) -> System.out.println(k + ":" + v));
```</p>

<p>Java の方、カオスすぎる…。.NET の <code>IGrouping</code> を Map でやってるからだな。</p>

<p>```
[.NET]
{ Id = 1, SumOfSales = 100 }
{ Id = 2, SumOfSales = 500 } // ID=2 の Sales が合計されている
{ Id = 3, SumOfSales = 400 }</p>

<p>[Java]
1=100
2=500
3=400
```</p>

<h3>合計(Sum)、最大(Max)、最小(Min)、平均(Average)、件数(Count)、先頭(First)、終端(Last)</h3>

<p>集計いろいろ。</p>

<p><code>csharp C#
var list1 = Enumerable.Range(0, 10);
Console.WriteLine("Sum={0}", list1.Sum());
Console.WriteLine("Max={0}", list1.Max());
Console.WriteLine("Min={0}", list1.Min());
Console.WriteLine("Count={0}", list1.Count());
Console.WriteLine("First={0}", list1.First());
Console.WriteLine("Last={0}", list1.Last());
Console.WriteLine("Average={0}", list1.Average());
</code></p>

<p>```java Java
List<Integer> list1 = Arrays.asList(0,1,2,3,4,5,6,7,8,9);
IntSummaryStatistics stats = list1.stream().collect(Collectors.summarizingInt(x -> x)); // Max,Min,Count,Average が取得できる
System.out.println("Sum=" + stats.getSum());
System.out.println("Max=" + stats.getMax());
System.out.println("Min=" + stats.getMin());
System.out.println("Count=" + stats.getCount());
System.out.println("First=" + list1.stream().findFirst().orElse(-1)); // summarizing では取れない
System.out.println("Last=" + list1.stream().sorted((x,y) -> y-x).findFirst().orElse(-1)); // 微妙
System.out.println("Average=" + stats.getAverage());</p>

<p>System.out.println("Average=" + IntStream.range(0, 10).average()); // 型指定 Stream なら average, sum がある（結果は Option に包まれる）
```</p>

<p><code>
Sum=45
Max=9
Min=0
Count=10
First=0
Last=9
Average=4.5
</code></p>

<p>…疲れた。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ふたつの Iterator を LINQ で]]></title>
    <link href="http://amay077.github.io/blog/2014/03/19/pair-iterator-implements-by-linq/"/>
    <updated>2014-03-19T00:33:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/03/19/pair-iterator-implements-by-linq</id>
    <content type="html"><![CDATA[<p>ふたつの Iterator を LINQ で</p>

<ul>
<li><a href="http://d.hatena.ne.jp/Nagise/20140315/1394884271">ふたつのIterator - プログラマーの脳みそ</a></li>
</ul>


<p>を拝見しました。</p>

<!--more-->


<p>コメントで「Zip じゃん」というのがあり、「確かに！」と思ったのでやってみました。</p>

<h2>C＃ の場合</h2>

<p>```csharp
// using using System.Linq;</p>

<p>var arr1 = new int[] { 1,2,3,4,5 };
var arr2 = new string[] { "hoge", "fuga", "piyo" };</p>

<p>arr1.Zip(arr2, (x, y) =>  new {x, y})</p>

<pre><code>.ToList()
.ForEach(Console.WriteLine);
</code></pre>

<p>```</p>

<h4>結果</h4>

<p><code>
{ x = 1, y = hoge }
{ x = 2, y = fuga }
{ x = 3, y = piyo }
</code></p>

<p>うむ、シンプル。要素数が違ってても少ない方に合わせてくれます。</p>

<h2>Java の場合</h2>

<p><a href="https://code.google.com/p/reactive4java/">reactive4java</a> というライブラリがありまして、これは Java で Reactive Extensions を実現するライブラリなのですが、LINQ的な機能が <code>Interactive</code> というクラスで提供されています。</p>

<p>これを使うと Zip ができます。</p>

<p>```java
//import hu.akarnokd.reactive4java.base.Func2;
//import hu.akarnokd.reactive4java.interactive.Interactive;</p>

<p>Iterable<Integer> array1 = Arrays.asList(1,2,3,4,5);
Iterable<String> array2 = Arrays.asList("hoge", "fuga", "piyo");</p>

<p>Iterator&lt;Pair&lt;Integer, String>> zippedIter =</p>

<pre><code>    Interactive.zip(array1, array2, 
            new Func2&lt;Integer, String, Pair&lt;Integer, String&gt;&gt;() {
@Override
public Pair&lt;Integer, String&gt; invoke(Integer x, String y) {
    return new Pair&lt;Integer, String&gt;(x, y);
}
</code></pre>

<p>}).iterator();</p>

<p>while (zippedIter.hasNext()) {</p>

<pre><code>Pair&lt;Integer, String&gt; p = zippedIter.next();
Log.d("StartupActivity", String.format("x=%d, y=%s", p.first, p.second));
</code></pre>

<p>}
```</p>

<p>ああ、Android で試したので <code>Pair</code> とか使ってしまった。
普通の Java の場合は自作の Tuple などに置き換えを。</p>

<h4>結果</h4>

<p><code>
x=1, y=hoge
x=2, y=fuga
x=3, y=piyo
</code></p>

<p>C# より冗長ですけど、いい感じで利用できるのではと思います。</p>

<p>reactive4java が Java8 のラムダ式に対応してくれると、上のコードはもっと簡潔に書けます。</p>

<p><a href="https://code.google.com/p/reactive4java/wiki/Reactive4Java8">Reactive4Java8</a> には、対応してる感じが見られますが、<a href="https://code.google.com/p/reactive4java/">Top ページ</a> によると、どうやら、「reactive4java の開発は終了し、<a href="https://github.com/Netflix/RxJava">RxJava</a> の開発に参加するつもりだ」みたいなことが書いてあります。</p>

<p>また、RxJava でなく reactive4java を使う利点として、<code>Interactive</code> 機能群の存在を挙げています。
単純に LINQ 的な機能を Java で使いたいならば、 reactive4java はまだまだ役に立つと思います。</p>

<p>最後に、もしあなたが Android 開発をしていて、Java の冗長さに嫌気がさしているなら、<a href="http://xamarin.com/csharp"><strong>Xamarin へどうぞ</strong></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C と Java と C# でクロージャ的な書き方の比較]]></title>
    <link href="http://amay077.github.io/blog/2014/01/29/closure-like-statement-comparison-with-objc-java-csharp/"/>
    <updated>2014-01-29T15:52:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/01/29/closure-like-statement-comparison-with-objc-java-csharp</id>
    <content type="html"><![CDATA[<p>クロージャとかラムダとか匿名** とか名前はいろいろですけど、各言語の書き方と動き（特に変数の扱い）について比べてみました。</p>

<p>ついでに非同期処理の例にもなってしまいました。</p>

<!--more-->


<h3>Objective-C</h3>

<p>Blocks を使います。</p>

<p>```objc Obj-C
int x = 1;
__block int y = 2;</p>

<p>dispatch_queue_t q_global = dispatch_get_global_queue(0, 0);
dispatch_async(q_global, ^{</p>

<pre><code>x = 10; // できない(コンパイルエラー
y = 20; // できる

int z = x + y;

[self dispValue:z]; // self の参照カウンタが+1される
</code></pre>

<p>});
```</p>

<p>普通に宣言した変数を Block の中で使うと、自動的に「キャプチャ」され、変数の複製される。この変数には、 Block 内では代入できずコンパイルエラーとなる。
<code>__block</code> を付けた変数は、Block 内外で同じ実体を参照でき、代入もできる。
<code>self</code> やプロパティを Block 内で使用すると参照カウンタがインクリメントされ、明示的に release しないとリークする。
あるいは、Block 外で <code>__weak</code> を付けた変数に代入しておくと、これは参照カウンタがインクリメントされない。</p>

<h3>Java 6 (Android ベースなので…)</h3>

<p>匿名クラスです。</p>

<p>```java Java
int x = 1;
final int y = 2;</p>

<p>ExecutorService executor = Executors.newSingleThreadExecutor();
executor.submit(new Runnable() {</p>

<pre><code>@Override
public void run() {
    y = 20; // できない(コンパイルエラー
    int z = x + y; // できない(コンパイルエラー

    String typeName = this.getClass().getInterfaces()[0].getName(); // Runnable になる
}
</code></pre>

<p>});
```</p>

<p>Java は匿名クラスの実装中に使える変数はかなり制限がある。
普通に宣言した変数は、匿名クラス内では使えない(コンパイルエラー)。
<code>final</code> を付けて宣言した変数は、匿名クラス内では参照のみ可能。ちょうど Objective-C の通常変数を Block 内で使った時と同じ。
Obj-C の <code>self</code> にあたる <code>this</code> は匿名クラス内では、その匿名クラスを示す。</p>

<h3>C＃</h3>

<p>ラムダ式です。</p>

<p>```csharp C#
int x = 1;
const int y = 2;
Task.Factory.StartNew(() =>
{</p>

<pre><code>x = 10; // OK
y = 20; // これはダメ、const だから。
var z = x + y;

var typeName = this.GetType().Name;
</code></pre>

<p>});
```</p>

<p>C# はかなりゆる〜い印象。
普通に宣言した変数を、ラムダ式の中でも自由に read/write できてしまう。write できちゃうのはこわい。
<code>this</code> は、ラムダ式の外側のクラスを示す。
　</p>

<h2>所感</h2>

<p>個人的には、Java のガチガチなのが好きかも。できる事が限定されているのでミスしにくい。
Objective-C は、ローカル変数は良いけど、self とか使っちゃうミス起こしそう。
C# は、普通に書き換えられて超不安、という感じ。なるべく const 使うようにしたい。
　
　
　</p>

<p>しかし記述量は C# が一番少ないですね、Xamarin いいよ Xamarin。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C の Dictionary は、キーに基本データ型が使えないのね ]]></title>
    <link href="http://amay077.github.io/blog/2014/01/28/cannot-using-int-type-in-objc-dictionary/"/>
    <updated>2014-01-28T15:49:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/01/28/cannot-using-int-type-in-objc-dictionary</id>
    <content type="html"><![CDATA[<p>Obj-C 慣れないもので、こんな所でハマってた。
くやしいので他の言語と比較しておく。
当然ながら Dictionary に限った話でない（はず）。</p>

<!--more-->


<h3>Objective-C</h3>

<p><code>obj-c Objective-C
NSMutableDictionary* dic = [[NSMutableDictionary alloc] init];
[dic setObject:@"hoge" forKey:[NSNumber numberWithInt:1]]; // これは OK
[dic setObject:@"huga" forKey:@1]; // これも OK (@1 は NSNumber のリテラル構文なので)
[dic setObject:@"piyo" forKey:2]; // これはダメ（落ちる
</code></p>

<p>キーと値が他の言語と逆なのにまずハマって、
キーに int型 の値を入れてたのに気づかずまたハマった。
せめてコンパイルエラーにして欲しいよ。
言語仕様上、型指定できないのでキーも値もどんな型でも突っ込めちゃう、こわい。</p>

<h3>Java</h3>

<p><code>java Java
Map&lt;Integer, String&gt; dic = new HashMap&lt;Integer, String&gt;();
Map&lt;int, String&gt; dic = new HashMap&lt;int, String&gt;(); // これはダメ(コンパイルできない)
dic.put(Integer.valueOf(1), "hoge"); // OK
dic.put(2, "piyo"); // これも OK（へー
</code></p>

<p>int と Integer ってのがあって、int を使って HashMap を宣言できない。
これはコンパイル時に分かるので良いけど、int と Integer の変換が必要なことがしばしば。</p>

<h3>C＃</h3>

<p><code>csharp C#
var dic = new Dictionary&lt;int, string&gt;(); // 型推論＆Generic
dic.Add(1, "hoge"); // OK
dic.Add(2, "piyo");
dic.Add(3, "huga");
</code></p>

<p>一番スッキリ書けますね。
　
　
　</p>

<p>…Xamarin いいよ、Xamarin</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[metersToEquatorPixels を Google Maps Android API v2 で]]></title>
    <link href="http://amay077.github.io/blog/2013/10/09/meterstoequatorpixels-in-gmap-v2/"/>
    <updated>2013-10-09T00:21:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/10/09/meterstoequatorpixels-in-gmap-v2</id>
    <content type="html"><![CDATA[<p>Google Map API v1 には、「地図上の距離(ｍ)を画面上の距離(ピクセル)に変換する」ためのメソッド <a href="https://developers.google.com/maps/documentation/android/v1/reference/com/google/android/maps/Projection#metersToEquatorPixels(float">Projection.metersToEquatorPixels</a>) がありましたが、v2 ではなくなってしまいました。</p>

<!--more-->


<p>ので、以下のような代替関数を作ってみました。</p>

<p>```java metersToEquatorPixels.java
public static int metersToEquatorPixels(GoogleMap map, LatLng base, float meters) {</p>

<pre><code>final double OFFSET_LON = 0.5d;

Location baseLoc = new Location("");
baseLoc.setLatitude(base.latitude);
baseLoc.setLongitude(base.longitude);

Location dest = new Location("");
dest.setLatitude(base.latitude);
dest.setLongitude(base.longitude + OFFSET_LON);

double degPerMeter = OFFSET_LON / baseLoc.distanceTo(dest); // 1m は何度？
double lonDistance = meters * degPerMeter; // m を度に変換

Projection proj = map.getProjection();
Point basePt = proj.toScreenLocation(base);
Point destPt = proj.toScreenLocation(new LatLng(base.latitude, base.longitude + lonDistance));

return Math.abs(destPt.x - basePt.x);
</code></pre>

<p>}
```</p>

<p>行っていることは単純で、基準となる緯度経度:<code>base</code> から、適当に(ここでは 0.5度)東へ移動した緯度経度を <code>Location.distanceTo</code> で求め、その結果から、「1ｍは何度か？」を求めます。あとは、この係数を使って 地図上の距離:<code>meters</code> を度に変換し、最後に、<code>base</code> と移動後の緯度経度それぞれを画面座標に変換して、画面上の距離を返す、というものです。</p>

<p>「1ｍは何度か？」は、赤道上の値を使っても良いのですが、緯度によって値が大きく変わるので、このような手法を取りました。</p>

<p>ただこれでも、求める距離の精度によっては、<code>OFFSET_LON</code> の値の調整が必要な気がします。また、経度:0 をまたぐような地域では正しく動かない気がします。(いずれも未検証)</p>

<p>また、緯度方向にもそれなりに正確な数値を出すには、上記と同じことを緯度に対しても行う必要があります。(これは v1 の API にもなかった)</p>

<p>v2 になって、描画系でピクセル座標を意識することはなくなったんであまり使うことも無いと思いますが、なにかで必要になったら思い出す程度で。</p>

<h3>追記</h3>

<p>あとで気づいたんですが、 v1 の <a href="https://developers.google.com/maps/documentation/android/v1/reference/com/google/android/maps/Projection#metersToEquatorPixels(float">Projection.metersToEquatorPixels</a>) は、赤道上の距離で算出してたんですね。それと比べるとちょっとオーバースペックでした。</p>

<p> それと、この記事を書く前に私のツイートを読まれた @honjo2 さんが、 v1 と同じ(赤道の距離を使う)仕様の関数を公開してくださいました。</p>

<blockquote class="twitter-tweet"><p>どうぞ <a href="https://t.co/quYnqvn1tw">https://t.co/quYnqvn1tw</a> RT <a href="https://twitter.com/amay077">@amay077</a>: Google Map Android v2 になって metersToEquatorPixels がなくなっちゃったのが地味に不便だ。</p>&mdash; 本城 博昭 (@honjo2) <a href="https://twitter.com/honjo2/statuses/387368608541589505">October 8, 2013</a></blockquote>


<script async src="http://amay077.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>

]]></content>
  </entry>
  
</feed>
