<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | Experiments Never Fail]]></title>
  <link href="http://blog.amay077.net/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://blog.amay077.net/"/>
  <updated>2016-02-08T01:23:54+09:00</updated>
  <id>http://blog.amay077.net/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RxJava で Observable の並列処理を直列化する]]></title>
    <link href="http://blog.amay077.net/blog/2016/02/08/serialize-operation-in-rxjava/"/>
    <updated>2016-02-08T01:16:02+09:00</updated>
    <id>http://blog.amay077.net/blog/2016/02/08/serialize-operation-in-rxjava</id>
    <content type="html"><![CDATA[<p><code>rx.Observable&lt;T&gt;</code> のオペレータは、通常は非同期で、並列に処理されます。</p>

<!--more-->


<p>例えば以下のような場合:</p>

<p>```java
public void start() {</p>

<pre><code>Observable.range(1, 5)
    .flatMap(x -&gt; fatTask(x))
    .subscribe(x -&gt; Log.d(TAG, "onNext - " + x));
</code></pre>

<p>}</p>

<p>private final Random rand = new Random();
private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(5);</p>

<p>// ランダムにスリープした後 x を onNext する
private Observable<Integer> fatTask(final int x) {</p>

<pre><code>return Observable.create(subscriber -&gt; {
    long sleep = (long) (rand.nextDouble() * 10000L);
    Log.d(TAG, "fatTask(" + x + ") - start.");

    executor.schedule(() -&gt; {
        subscriber.onNext(x);
        subscriber.onCompleted();
    }, sleep, TimeUnit.MILLISECONDS);
});
</code></pre>

<p>}
```</p>

<p>このプログラムの出力はこうなります。</p>

<blockquote><p>出力:<br/>
fatTask(1) &ndash; start.<br/>
fatTask(2) &ndash; start.<br/>
fatTask(3) &ndash; start.<br/>
fatTask(4) &ndash; start.<br/>
fatTask(5) &ndash; start.<br/>
onNext &ndash; 3<br/>
onNext &ndash; 5<br/>
onNext &ndash; 4<br/>
onNext &ndash; 2<br/>
onNext &ndash; 1<br/></p></blockquote>

<p>fatTask は 1,2,3,4,5 の順で <em>完了を待たずに</em> 呼びだされます。
が、それぞれ処理にかかる時間が異なるので、 <code>onNext</code> が呼ばれる順は 1〜 とは限りません。</p>

<p>ソースとなる Stream の順番を崩したくない場合は、 <code>fatTask(1)</code> が完了してから <code>fatTask(2)</code> を開始する、というように直列化しなければなりません。</p>

<h2>Observable.Concat(concatWith)</h2>

<p>これを行うのが <code>Observable.Concat</code> です(RxJava では <code>Observable.concatWith</code> のようですね)。
複数の <code>Observable</code> を順に（完了してから次へ）処理していきます。</p>

<h3>使い方</h3>

<p><code>toList</code> で一旦ただの <code>List</code> にしてから、<code>concatWith</code> で数珠つなぎにします。</p>

<p>```java
public void start() {</p>

<pre><code>Observable.range(1, 5)
    .toList()
    .flatMap(list -&gt; {
        // fatTask(1).contat(fatTask(2)).contat(fatTask(3))... 
        // にする（fold 使えれば…)
        Observable&lt;Integer&gt; task = null;
        for (int x : list) {
            if (task == null) {
                task = fatTask(x);
            } else {
                task = task.concatWith(fatTask(x));
            }
        }
        return task;
    })
    .subscribe(x -&gt; Log.d(TAG, "onNext - " + x));
</code></pre>

<p>}
```</p>

<p>このプログラムの出力はこうなります。</p>

<blockquote><p>出力<br/>
fatTask(1) &ndash; start.<br/>
onNext &ndash; 1<br/>
fatTask(2) &ndash; start.<br/>
onNext &ndash; 2<br/>
fatTask(3) &ndash; start.<br/>
onNext &ndash; 3<br/>
fatTask(4) &ndash; start.<br/>
onNext &ndash; 4<br/>
fatTask(5) &ndash; start.<br/>
onNext &ndash; 5<br/></p></blockquote>

<p><code>fatTask(1)</code> の完了を待ってから、次の <code>fatTask(2)</code> が実行されています。</p>

<p>※
Rx.NET では、</p>

<p><code>csharp
static IObservable&lt;T&gt; Concat&lt;T&gt;(IEnumerable&lt;IObservable&lt;T&gt;&gt; sources)
</code></p>

<p>で、複数の <code>IObservable</code> を一括で渡せるのですが、 RxJava にはないようで、、、。</p>

<p><code>java
static &lt;T&gt; Observable&lt;T&gt; concatEager(Iterable&lt;? extends Observable&lt;? extends T&gt;&gt; sources)
</code></p>

<p>というのがあったんですが、期待通りうごいてくれず、 Eager? なんでしょう？</p>

<h2>ソースが無限リストだったら？</h2>

<p><code>toList</code> で一旦ただの List にしているのが非常に気に入らないですね。
<code>range(1, 5)</code> が <code>interval(1, TimeUnit.SECONDS)</code> のように無限の Stream だったら使えません。</p>

<p>そこで、 <code>concat</code> には、こんな overload もあります。</p>

<p><code>java
static &lt;T&gt; Observable&lt;T&gt; concat(Observable&lt;? extends Observable&lt;? extends T&gt;&gt; observables)
</code></p>

<p>Observable<T> を通知する Observable？ ややこしいですがこう使います。</p>

<p>```java
public void start() {</p>

<pre><code>// 2. を concat する
Observable.concat( 
    // 1. Observable&lt;Long&gt;
    Observable.interval(1, TimeUnit.SECONDS) 
        // 2. Long を Observable&lt;Integer&gt; に変換 
        //    → Observable&lt;Observable&lt;Integer&gt;&gt; になる
        .map(x -&gt; fatTask(x.intValue()))) 
    .subscribe(x -&gt; Log.d(TAG, "onNext - " + x));
</code></pre>

<p>}
```</p>

<p>このプログラムの出力はこうなります。</p>

<blockquote><p>出力<br/>
fatTask(0) &ndash; start.<br/>
onNext &ndash; 0<br/>
fatTask(1) &ndash; start.<br/>
onNext &ndash; 1<br/>
fatTask(2) &ndash; start.<br/>
onNext &ndash; 2<br/>
…つづく<br/></p></blockquote>

<p>無限リストながら、並列処理せずに順序通り動いてくれます。</p>

<p><code>interval</code> の値を単純に <code>map</code> で <code>Observable&lt;Integer&gt;</code> に変換してやります。するとこれは <code>Observable&lt;Observable&lt;Integer&gt;&gt;</code> になり、<code>concat</code> 可能になります。 <code>flatMap</code> だと平坦化されちゃうのでただの <code>map</code> です。</p>

<h2>まとめ</h2>

<p>Observable は普通は非同期で並列処理。
非同期ながら直列化したい場合は <code>Observable.concat</code> でできます。</p>

<ol>
<li>GPS から緯度経度を取得</li>
<li>なんか重い計算を行う</li>
<li>結果をテキストファイルに書き出す</li>
</ol>


<p>みたいな処理をするとき 3. を 1. の順序と同じにしたいのでこれを使います。</p>

<p>はじめ自分は <code>flatMap</code> で繋いでいくだけですべて直列化されているのかなーと勘違いしていたので、これを知った時は目からウロコでした。</p>

<h2>参考</h2>

<ul>
<li><a href="http://www.introtorx.com/content/v1.0.10621.0/12_CombiningSequences.html">Intro to Rx &ndash; Combining sequences</a></li>
<li><a href="http://reactivex.io/documentation/operators/concat.html">ReactiveX &ndash; Concat operator</a></li>
<li><a href="http://blog.okazuki.jp/entry/20120219/1329663635">Reactive Extensions再入門 その４１「どんどん合成するよ」 &ndash; かずきのBlog@hatena</a></li>
<li><a href="https://twitter.com/neuecc/status/695604984763650050">https://twitter.com/neuecc/status/695604984763650050</a> &ndash; @neuecc さんありがとうございます！</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android-Java でリスト操作するなら IxJava が決定版だと思う]]></title>
    <link href="http://blog.amay077.net/blog/2016/01/21/ixjava-the-best-library-of-list-operations/"/>
    <updated>2016-01-21T23:59:59+09:00</updated>
    <id>http://blog.amay077.net/blog/2016/01/21/ixjava-the-best-library-of-list-operations</id>
    <content type="html"><![CDATA[<p>Android では Java8 が使えないため、 &lsquo;Yet another Stream API&rsquo; なライブラリがいくつかあります。</p>

<!--more-->


<ul>
<li><a href="http://qiita.com/tsumuchan/items/8e438a2ea653fa786c23">Androidでリスト操作するなら、Lightweight-Stream-APIが便利 &ndash; Qiita</a></li>
<li><a href="http://qiita.com/k--kato/items/ec7ab8b392fa8bb0a732">JavaにC#のLINQを移植してみた &ndash; jLinqer &ndash; Qiita</a></li>
<li><a href="http://stackoverflow.com/questions/1217228/what-is-the-java-equivalent-for-linq">What is the Java equivalent for LINQ? &ndash; Stack Overflow</a></li>
</ul>


<p>普段 C# を使っているため LINQ to Objects の便利さをなんとか Androidアプリ開発でも享受したい。
そこで個人的に「これだ！」と思っているライブラリが IxJava です。</p>

<ul>
<li><a href="https://github.com/akarnokd/ixjava">akarnokd/ixjava: Interactive Extensions for Java</a></li>
</ul>


<h2>IxJava とは？</h2>

<p>一言でいえば <em>「LINQ to Objects の Java版」</em> です。</p>

<p>README より、</p>

<blockquote><p>Interactive Extensions for Java, the dual of RxJava. Originally implemented in the Reactive4Java framework, now converted to work with RxJava.</p>

<p>The aim is to provide pull-based datastream support with the same naming as in RxJava mainly for the pre-Java-8 world.</p></blockquote>

<p>開発者の akarnokd 氏は、 RxJava の登場以前から <a href="https://code.google.com/p/reactive4java/">Reactive4Java</a> という「Java版Rx」を開発しており、これには大きく２つの機能が含まれていました。</p>

<ul>
<li><code>Reactive&lt;T&gt;</code> : Reactive Extension の Java実装</li>
<li><code>Interactive&lt;T&gt;</code> : LINQ to Objects の Java実装</li>
</ul>


<p>そう、 akarnokd 氏は、Rx と共に LINQ も Java に移植していたのです。
その後、彼は RxJava への参加を表明し、 reactive4java は開発終了となりましたが、RxJava には LINQ 相当の機能は含まれません。
そこで彼は、 <code>Interactive&lt;T&gt;</code> だけを <em>IxJava</em> として切り離し、純粋な <em>「LINQ to Object for Java」</em> として開発続行したのです。</p>

<p>akarnokd 氏は RxJava の <a href="https://github.com/ReactiveX/RxJava/graphs/contributors">Contributors</a> を見ると中心的な開発者であると思われます。そんな彼が開発した ixjava も安心できる品質ではないかと思います。（ちょっと ixjava の知名度が低いのが残念ですが。ただ reactive4java の <code>Interactive&lt;T&gt;</code> を使ってきましたが問題はありません。）</p>

<h2>使い方（Android の場合）</h2>

<h3>導入方法</h3>

<p>Module の <code>build.gradle</code> に以下を追加するだけです。</p>

<p>```java
dependencies {</p>

<pre><code>compile "com.github.akarnokd:ixjava:0.90.0"
</code></pre>

<p>}
```</p>

<h3>使用例</h3>

<ul>
<li><a href="http://qiita.com/amay077/items/9d2941283c4a5f61f302">LINQ to Objects と Java8-Stream API の対応表 &ndash; Qiita</a></li>
</ul>


<p>のサンプルコードの一部を IxJava で書いてみました。</p>

<h4>抽出(filter)、並べ替え(orderBy)、射影(map)</h4>

<p><code>java ixjava
Ix.from(Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9))
  .filter(x -&gt; x % 2 == 0) // 可視性向上の為のなんちゃってラムダ
  .orderBy(x-&gt; -x)  // OrderByDescending がないので
  .map(x -&gt; x * 10)
  .toList();
</code></p>

<p><code>
//出力
80 60 40 20 0
</code></p>

<h4>平坦化して射影(flatMap)</h4>

<p><code>java ixjava
Ix.from(Arrays.asList(1, 2, 3, 4, 5))
  .flatMap(x −&gt; Ix.range(x * 10, x))
  .toList();
</code></p>

<p><code>
//出力
10
20 21
30 31 32
40 41 42 43
50 51 52 53 54
</code></p>

<h4>2つの値を揃えて流す(zip)</h4>

<p>Stream API には無いが IxJava にはあるのだよ。</p>

<p>```java ixjava
Ix.from(Arrays.asList(1, 2, 3, 4, 5))
  .zip(Ix.from(Arrays.asList(&ldquo;hoge&rdquo;, &ldquo;fuga&rdquo;, &ldquo;piyo&rdquo;)),</p>

<pre><code>(x, y) -&gt; new Pair&lt;Integer, String&gt;(x, y))
</code></pre>

<p>  .toList();
```</p>

<p><code>
//出力
{ first = 1, second = hoge }
{ first = 2, second = fuga }
{ first = 3, second = piyo }
</code></p>

<h4>Ix<T> のメソッド一覧</h4>

<p>あとはテキトーに抜き出したメソッド一覧を置いておきますね。
RxJava や LINQ とほとんど同じなのでだいたい想像付くと思います。
（何気に <code>toObservable</code> で <code>Observable&lt;T&gt;</code> にも変換できますね。）
あ、あとタイトルには Androidの〜 と書きましたが、普通の Java でもフツーに使えますので。</p>

<ul>
<li>aggregate</li>
<li>all</li>
<li>any</li>
<li>argAndMax</li>
<li>argAndMin</li>
<li>averageBigDecimal</li>
<li>averageBigInteger</li>
<li>averageDouble</li>
<li>averageFloat</li>
<li>averageInt</li>
<li>averageLong</li>
<li>buffer</li>
<li>call</li>
<li>concat</li>
<li>concatWith</li>
<li>concatWithAll</li>
<li>contains</li>
<li>count</li>
<li>countLong</li>
<li>defer</li>
<li>dematerialize</li>
<li>distinct</li>
<li>distinctNext</li>
<li>doOnCompleted</li>
<li>doOnNext</li>
<li>doWhile</li>
<li>empty</li>
<li>endWith</li>
<li>error</li>
<li>filter</li>
<li>filterIndexed</li>
<li>first</li>
<li>flatMap</li>
<li>forEach</li>
<li>from</li>
<li>fromPart</li>
<li>generate</li>
<li>groupBy</li>
<li>into</li>
<li>isEmpty</li>
<li>iterator</li>
<li>join</li>
<li>just</li>
<li>last</li>
<li>map</li>
<li>mapIndexed</li>
<li>materialize</li>
<li>max</li>
<li>maxBy</li>
<li>mayBy</li>
<li>memoize</li>
<li>memoizeAll</li>
<li>min</li>
<li>minBy</li>
<li>minxBy</li>
<li>newBuilder</li>
<li>ofType</li>
<li>orderBy</li>
<li>print</li>
<li>println</li>
<li>prune</li>
<li>publish</li>
<li>range</li>
<li>removeAll</li>
<li>repeat</li>
<li>replay</li>
<li>run</li>
<li>scan</li>
<li>share</li>
<li>skipLast</li>
<li>startWith</li>
<li>subsequent</li>
<li>sumBigDecimal</li>
<li>sumBigInteger</li>
<li>sumDouble</li>
<li>sumFloat</li>
<li>sumInt</li>
<li>sumIntAsDouble</li>
<li>sumLong</li>
<li>sumLongAsDouble</li>
<li>take</li>
<li>takeLast</li>
<li>toArray</li>
<li>toBuilder</li>
<li>toHashMap</li>
<li>toHashMultimap</li>
<li>toList</li>
<li>toMap</li>
<li>toMultimap</li>
<li>toObservable</li>
<li>zip</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hot Observable と ConnectableObservable について]]></title>
    <link href="http://blog.amay077.net/blog/2015/12/17/about-hot-observable-and-connectableobservable/"/>
    <updated>2015-12-17T23:59:59+09:00</updated>
    <id>http://blog.amay077.net/blog/2015/12/17/about-hot-observable-and-connectableobservable</id>
    <content type="html"><![CDATA[<p>　これは <a href="http://qiita.com/advent-calendar/2015/rxjava">RxJava Advent Calendar 2015 17日目</a> の記事です。</p>

<p>空いてたので参加してみました。
普段は Xamarin(C#) + Reactive Extensions + ReactiveProperty で、Reactive + MVVM な Android/iOS両対応アプリを開発しています。</p>

<!--more-->


<h2>Cold vs Hot</h2>

<p>Cold Observable は「あなただけの」Stream、Hot は「みんなの」Stream 。
（私的にはニコ動かニコ生か、みたいに理解してますが、その話はいいや）</p>

<p>Cold は、あなたが subscribe した瞬間からデータが流れ始めます。
Hot は、あなたが subscribe してもデータは流れ始めません(流れるかも知れません？)。</p>

<p>では Hot Observable はいつからデータが流れ始める？Observable が生成された瞬間から？
その答え(の一つ)が <strong>ConnectableObservable</strong> 。</p>

<h2>ConnectableObservable のデータ放流の開始と停止</h2>

<p>Cold Observable を Hot化する publish メソッドの返り値は ConnectableObservable。
Hot は必ず ConnectableObservable。（←これ後で否定します）</p>

<p>ConnectableObservable には connect メソッドがあります。
Hot Observable のデータが流れ始めるのは、このメソッドを呼んだ瞬間から。
なので、どれだけ subscriber が居ようとも connect を呼ばなければデータは流れません。逆に subscriber が居なくても connect を呼べばデータが流れ始めます。</p>

<p>connect メソッドの返り値は Subscription です。
Subscription の unsubscribe メソッドを呼ぶと、データの放流が停止します。これも subscriber が居ようが居まいが停止します。
再度 connect すると、 <strong>最初から</strong> データが流れ出します。再開ではありません。</p>

<h2>実例</h2>

<h3>Cold Observable</h3>

<p>Observable.interval は、一定時間置きにインクリメントされた値を流す <strong>Cold</strong> Observable。
なので、複数の subscriber が居たら、各々に独立した値を流します。</p>

<p>Android の画面にボタンが２つ（buttonSubscribe1 と buttonSubscribe2）並んでるだけのサンプルです。</p>

<p>```java
final Observable<Long> tickObservable = Observable.interval(1000, TimeUnit.MILLISECONDS);</p>

<p>// 可視性向上の為のなんちゃってラムダ
findViewById(R.id.buttonSubscribe1).setOnClickListener(v &ndash;> {</p>

<pre><code>Log.d(TAG, "buttonSubscribe1 click!");
tickObservable.subscribe(x -&gt; Log.d(TAG, "subscriber1 - onNext - " + x));
</code></pre>

<p>});</p>

<p>findViewById(R.id.buttonSubscribe2).setOnClickListener(v &ndash;> {</p>

<pre><code>Log.d(TAG, "buttonSubscribe2 click!");
tickObservable.subscribe(x -&gt; Log.d(TAG, "subscriber2 - onNext - " + x));
</code></pre>

<p>});
```</p>

<blockquote><p>結果:<br/>
D/MainActivity: buttonSubscribe1 click!<br/>
D/MainActivity: subscriber1 &ndash; onNext &ndash; 0<br/>
D/MainActivity: subscriber1 &ndash; onNext &ndash; 1<br/>
D/MainActivity: subscriber1 &ndash; onNext &ndash; 2<br/>
D/MainActivity: subscriber1 &ndash; onNext &ndash; 3<br/>
D/MainActivity: subscriber1 &ndash; onNext &ndash; 4<br/>
D/MainActivity: subscriber1 &ndash; onNext &ndash; 5<br/>
D/MainActivity: buttonSubscribe2 click!<br/>
D/MainActivity: subscriber1 &ndash; onNext &ndash; 6<br/>
D/MainActivity: subscriber2 &ndash; onNext &ndash; 0<br/>
D/MainActivity: subscriber1 &ndash; onNext &ndash; 7<br/>
D/MainActivity: subscriber2 &ndash; onNext &ndash; 1<br/>
D/MainActivity: subscriber1 &ndash; onNext &ndash; 8<br/>
D/MainActivity: subscriber2 &ndash; onNext &ndash; 2<br/></p></blockquote>

<p>buttonSubscribe1 を押すとデータ(０から連番)が流れ始めます。
しばらくして buttonSubscribe2 を押すと、1 とは関係なく、また 0 から流れ始めます。</p>

<h3>Hot(Connectable) Observable</h3>

<p>publish で Hot 化します。
connect と unsubscribe を呼ぶためのボタン（buttonConnect, buttonDisConnect）を画面に追加してます。</p>

<p>```java
private Subscription _connection; // field です</p>

<p>final ConnectableObservable<Long> tickObservable =</p>

<pre><code>Observable.interval(1000, TimeUnit.MILLISECONDS).publish(); // publish で Hot化
</code></pre>

<p>findViewById(R.id.buttonSubscribe1).setOnClickListener(v &ndash;> {</p>

<pre><code>Log.d(TAG, "buttonSubscribe1 click!");
tickObservable.subscribe(x -&gt; Log.d(TAG, "subscriber1 - onNext - " + x));
</code></pre>

<p>});</p>

<p>findViewById(R.id.buttonSubscribe2).setOnClickListener(v &ndash;> {</p>

<pre><code>Log.d(TAG, "buttonSubscribe2 click!");
tickObservable.subscribe(x -&gt; Log.d(TAG, "subscriber2 - onNext - " + x));
</code></pre>

<p>});</p>

<p>findViewById(R.id.buttonConnect).setOnClickListener(v &ndash;> {</p>

<pre><code>Log.d(TAG, "buttonConnect click!");
_connection = tickObservable.connect(); // データ放流開始
</code></pre>

<p>});</p>

<p>findViewById(R.id.buttonDisConnect).setOnClickListener(v &ndash;> {</p>

<pre><code>Log.d(TAG, "buttonDisConnect click!");
if (_connection != null) {
    _connection.unsubscribe(); // データ放流停止
    _connection = null;
}
</code></pre>

<p>});
```</p>

<blockquote><p>結果:<br/>
D/MainActivity: buttonSubscribe1 click!<br/>
D/MainActivity: buttonConnect click!      // ←数秒経過している<br/>
D/MainActivity: subscriber1 &ndash; onNext &ndash; 0<br/>
D/MainActivity: subscriber1 &ndash; onNext &ndash; 1<br/>
D/MainActivity: subscriber1 &ndash; onNext &ndash; 2<br/>
D/MainActivity: subscriber1 &ndash; onNext &ndash; 3<br/>
D/MainActivity: buttonSubscribe2 click!<br/>
D/MainActivity: subscriber1 &ndash; onNext &ndash; 4<br/>
D/MainActivity: subscriber2 &ndash; onNext &ndash; 4<br/>
D/MainActivity: subscriber1 &ndash; onNext &ndash; 5<br/>
D/MainActivity: subscriber2 &ndash; onNext &ndash; 5<br/>
D/MainActivity: subscriber1 &ndash; onNext &ndash; 6<br/>
D/MainActivity: subscriber2 &ndash; onNext &ndash; 6<br/>
D/MainActivity: buttonDisConnect click!<br/>
-これ以降 onNext は出力されない-<br/></p></blockquote>

<p>buttonSubscribe1 を押しても、まだデータは流れてきません。
数秒後、buttonConnect を押すとデータが流れ始めます。
buttonSubscribe2 を押すと、subscriber2 が増えますが、Hot(みんなの)Observable なので、流れてくる値とタイミングは subscriber1 と全く同じです。</p>

<p>buttonDisConnect を押すと、データの放流が停止されます。(ちなみにもう一度 CONNECT すると、また 0 から値が流れます)
subscriber1, subscriber2 にはもう onNext は呼ばれません。</p>

<p>※サンプルでは onNext しか受信していませんが、 buttonDisConnect を押しても、 subscriber1, subscriber2 の onComplete や onError も呼ばれません。つまり、 <strong>「データの放流が停止されても、 subscriber はそれに気付けない」</strong> ということになります。これはこれでいいんだろか、という感じです。</p>

<h2>ConnectableObservable.refCount について</h2>

<blockquote><p>Hot は必ず ConnectableObservable。（←これ後で否定します）</p></blockquote>

<p>否定始めます。</p>

<p>ConnectableObservable では、データ放流の開始と停止は、 connect と unsubscribe に委ねられていました。</p>

<p>refCount() を使うとそれを自動化できます。(refCount？参照カウントを返すメソッド？そう思っていましたが全然違いました。)
どういうことかと言うと、最初の subscriber が現れたらデータ放流を開始し、誰も subscriber が居なくなったら放流を停止する、というものです。
refCount() の返値はただの Observable です、でも Hot です。はい否定しましたー。</p>

<h3>実例</h3>

<p>publish した Hot Observable を refCount してデータ放流を自動制御してもらいます。
画面には、 buttonConnect, buttonDisConnect に代わり、buttonUnsubscribe1, buttonUnsubscribe2 を用意します。</p>

<p>```java
private Subscription <em>subscription1; // field です
private Subscription </em>subscription2; // field です
private Subscription _connection;    // field です</p>

<p>final Observable<Long> tickObservable =</p>

<pre><code>Observable.interval(1000, TimeUnit.MILLISECONDS).publish().refCount(); // 返値は Connectable ではない
</code></pre>

<p>findViewById(R.id.buttonSubscribe1).setOnClickListener(v &ndash;> {</p>

<pre><code>Log.d(TAG, "buttonSubscribe1 click!");
_subscription1 = tickObservable.subscribe(x -&gt; Log.d(TAG, "subscriber1 - onNext - " + x));
</code></pre>

<p>});</p>

<p>findViewById(R.id.buttonSubscribe2).setOnClickListener(v &ndash;> {</p>

<pre><code>Log.d(TAG, "buttonSubscribe2 click!");
_subscription2 = tickObservable.subscribe(x -&gt; Log.d(TAG, "subscriber2 - onNext - " + x));
</code></pre>

<p>});</p>

<p>findViewById(R.id.buttonUnsubscribe1).setOnClickListener(v &ndash;> {</p>

<pre><code>Log.d(TAG, "buttonUnsubscribe1 click!");
if (_subscription1 != null) {
    _subscription1.unsubscribe(); // 1購読終了
    _subscription1 = null;
}
</code></pre>

<p>});</p>

<p>findViewById(R.id.buttonUnsubscribe2).setOnClickListener(v &ndash;> {</p>

<pre><code>Log.d(TAG, "buttonUnsubscribe2 click!");
if (_subscription2 != null) {
    _subscription2.unsubscribe(); // 2購読終了
    _subscription2 = null;
}
</code></pre>

<p>});
```</p>

<blockquote><p>結果:<br/>
D/MainActivity: buttonSubscribe1 click!<br/>
D/MainActivity: subscriber1 &ndash; onNext &ndash; 0<br/>
D/MainActivity: subscriber1 &ndash; onNext &ndash; 1<br/>
D/MainActivity: subscriber1 &ndash; onNext &ndash; 2<br/>
D/MainActivity: buttonSubscribe2 click!<br/>
D/MainActivity: subscriber1 &ndash; onNext &ndash; 3<br/>
D/MainActivity: subscriber2 &ndash; onNext &ndash; 3<br/>
D/MainActivity: subscriber1 &ndash; onNext &ndash; 4<br/>
D/MainActivity: subscriber2 &ndash; onNext &ndash; 4<br/>
D/MainActivity: subscriber1 &ndash; onNext &ndash; 5<br/>
D/MainActivity: subscriber2 &ndash; onNext &ndash; 5<br/>
D/MainActivity: subscriber1 &ndash; onNext &ndash; 6<br/>
D/MainActivity: subscriber2 &ndash; onNext &ndash; 6<br/>
D/MainActivity: subscriber1 &ndash; onNext &ndash; 7<br/>
D/MainActivity: subscriber2 &ndash; onNext &ndash; 7<br/>
D/MainActivity: buttonUnsubscribe1 click!<br/>
D/MainActivity: subscriber2 &ndash; onNext &ndash; 8<br/>
D/MainActivity: subscriber2 &ndash; onNext &ndash; 9<br/>
D/MainActivity: subscriber2 &ndash; onNext &ndash; 10<br/>
D/MainActivity: subscriber2 &ndash; onNext &ndash; 11<br/>
D/MainActivity: buttonUnsubscribe2 click!<br/>
-これ以降 onNext は出力されない-<br/></p></blockquote>

<p>buttonSubscribe1 を押すと、その時点でデータが流れ始めます(refCount による自動制御)。
buttonSubscribe2 を押すと、subscriber1 と同じタイミングで、同じ値を受信できます(Hot だから)。
buttonUnsubscribe1 を押すと、 subscriber1 は購読をやめますが、subscriber2 はまだ受信しています。
buttonUnsubscribe2 を押すと、subscriber2 も購読をやめ、この時点でデータ放流が停止します(refCount による自動制御)。</p>

<p>※ほんとにデータ放流終わってんの？を確認するには、 tickObservable に doOnNext を繋げて確認するとよいと思います。</p>

<h2>まとめ</h2>

<p>Hot Observable は、ほとんどの場合(publish により生成されるので) ConnectableObservable。
ConnectableObservable は、購読者の有無に関係なく connect でデータ放流開始、Subscription.unsubscribe でデータ放流停止。
refCount により購読者の有無に連動したデータ放流の自動制御が可能。この場合 Hot だけど普通の Observable型。</p>

<p>実際に Hot Observable を使う場合は、refCount() しとくのが無難かなー、と思いました。(購読者の unsubscribe を厳密に管理しておけば、という前提で)</p>

<h2>参考</h2>

<ul>
<li><a href="http://www.introtorx.com/content/v1.0.10621.0/14_HotAndColdObservables.html">Intro to Rx &ndash; Hot and Cold observables</a></li>
<li><a href="https://github.com/ReactiveX/RxJava/wiki/Connectable-Observable-Operators">Connectable Observable Operators · ReactiveX/RxJava Wiki</a></li>
<li><a href="http://qiita.com/advent-calendar/2015/rxjava">RxJava Advent Calendar 2015 を書かれた皆さん</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[システムの起動時にアプリを起動する]]></title>
    <link href="http://blog.amay077.net/blog/2014/09/01/run-application-on-system-startup/"/>
    <updated>2014-09-01T21:41:43+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/09/01/run-application-on-system-startup</id>
    <content type="html"><![CDATA[<p>ググれば出てくるんだけど、情報が古いので書きなおしてみた。</p>

<!--more-->


<h2>全体</h2>

<p>Android OS の起動が終わると <code>android.intent.action.BOOT_COMPLETED</code> がブロードキャストされるので、それを捕まえて任意の処理をする。</p>

<h2>起動時に呼び出されるコード</h2>

<p>ブロードキャストを捕まえたときに呼ばれるコード。<code>MyActivity</code> を開始している。BroadcastReceiver から Activity を開始するには <code>Intent.FLAG_ACTIVITY_NEW_TASK</code> が必要なので注意。</p>

<p>```java StartupReceiver.java
public class StartupReceiver extends BroadcastReceiver {</p>

<pre><code>private static final String TAG = "StartupReceiver";

@Override
public void onReceive(Context context, Intent intent) {
    Log.d(TAG, "onReceive:" + MyApplication.data);
    Intent intentActivity = new Intent(context, MyActivity.class);
    intentActivity.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    context.startActivity(intentActivity);
}
</code></pre>

<p>}
```</p>

<h2>AndroidManifest.xml で受信登録</h2>

<p><code>StartupReceiver</code> を登録する。
忘れちゃいけないのが <code>android.permission.RECEIVE_BOOT_COMPLETED</code> による権限の設定。これがないと受信できない。</p>

<p>```xml AndroidManifest.xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
&lt;manifest xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code>package="com.amay077.reboottest" &gt;

&lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" /&gt;

&lt;application
    android:allowBackup="true"
    android:icon="@drawable/ic_launcher"
    android:label="@string/app_name"
    android:theme="@style/AppTheme" &gt;
    &lt;activity
        android:name=".MyActivity"
        android:label="@string/app_name" &gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.MAIN" /&gt;
            &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
        &lt;/intent-filter&gt;

    &lt;/activity&gt;
    &lt;receiver android:name=".StartupReceiver" &gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.BOOT_COMPLETED" /&gt;
            &lt;category android:name="android.intent.category.DEFAULT" /&gt;
        &lt;/intent-filter&gt;
    &lt;/receiver&gt;
&lt;/application&gt;
</code></pre>

<p></manifest>
```</p>

<h2>端末を再起動して試す</h2>

<ul>
<li><a href="http://9ensan.com/blog/smartphone/android/android-boot_completed-adb-shell-am-broadcast/">AndroidのBOOT_COMPLETEDの受信とテスト | 9ensanのLifeHack</a></li>
</ul>


<p>で知った <code>adb shell am broadcast -a android.intent.action.BOOT_COMPLETED</code> は GenyMotion でも使えました。
<code>RECEIVE_BOOT_COMPLETED</code> の位置によっては、テストが成功したりしなかったりだと書かれておられますが、上記の <code>AndroidManifest.xml</code> では、テストも実際の再起動も成功しました。</p>

<h2>参考</h2>

<ul>
<li><a href="http://techbooster.jpn.org/andriod/application/1100/">システムの起動時にサービスを実行する « Tech Booster</a>(2010年なのでだいぶ古い、要注意)</li>
<li><a href="http://9ensan.com/blog/smartphone/android/android-boot_completed-adb-shell-am-broadcast/">AndroidのBOOT_COMPLETEDの受信とテスト | 9ensanのLifeHack</a>(2012年、まだまだ古い)</li>
<li><a href="http://stackoverflow.com/questions/20441308/boot-completed-not-working-android/20441442#20441442">broadcastreceiver &ndash; BOOT_COMPLETED not working Android &ndash; Stack Overflow</a>(2013年、これなら何とか)</li>
<li><a href="https://groups.google.com/forum/#!topic/android-group-japan/D1EKohMIji0">BOOT_COMPLETEDが受信出来ない &ndash; Google グループ</a> SDカードにインストールされるとこのブロードキャストを受信できないそうです</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LINQ to Objects と Java8-Stream API の対応表]]></title>
    <link href="http://blog.amay077.net/blog/2014/03/20/linq-to-objects-vs-java8-stream-api/"/>
    <updated>2014-03-20T15:15:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/03/20/linq-to-objects-vs-java8-stream-api</id>
    <content type="html"><![CDATA[<p>Java8 で <code>filter</code> や <code>map</code> が使えるようになったー！
というわけで .NET の LINQ to Objects との対応表を作ってみました。</p>

<!--more-->


<ul>
<li>LINQ &ndash; <a href="http://msdn.microsoft.com/ja-jp/library/system.linq.enumerable(v=vs.110">Enumerable クラス (System.Linq)</a>.aspx)</li>
<li>Java8 &ndash; <a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Stream (Java Platform SE 8 )</a></li>
</ul>


<p>の比較です。</p>

<p>Java の方は</p>

<ul>
<li><a href="http://download.java.net/jdk8/docs/api/java/util/stream/Collectors.html">Collectors (Java Platform SE 8 )</a></li>
</ul>


<p>も使います。</p>

<p>まだ試したものは少ないので間違ってるかもしれない ＆ カテゴライズが適当 なので、編集リクエストしてもらえるとありがたいです。</p>

<table>
<thead>
<tr>
<th></th>
<th> 機能 </th>
<th> LINQ </th>
<th> Java8 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> <strong>【基本的なやつ】</strong> </td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td> 抽出 </td>
<td> Where </td>
<td> filter </td>
</tr>
<tr>
<td></td>
<td> 射影 </td>
<td> Select </td>
<td> map </td>
</tr>
<tr>
<td></td>
<td> 並べ替え </td>
<td> OrderBy / OrderByDescending </td>
<td> sorted </td>
</tr>
<tr>
<td></td>
<td> 後続を並べ替え </td>
<td> ThenBy / ThenByDescending </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> 平坦化して射影 </td>
<td> SelectMany </td>
<td> flatMap </td>
</tr>
<tr>
<td></td>
<td> <strong>【抽出系】</strong> </td>
<td>  </td>
<td>  </td>
</tr>
<tr>
<td></td>
<td> ｎ件飛ばす </td>
<td> Skip </td>
<td> skip </td>
</tr>
<tr>
<td></td>
<td> 条件を満たすまで飛ばす </td>
<td> SkipWhile </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> ｎ件まで流す </td>
<td> Take </td>
<td> limit </td>
</tr>
<tr>
<td></td>
<td> 条件を満たすまで流す </td>
<td> TakeWhile </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> <strong>【合成系】</strong> </td>
<td>  </td>
<td>  </td>
</tr>
<tr>
<td></td>
<td> 連結 </td>
<td> Concat </td>
<td> concat </td>
</tr>
<tr>
<td></td>
<td> 積集合 </td>
<td> Intersect </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> 和集合 </td>
<td> Union </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> 差集合 </td>
<td> Except </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> 内部結合 </td>
<td> Join </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> 外部結合</td>
<td> GroupJoin </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> 並びを逆にする </td>
<td> Reverse </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> 2つの値を揃えて流す </td>
<td> Zip </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> <strong>【グループ化、集計系】</strong> </td>
<td>  </td>
<td>  </td>
</tr>
<tr>
<td></td>
<td> 重複を無くす </td>
<td> Distinct </td>
<td> distinct </td>
</tr>
<tr>
<td></td>
<td> 畳み込み </td>
<td> Aggregate </td>
<td> reduce </td>
</tr>
<tr>
<td></td>
<td> グループ化 </td>
<td> GroupBy </td>
<td> Collectors.groupingBy </td>
</tr>
<tr>
<td></td>
<td> 平均 </td>
<td> Average </td>
<td> IntStream.average /  Collectors.summarizingXXX </td>
</tr>
<tr>
<td></td>
<td> 件数 </td>
<td> Count / LongCount </td>
<td> count </td>
</tr>
<tr>
<td></td>
<td> 最大 </td>
<td> Max </td>
<td> max </td>
</tr>
<tr>
<td></td>
<td> 最小 </td>
<td> Min </td>
<td> min </td>
</tr>
<tr>
<td></td>
<td> 合計 </td>
<td> Sum </td>
<td> IntStream.sum / Collectors.summarizingXXX</td>
</tr>
<tr>
<td></td>
<td> 先頭 </td>
<td> First / FirstOrDefault </td>
<td> findFirst </td>
</tr>
<tr>
<td></td>
<td> 終端 </td>
<td> Last / LastOrDefault </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> とりあえず値を得る </td>
<td> </td>
<td> findAny </td>
</tr>
<tr>
<td></td>
<td> 集計用の汎用関数？ </td>
<td> </td>
<td> collect </td>
</tr>
<tr>
<td></td>
<td> 1件の値を得る </td>
<td> Single / SingleOrDefault </td>
<td> </td>
</tr>
<tr>
<td></td>
<td> 空なら既定値を返す </td>
<td> DefaultIfEmpty </td>
<td> </td>
</tr>
<tr>
<td></td>
<td> 全データが条件にマッチするか？ </td>
<td> All </td>
<td> allMatch </td>
</tr>
<tr>
<td></td>
<td> いずれかのデータが条件にマッチするか？ </td>
<td> Any </td>
<td> anyMatch </td>
</tr>
<tr>
<td></td>
<td> いずれかのデータも条件にマッチしないか？ </td>
<td> </td>
<td> noneMatch </td>
</tr>
<tr>
<td></td>
<td> <strong>【生成系】</strong> </td>
<td>  </td>
<td>  </td>
</tr>
<tr>
<td></td>
<td> 空っぽ </td>
<td> Empty </td>
<td> empty </td>
</tr>
<tr>
<td></td>
<td> 範囲を生成 </td>
<td> Range </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> 繰り返す </td>
<td> Repeat </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> 無限リスト生成 </td>
<td> </td>
<td> generate / iterate </td>
</tr>
<tr>
<td></td>
<td> <strong>【その他】</strong> </td>
<td>  </td>
<td>  </td>
</tr>
<tr>
<td></td>
<td> </td>
<td> SequenceEqual </td>
<td> </td>
</tr>
<tr>
<td></td>
<td> 列挙 </td>
<td> ToList().ForEach </td>
<td> forEach </td>
</tr>
<tr>
<td></td>
<td> なんか Action を挟む(デバッグ用？) </td>
<td> </td>
<td> peek </td>
</tr>
</tbody>
</table>


<p>ううむ、合成系の機能はほとんどないようです…ので自力でやるしか。
以下、サンプル。</p>

<h2>サンプル</h2>

<p>LINQ の方は Mac+Mono(Xamarin) で試しています（ぼそり</p>

<h3>抽出(Where)、並べ替え(OrderBy)、射影(Select)</h3>

<p>0〜9 を、偶数値だけ抽出して、降順にソートして、値を10倍して、出力。</p>

<p><code>csharp C#
Enumerable.Range(0, 10)
  .Where(x =&gt; x % 2 == 0)
  .OrderByDescending(x =&gt; x)
  .Select(x =&gt; x * 10)
  .ToList().ForEach(Console.WriteLine);
</code></p>

<p><code>java Java
Arrays.asList(0,1,2,3,4,5,6,7,8,9).stream()
  .filter(x -&gt; x % 2 == 0)
  .sorted((x, y) -&gt; y - x)
  .map(x -&gt; x * 10)
  .forEach(System.out::println);
</code></p>

<p><code>
80 60 40 20 0
</code></p>

<h3>平坦化して射影(SelectMany)</h3>

<p>1〜5のリストから、「n×10から始まるn件」のリストを生成。(結果見たほうが分かりやすいな（^_^;)</p>

<p><code>csharp C#
Enumerable.Range(1, 5)
  .SelectMany(x =&gt; Enumerable.Range(10 * x, x))
  .ToList().ForEach(Console.WriteLine);
</code></p>

<p><code>java Java
Arrays.asList(1,2,3,4,5).stream()
  .flatMap(x -&gt; IntStream.range(x * 10, x * 10 + x).boxed())
  .forEach(System.out::println);
</code></p>

<p><code>
10
20 21
30 31 32
40 41 42 43
50 51 52 53 54
</code></p>

<h3>抽出系(Take, Skip)</h3>

<p>1〜10のリストの3件飛ばして、5件取得。</p>

<p><code>csharp C#
Enumerable.Range(1, 10)
  .Skip(3)
  .Take(5)
  .ToList().ForEach(Console.WriteLine);
</code></p>

<p><code>java Java
// 無限リストでも limit あるから大丈夫
Stream.iterate(1, x-&gt; x++)
  .skip(3)
  .limit(5)
  .forEach(System.out::println);
</code></p>

<p><code>
4 5 6 7 8
</code></p>

<p>LINQ には件数でなく条件を指定できる <code>TakeWhile</code> <code>SkipWhile</code> がありますが、Java にはなさそうなので <code>filter</code> で代用しないといけなさそう。</p>

<p><code>csharp C#
Enumerable.Range(1, 10)
  .SkipWhile(x =&gt; x &lt; 4)
  .TakeWhile(x =&gt; x &lt; 9)
  .ToList().ForEach(Console.WriteLine);
</code></p>

<h3>連結(Concat)</h3>

<p>2つのリストをつなげる</p>

<p><code>csharp C#
new int[] { 1, 2, 3 }.Concat(new int[]{ 30, 20, 10 })
.ToList().ForEach(Console.WriteLine);
</code></p>

<p><code>java Java
Stream.concat(
  Arrays.asList(1,2,3).stream(),
  Arrays.asList(30,20,10).stream())
.forEach(System.out::println);
</code></p>

<p>なんで static メソッドやねん…。</p>

<p><code>
1 2 3 30 20 10
</code></p>

<h3>積集合(Intersect)、和集合(Union)、差集合(Except)</h3>

<p>積集合：2つのリストから重複をなくす。
和集合：2つのリストをマージする。
差集合：リスト1を基準にリスト2との差分を得る。</p>

<p>```csharp C#
var list1 = new int[]{1,2,3,4,5,6};
var list2 = new int[]{8,7,6,5,4};</p>

<p>list1.Intersect(list2)
  .ToList().ForEach(Console.WriteLine);</p>

<p>list1.Union(list2)
  .ToList().ForEach(Console.WriteLine);</p>

<p>list1.Except(list2)
  .ToList().ForEach(Console.WriteLine);
```</p>

<p>```java Java
// 自力で実現かよｗ
list1.stream().filter(x &ndash;> list2.stream().anyMatch(y &ndash;> y == x))
  .forEach(System.out::println);</p>

<p>Stream.concat(list1.stream(),
  list2.stream().filter(x &ndash;> list1.stream().noneMatch(y &ndash;> y == x)))
  .forEach(System.out::println);</p>

<p>list1.stream().filter(x &ndash;> list2.stream().noneMatch(y &ndash;> y == x))
  .forEach(System.out::println);
```</p>

<p><code>
4 5 6 // 積
1 2 3 4 5 6 8 7 // 和
1 2 3 // 差
</code></p>

<h3>内部結合(Join)</h3>

<p>商品マスタと売上テーブルを INNER JOIN する的な。</p>

<p>```csharp C#
var master = new [] {</p>

<pre><code>new { Id = 1, Name = "Apple" },
new { Id = 2, Name = "Grape" }
</code></pre>

<p>};</p>

<p>var sales = new [] {</p>

<pre><code>new { Id = 1, Sales = 100 },
new { Id = 2, Sales = 200 },
new { Id = 2, Sales = 300 },
new { Id = 3, Sales = 400 },
</code></pre>

<p>};</p>

<p>master.Join(sales,
  outer=>outer.Id,
  inner=>inner.Id,
  (o, i) => new { o.Name, i.Sales })
.ToList().ForEach(Console.WriteLine);
```</p>

<p>```java Java
// 自力
List&lt;Pair&lt;Integer, String>> master = Arrays.asList(
  new Pair&lt;>(1, &ldquo;Apple&rdquo;),
  new Pair&lt;>(2, &ldquo;Grape&rdquo;)
);</p>

<p>List&lt;Pair&lt;Integer, Integer>> sales = Arrays.asList(
  new Pair&lt;>(1, 100),
  new Pair&lt;>(2, 200),
  new Pair&lt;>(2, 300),
  new Pair&lt;>(3, 400)
);</p>

<p>master.stream()
  .flatMap(outer &ndash;> sales.stream()</p>

<pre><code>.filter(inner -&gt; outer.getKey() == inner.getKey())
.map(z-&gt; new Pair&lt;String, Integer&gt;(outer.getValue(), z.getValue())))
</code></pre>

<p>  .forEach(System.out::println);
```</p>

<p><code>
{ Name = Apple, Sales = 100 }
{ Name = Grape, Sales = 200 }
{ Name = Grape, Sales = 300 }
</code></p>

<h3>外部結合(GroupJoin)</h3>

<p>商品マスタと売上テーブルを OUTER JOIN する的な。結合先のテーブルに行が見つからなかったものは null になる。</p>

<p>```csharp C#
var master = new [] {</p>

<pre><code>new { Id = 1, Name = "Apple" },
new { Id = 2, Name = "Grape" },
new { Id = 5, Name = "Orange" },
</code></pre>

<p>};</p>

<p>var sales = new [] {  // Orange は無い</p>

<pre><code>new { Id = 1, Sales = 100},
new { Id = 2, Sales = 200},
new { Id = 3, Sales = 400},
</code></pre>

<p>};</p>

<p>master.GroupJoin(sales,
  outer=>outer.Id,
  inner=>inner.Id,
  (o, i) => new { o.Name, FirstOfSales = i.Select(</p>

<pre><code>x=&gt;(int?)x.Sales).FirstOrDefault() }) // 無かったら null にしたいので null許容型にしてから FirstOrDefault
</code></pre>

<p>.ToList().ForEach(Console.WriteLine);
```</p>

<p>たぶん普通は First じゃなくて Sum とか使うんだろう。</p>

<p>```java Java
// これも自力
List&lt;Pair&lt;Integer, String>> master = Arrays.asList(
  new Pair&lt;>(1, &ldquo;Apple&rdquo;),
  new Pair&lt;>(2, &ldquo;Grape&rdquo;),
  new Pair&lt;>(5, &ldquo;Orange&rdquo;)
);</p>

<p>List&lt;Pair&lt;Integer, Integer>> sales = Arrays.asList(
  new Pair&lt;>(1, 100),
  new Pair&lt;>(2, 200),
  new Pair&lt;>(2, 300),
  new Pair&lt;>(3, 400)
);</p>

<p>master.stream().map(outer->new Pair&lt;String, Optional<Integer>>(outer.getValue(),
  sales.stream()</p>

<pre><code>.filter(inner-&gt;inner.getKey() == outer.getKey()) // Id でフィルタ
  .map(x-&gt;x.getValue()) // Sales だけに射影
  .findFirst())) // 同一Id中の先頭
</code></pre>

<p>  .forEach(System.out::println);
```</p>

<p>```
[.NET]
{ Name = Apple, FirstOfSales = 100 }
{ Name = Grape, FirstOfSales = 200 }
{ Name = Orange, FirstOfSales = } // 相手が居ないやつは null になる</p>

<p>[Java]
Apple=Optional[100]
Grape=Optional[200]
Orange=Optional.empty // Option だから empty になるのは良い
```</p>

<h3>2つの値を揃えて流す(Zip)</h3>

<p>２つのリストの値をひとつずつセットにして流す。</p>

<p>```csharp C#
var arr1 = new int[] { 1, 2, 3, 4, 5 };
var arr2 = new string[] { &ldquo;hoge&rdquo;, &ldquo;fuga&rdquo;, &ldquo;piyo&rdquo; };</p>

<p>arr1.Zip(arr2, (x, y) =>  new {x, y})</p>

<pre><code>.ToList()
.ForEach(Console.WriteLine);
</code></pre>

<p>```</p>

<p><code>java Java
// FIXME どうやるの？ Streams.zip はどこいった？
</code></p>

<p><code>
{ x = 1, y = hoge }
{ x = 2, y = fuga }
{ x = 3, y = piyo }
</code></p>

<h3>重複を無くす(Distinct)</h3>

<p>重複する数値リストから重複をなくす。</p>

<p><code>csharp C#
new int[]{1,3,4,3,2,4}
  .Distinct()
  .ToList().ForEach(Console.WriteLine);
</code></p>

<p><code>java Java
Arrays.asList(1,3,4,3,2,4).stream()
  .distinct()
  .forEach(System.out::println);
</code></p>

<p><code>
1 3 4 2
</code></p>

<h3>畳み込み</h3>

<p>いろいろな集計の素、畳み込み。言語により fold とか reduce とか aggregate とか、いろいろな呼び名がありますね。
よい例が浮かなかったので Max を実装してみました。</p>

<p>```csharp C#
var max = new int[]{1,5,3,7,2,4}</p>

<pre><code>.Aggregate(Int32.MinValue, (x, y) =&gt; Math.Max(x, y));
</code></pre>

<p>Console.WriteLine(max);
```</p>

<p><code>java Java
int max = Arrays.asList(1,5,3,7,2,4).stream()
  .reduce(Integer.MIN_VALUE, (x, y) -&gt; Math.max(x, y));
System.out.println(max);
</code></p>

<p><code>
7
</code></p>

<h3>グループ化</h3>

<p>リストの要素をキーにしてグループ化する。Salesは合計を計算する。</p>

<p>```csharp C#
var sales = new [] {</p>

<pre><code>new { Id = 1, Sales = 100 },
new { Id = 2, Sales = 200 },
new { Id = 2, Sales = 300 },
new { Id = 3, Sales = 400 },
</code></pre>

<p>};</p>

<p>sales.GroupBy(x=>x.Id, (Id, groupedSales) => new {Id,</p>

<pre><code>SumOfSales = groupedSales.Sum( element =&gt; element.Sales) // Sales は合計する
</code></pre>

<p>  })
  .ToList().ForEach(Console.WriteLine);
```</p>

<p>（LINQ ではありませんが、 <code>List.LookUp</code> を使って実現することもできるようです → <a href="http://qiita.com/amay077/items/9d2941283c4a5f61f302#comment-82388821b902ad7999b0">コメント:2014/03/22 00:29</a>）</p>

<p>```java Java
// javafx に Pair があったので Tuple 代わりに使っちゃった
List&lt;Pair&lt;Integer, Integer>> list1 = Arrays.asList(
  new Pair&lt;>(1, 100),
  new Pair&lt;>(2, 200),
  new Pair&lt;>(2, 300),
  new Pair&lt;>(3, 400)
);</p>

<p>list1.stream().collect(Collectors.groupingBy(x &ndash;> x.getKey()))
  .entrySet().stream() // group化の結果が Map なので、エントリを Stream 化
  .map(x &ndash;> new Pair&lt;Integer, Integer>(</p>

<pre><code>x.getKey(), // Key が Id に相当
x.getValue().stream().collect(Collectors.summingInt(y-&gt;y.getValue())))) // Value が List なのでまた Stream 化して合計を得る
</code></pre>

<p>  .forEach(System.out::println);</p>

<p>// Collectors.groupingBy 使わずに Map.merge を使ったほうが分かりやすい気も。。。
list1.stream().collect(
  () &ndash;> new HashMap&lt;Integer, Integer>(),
  (map, item) &ndash;> map.merge(item.getKey(), item.getValue(), (x, y) &ndash;> x + y), // 同じキーの値を加算してく
  (left, right) &ndash;> left.putAll(right))
  .forEach((k, v) &ndash;> System.out.println(k + &ldquo;:&rdquo; + v));
```</p>

<p>Java の方、カオスすぎる…。.NET の <code>IGrouping</code> を Map でやってるからだな。</p>

<p>```
[.NET]
{ Id = 1, SumOfSales = 100 }
{ Id = 2, SumOfSales = 500 } // ID=2 の Sales が合計されている
{ Id = 3, SumOfSales = 400 }</p>

<p>[Java]
1=100
2=500
3=400
```</p>

<h3>合計(Sum)、最大(Max)、最小(Min)、平均(Average)、件数(Count)、先頭(First)、終端(Last)</h3>

<p>集計いろいろ。</p>

<p><code>csharp C#
var list1 = Enumerable.Range(0, 10);
Console.WriteLine("Sum={0}", list1.Sum());
Console.WriteLine("Max={0}", list1.Max());
Console.WriteLine("Min={0}", list1.Min());
Console.WriteLine("Count={0}", list1.Count());
Console.WriteLine("First={0}", list1.First());
Console.WriteLine("Last={0}", list1.Last());
Console.WriteLine("Average={0}", list1.Average());
</code></p>

<p>```java Java
List<Integer> list1 = Arrays.asList(0,1,2,3,4,5,6,7,8,9);
IntSummaryStatistics stats = list1.stream().collect(Collectors.summarizingInt(x &ndash;> x)); // Max,Min,Count,Average が取得できる
System.out.println(&ldquo;Sum=&rdquo; + stats.getSum());
System.out.println(&ldquo;Max=&rdquo; + stats.getMax());
System.out.println(&ldquo;Min=&rdquo; + stats.getMin());
System.out.println(&ldquo;Count=&rdquo; + stats.getCount());
System.out.println(&ldquo;First=&rdquo; + list1.stream().findFirst().orElse(-1)); // summarizing では取れない
System.out.println(&ldquo;Last=&rdquo; + list1.stream().sorted((x,y) &ndash;> y-x).findFirst().orElse(-1)); // 微妙
System.out.println(&ldquo;Average=&rdquo; + stats.getAverage());</p>

<p>System.out.println(&ldquo;Average=&rdquo; + IntStream.range(0, 10).average()); // 型指定 Stream なら average, sum がある（結果は Option に包まれる）
```</p>

<p><code>
Sum=45
Max=9
Min=0
Count=10
First=0
Last=9
Average=4.5
</code></p>

<p>…疲れた。。。</p>
]]></content>
  </entry>
  
</feed>
