<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: jUnit | Experiments Never Fail]]></title>
  <link href="http://amay077.github.io/blog/categories/junit/atom.xml" rel="self"/>
  <link href="http://amay077.github.io/"/>
  <updated>2013-09-30T23:33:52+09:00</updated>
  <id>http://amay077.github.io/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android の jUnit テストで Context が欲しい時]]></title>
    <link href="http://amay077.github.io/blog/2013/01/19/gets-context-on-android-junit/"/>
    <updated>2013-01-19T00:44:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/01/19/gets-context-on-android-junit</id>
    <content type="html"><![CDATA[<p>Activity のテストなら <code>ActivityInstrumentationTestCase2</code> 、 Service なら <code>ServiceTestCase</code> を使うべきなんでしょうけど、Android って事あるごとに Context が必要なので、ただのクラスライブラリのテストでも必要なことがシバシバ。</p>

<!-- more -->


<p>``` java HogeTest.java
public class HogeTest extends InstrumentationTestCase {</p>

<pre><code>/** ApplicationContext を取得します */
private Context getApplicationContext() {
    return this.getInstrumentation().getTargetContext().getApplicationContext();
}
</code></pre>

<p>}
```</p>

<h2>参考</h2>

<ul>
<li>[androidの単体テスト(AndroidTestCase) - Androidのド肝] (http://blog.haw.co.jp/android/?p=471) - クラス図がとても役に立ちました</li>
<li><a href="http://stackoverflow.com/questions/5544205/accessing-application-context-from-testsuite-in-setup-before-calling-getactivi">android - Accessing application context from TestSuite in Setup() before calling getActivity() - Stack Overflow</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jUnit で非同期処理のテストがちょっと楽になるクラス作ってみた]]></title>
    <link href="http://amay077.github.io/blog/2012/12/20/asynctest-on-junit/"/>
    <updated>2012-12-20T19:07:00+09:00</updated>
    <id>http://amay077.github.io/blog/2012/12/20/asynctest-on-junit</id>
    <content type="html"><![CDATA[<p>非同期メソッドのテストって、皆さんどうやってるんでしょう？
ちょっとググってみたけど「<code>Object.wait</code> とか <code>CountDownLatch</code> とか <code>Future</code> で待て」とかあんまり良い答えが見つからなかったので、自分でユーティリティクラス作ってみた。</p>

<!-- more -->


<p>まあ CountDownLatch で待ってるだけなんですけども。</p>

<p>2013.1.10 修正:メソッドに全部 <code>synchronized</code> つけたら動かんやん、恥ずかし…</p>

<p>```java FutureResult.java
/<em>*
 * success または error が呼ばれるまで get() で待ってる Future みたいなクラス
 *
 * @author @amay077
 </em>/
public class FutureResult<T> {</p>

<pre><code>private final int TIMEOUT = 10;
private final TimeUnit TIMEOUT_UNIT = TimeUnit.SECONDS;

private final CountDownLatch _latch = new CountDownLatch(1);
private T _value;
private Exception _error;

public static class FutureResultException extends Exception {
    private static final long serialVersionUID = 1L;

    public FutureResultException(Exception detailException) {
        super(detailException);
    }
}

/**
 * 非同期処理が成功したら呼ぶメソッド
 */
public synchronized void success(T value) {
    _value = value;
    _latch.countDown();
}

/**
 * 非同期処理が失敗したら呼ぶメソッド
 */
public synchronized void error(Exception ex) {
    _error = ex;
    _latch.countDown();
}

/**
 * 非同期処理が終わるまで待って結果を返す。
 * エラーだったら例外を投げる。
 */
public T get() throws Exception {
    try {
        if (!_latch.await(TIMEOUT, TIMEOUT_UNIT)) {
            throw new FutureResultException(new TimeoutException());
        }
    } catch (Exception ex) {
        throw new FutureResultException(ex);
    }

    if (_error != null) {
        throw _error;
    }

    return _value;
}
</code></pre>

<p>}
```</p>

<p>Future インターフェースを implements しようと思ったけど数が多くてやめたｗ
使い方はこんな感じ。</p>

<p>```java AsyncMethodTest.java
public void testAsyncMethod() {</p>

<pre><code>final FutureResult&lt;Integer&gt; result = new FutureResult&lt;Integer&gt;();

// 非同期なメソッドを実行
hoge.asyncMethod(new OnReceiveListener() {
    @Override
    public void onReceive(Integer data) {
        // 正そうな値を受信しtら success を呼ぶ
        result.success(data);
    }

    @Override
    public void onError(Exception ex) {
        // エラーを受信した場合は error を呼ぶ
        result.error(ex);
    }
});

// 検証
try {
    // get で success か error かタイムアウトするまで待ってる。
    Assert.assertEquals(0, result.get()); 
} catch (Exception e) {
    fail(e.getMessage());
}
</code></pre>

<p>}</p>

<p>```</p>

<h2>参考</h2>

<p>なんて記事を書いたあとにもっかいググってみたらこんなライブラリがあるようで。詳細はまだ見てない。</p>

<ul>
<li><a href="http://code.google.com/p/awaitility/">Awaitility</a> - Awaitility is a small Java-based DSL for synchronizing asynchronous operations. It makes it easy to test asynchronous code. - Google Project Hosting</li>
</ul>

]]></content>
  </entry>
  
</feed>
