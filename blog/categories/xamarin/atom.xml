<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: xamarin | Experiments Never Fail]]></title>
  <link href="http://blog.amay077.net/blog/categories/xamarin/atom.xml" rel="self"/>
  <link href="http://blog.amay077.net/"/>
  <updated>2014-08-05T22:56:59+09:00</updated>
  <id>http://blog.amay077.net/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ランダムで且つ重複しない数値リストを作る]]></title>
    <link href="http://blog.amay077.net/blog/2014/07/08/create-distinct-array-in-fsharp/"/>
    <updated>2014-07-08T00:00:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/07/08/create-distinct-array-in-fsharp</id>
    <content type="html"><![CDATA[<p>F# 入門中です。</p>

<!--more-->


<p><a href="http://www.shuzan.jp/kentei/flash/">フラッシュ暗算</a>ぽいアプリを作っていて、次々と表示する数値は、</p>

<ul>
<li>ランダムで</li>
<li>一度使った数値は二度と使わなくて</li>
<li>０も使わない</li>
</ul>


<p>というルールにしています（公式ルールは知らない）</p>

<p><code>makeRandomList</code> の引数 <code>rand</code> は <code>System.Random</code> のインスタンス、<code>count</code> は生成するリストの要素数、<code>arr</code> は生成した数値群(=再帰処理で値の既出判定に使う)としています。</p>

<p><code>rand.Next(10)</code> で得た値が、0 もしくは <code>arr</code> に存在する場合は、もう一度同じパラメータで再帰呼び出し、そうでない場合は <code>count</code> を減算しつつ、<code>arr</code> に値を連結して再帰呼び出しします。<code>count</code> が <code>0</code> になったら <code>arr</code> を返して終わります。</p>

<p>```fsharp
let rec makeRandomList = fun (rand:Random, count:int, arr:List<int>) &ndash;></p>

<pre><code>match count with
| 0 -&gt; arr
| _ -&gt; 
    let n = rand.Next(10) // 1桁の数値
    if n = 0 || arr |&gt; List.exists (fun x-&gt;x=n) then 
        makeRandomList (rand, count, arr) 
    else makeRandomList (rand, count-1, [n] @ arr)
</code></pre>

<p>let arr = makeRandomList (new Random(DateTime.Now.Millisecond), 3, [])
for x in arr do</p>

<pre><code>Console.WriteLine x
</code></pre>

<p>// 出力例
7
5
4
```</p>

<p>こんな感じで書けばいいのかなあ。
なんかところどころ手続き型の書き方になってる気がしますが、C# で <code>while</code> で処理するよりはスマートにできた気がします。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin で System.Data.SqlClient を使うには BUSINESS 版以上が必要です]]></title>
    <link href="http://blog.amay077.net/blog/2014/07/01/sqlclient-require-business-edition/"/>
    <updated>2014-07-01T01:00:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/07/01/sqlclient-require-business-edition</id>
    <content type="html"><![CDATA[<p>当方 Xamarin INDIE 版しか買えないしがない個人開発者です。</p>

<!--more-->


<p>Xamarin で <code>System.Data.SqlClient.SqlCommand</code> などを使ったプロジェクトをビルドしたら、ビルド時にこんなダイアログボックスが。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/xamarin_requires_business_edition_when_using_sqlclient_01.png" alt="" /></p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/xamarin_requires_business_edition_when_using_sqlclient_02.png" alt="" /></p>

<p>どうやら、特定のクラスを使用するには BUSINESS 版以上が必要なようです。</p>

<ul>
<li><a href="http://qiita.com/amay077/items/ab90c74e78dd87ba31fb">Xamarin でビルドを自動化するには Business 版以上が必要です</a></li>
</ul>


<p>といい、INDIE 版の制限事項が後出しで判明するのなんとかならないですかね。</p>

<p>今回は .NET のプロジェクトを Xamarin に移植する際に発覚したもので、特に <code>SqlClient</code> は使ってなかったので削除して解決しました。</p>

<p>Xamarin で <code>SqlClient</code> って何に使うんだろ？イントラ？あるいは SQL Server Compact が使える？まさかね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.Forms、Android での BACK キーの制御]]></title>
    <link href="http://blog.amay077.net/blog/2014/06/17/hooking-back-key-in-xamarin-forms/"/>
    <updated>2014-06-17T01:00:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/06/17/hooking-back-key-in-xamarin-forms</id>
    <content type="html"><![CDATA[<p><a href="http://qiita.com/amay077/items/12979585ac3e2dcacacb">Xamarin.Forms でどうにかしたい iOS と Android の違い</a> の「BACKキーの制御」の <strong>現時点(1.1.0.6201)</strong> での回答。</p>

<!--more-->


<p>Android の BACKキーの制御を、Xamarin.Forms ではどう扱えるかを調べた。</p>

<h2>シナリオ</h2>

<p>Xamarin.Forms による画面１(MainPage)、２(SecondPage)があり、MainPage では BACKキーで戻る(=アプリ終了)事ができるが、SecondPage ではBACKキーが効かない、ようにしたい。</p>

<h2>対策</h2>

<p>まず画面１と２はこんな感じ。ボタンを押したら画面２へ遷移するだけ。</p>

<p>```csharp Pages.cs
// 画面１
public class MainPage : ContentPage
{</p>

<pre><code>public MainPage() 
{
    var button = new Button
    {
        Text = "To Second",
        VerticalOptions = LayoutOptions.Center,
    };

    button.Clicked += (sender, e) =&gt; 
    {
        this.Navigation.PushAsync(new SecondPage());
    };

    Content = button;
}
</code></pre>

<p>}</p>

<p>// 画面２
public class SecondPage : ContentPage
{</p>

<pre><code>public SecondPage()
{
    Content = new Label
    {
        Text = "Second"
    };
}
</code></pre>

<p>}
```</p>

<p>ここからが本題。
まず Android側のエントリポイントである <code>MainActivity.cs</code> は以下のように、<code>ContentPage</code> プロパティを設ける。そして <code>OnBackPressed</code> メソッドを override して、MainPage だったら OnBackPressed を親へ伝搬する。</p>

<p>```csharp MainActivity.cs
[Activity(Label = &ldquo;ScrollTest.Android.Android&rdquo;, MainLauncher = true)]
public class MainActivity : AndroidActivity
{</p>

<pre><code>protected override void OnCreate(Bundle bundle)
{
    base.OnCreate(bundle);

    Xamarin.Forms.Forms.Init(this, bundle);

    SetPage(new NavigationPage(new MainPage()));
}

internal Page ContentPage
{
    get;
    set;
}

public override void OnBackPressed()
{
    if (this.ContentPage is MainPage)
    {
        base.OnBackPressed();
    }
}
</code></pre>

<p>}
```</p>

<p>次に、MainActivity.ContentPage への設定を行うコードは以下の通り。
PageRenderer を拡張して ExportRenderer することで、すべての Page にフックをかけ、Page の表示時に MainActivity.ContentPage に設定する。</p>

<p>```csharp MyPageRenderer.cs
using System;
using Xamarin.Forms.Platform.Android;
using Android.App;
using Xamarin.Forms;
using ScrollTest.Android;
using Android.Views;
using Android.Graphics;</p>

<p>[assembly:ExportRenderer(typeof(ContentPage), typeof(MyPageRenderer))]</p>

<p>namespace ScrollTest.Android
{</p>

<pre><code>public class MyPageRenderer : PageRenderer
{
    protected override void OnElementChanged(ElementChangedEventArgs&lt;Xamarin.Forms.Page&gt; e)
    {
        base.OnElementChanged(e);

        // なんとなく不安なので weak にしてみた
        var activity = new WeakReference&lt;MainActivity&gt;(this.Context as MainActivity);

        e.NewElement.Appearing += (_, __) =&gt;
        {
            MainActivity a;
            if (activity.TryGetTarget(out a)) {
                a.ContentPage = e.NewElement;    
            }
        };
    }
}
</code></pre>

<p>}
```</p>

<p>これで、画面１(MainPage)の時だけ BACKキーが効くようにできる。</p>

<h3><code>Appearing</code> イベントが必要なの？</h3>

<p>　Xamarin.Forms の Android実装では、画面遷移の度に <strong>「同じインスタンスの MainActivity」</strong> が使いまわされる、さらに <code>OnElementChanged</code> は、各Pageにつき１度しか発生しない。その為、画面１→２→１と遷移すると <code>MainActivity.ContentPage</code> は <code>SecondPage</code> のままになってしまう。ので <code>Appearing</code> イベントで表示の度に MainActivity.ContentPage を設定する必要がある。</p>

<h3><code>AndroidActivity</code> に static な <code>BackPressed</code> イベントがあるんだけど…</h3>

<p>イベントハンドラの定義は
<code>public delegate bool BackButtonPressedEventHandler(object sender, EventArgs e);</code>
となっていて、<code>true</code> を返すと BACK キーを無効にできるようなのだけど、<code>sender</code> は <code>MainActivity</code>だし、<code>EventArgs</code> は Page を取得できないしで使えないじゃん。。。</p>

<p>なんだかすごく発展途上な気がする、その内いろいろ整備されそうなので、それまで待った方が良い気がします。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.Forms の Label から iOS の UILabel を取り出す]]></title>
    <link href="http://blog.amay077.net/blog/2014/06/13/convert-xamarin-forms-label-to-native-uilabel/"/>
    <updated>2014-06-13T15:34:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/06/13/convert-xamarin-forms-label-to-native-uilabel</id>
    <content type="html"><![CDATA[<p><a href="http://qiita.com/amay077/items/12979585ac3e2dcacacb">Xamarin.Forms でどうにかしたい iOS と Android の違い</a> の「文字の自動縮小」の自己回答。</p>

<!--more-->


<p>Xamarin.Forms で定義した <code>Label</code> は、iOS では <code>UILabel</code> となるはずなので、その過程のどこかでフックできれば <code>UILabel.AdjustsFontSizeToFitWidth</code> が仕込める、と目論んで、ホントにできたのでメモ。</p>

<h2>要点</h2>

<p><del>Forms→ネイティブのフックは PageRenderer でできる。その中で得られる UIView（のサブクラス）は、Label と UILabel の両方の参照を持っているので、あとは使うだけ。</del></p>

<p><strong>ページでなく、UIパーツレベルでフックできたので、全面的に書き換えた。</strong></p>

<h2>やってみる</h2>

<p>参考にしたのは <a href="https://github.com/xamarin/xamarin-forms-samples/tree/master/Forms2Native">https://github.com/xamarin/xamarin-forms-samples/tree/master/Forms2Native</a> 。</p>

<p>このサンプルをちょっと改造して試した。</p>

<p>まずは Forms側の MySecondPage.cs を修正。</p>

<p>```csharp MySecondPage.cs
public class MySecondPage : ContentPage
{</p>

<pre><code>public Label MyLabel { get; private set; }

public MySecondPage ()
{
    this.MyLabel = new Label
    {
        Text = "Too loooooooooooooooooooooooong label",
        Font = Font.SystemFontOfSize(30d),
        LineBreakMode = LineBreakMode.NoWrap
    };

    Content = new StackLayout
    {
        Orientation = StackOrientation.Vertical,
        VerticalOptions = LayoutOptions.CenterAndExpand,
        Children = 
        {
            this.MyLabel
        }
    };
}
</code></pre>

<p>}
```</p>

<p>ラベルを配置。とても文字が長いので全部は表示しきれない。</p>

<p>次に iOS側に MyLabelRenderer.cs を作成。</p>

<p>```csharp MyLabelRenderer.cs
using System;
using Xamarin.Forms;
using Forms2Native;
using Xamarin.Forms.Platform.iOS;
using MonoTouch.UIKit;</p>

<p>[assembly:ExportRenderer(typeof(Label), typeof(MyLabelRenderer))]</p>

<p>namespace Forms2Native
{</p>

<pre><code>public class MyLabelRenderer : LabelRenderer
{
    protected override void OnElementChanged(ElementChangedEventArgs&lt;Label&gt; e)
    {
        base.OnElementChanged(e);
        this.Control.AdjustsFontSizeToFitWidth = true;
    }
}
</code></pre>

<p>}
```</p>

<p><code>ExportRenderer</code> で「Formsの<code>Label</code>は、<code>MyLabelRenderer</code>を使う」と定義している。
するとすべての <code>Label</code> の生成時を <code>OnElementChanged</code> でフックでき、<code>Control</code> で <code>UILabel</code> は取り出せるので、あとはご自由に、という感じ。</p>

<p>この実装だと、すべての Label に Ajusts が適用されてしまう。個別に行いたい場合は、Forms側に Labelから派生した <code>AjustableLabel</code> を作成して使い、<code>ExportRenderer(typeof(Label),…</code> のところを <code>ExportRenderer(typeof(AjustableLabel),…</code> にすればいけるはず。そしてこの方法はカスタムビューを作る手順に通じる（というかそのもの？）はず。</p>

<p>ちなみにこの <code>OnElementChanged</code> は、Nuget の Xamarin.Formsパッケージの Ver1.1.0.6201から利用できる。</p>

<h2>実行する</h2>

<p>こんな感じで、ちゃんと文字サイズが縮小されました。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/getting_uilabel_from_xamarin_forms.png" alt="" /></p>

<p>Android の方も同じ要領でいけるは…ず。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.Forms でどうにかしたい iOS と Android の違い]]></title>
    <link href="http://blog.amay077.net/blog/2014/06/10/difference-ios-and-android-in-xamarin-forms/"/>
    <updated>2014-06-10T15:30:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/06/10/difference-ios-and-android-in-xamarin-forms</id>
    <content type="html"><![CDATA[<p>Xamarin.Forms で簡単な iOS/Android 両対応アプリを作ってみてて、悩ましい点がいくつか見つかってるので、挙げてみる。</p>

<!--more-->


<h2><del>不可視の扱い</del></h2>

<p><del>Forms 側のパーツには <code>IsVisible = true | false</code> がある。
iOS は <code>true | false</code> なのでいいけど、Android の Visibility は、 <code>Visible | Invisible | Gone</code> の3つある。</del></p>

<p><del>Forms 側での <code>IsVisible = false</code> は、Android では <code>Invisible</code> に相当するみたい。つまり StackLayout とかで「不可視なパーツが <strong>詰められない</strong>」。 iOS の <code>Visible = false</code> は <strong>詰められる</strong> 模様。</del></p>

<p><code>IsVisible = false</code> は Android ではちゃんと <code>Gone</code> になってました、すいませんでした。</p>

<h2>空文字の扱い</h2>

<p>IsVisible と勘違いしてたのはこっちだった。</p>

<p>StackLayout に、Label を2つ積んで、上の Label を空文字にすると、iOSでは詰められるけど、Androidでは空白が空くみたい。こっちはちゃんと裏をとった(汗)</p>

<p><a href="https://gist.github.com/amay077/cf0f4ca1aa14d54bac9a">https://gist.github.com/amay077/cf0f4ca1aa14d54bac9a</a></p>

<h2>画面回転時の再構築</h2>

<p>Android だと、画面を回転させると <code>onCreate</code> からやり直しなのは常識。
Forms アプリを Android で動かして回転させると、なんと <strong>RootPage まで戻って</strong> しまう。なんじゃこりゃ。</p>

<h2>回避方法</h2>

<blockquote class="twitter-tweet" lang="ja"><p><a href="https://twitter.com/amay077">@amay077</a> あとAndroidの回転問題（バグです）はとりあえず ConfigurationChanges = ConfigChanges.ScreenSize | ConfigChanges.Orientation で回避するといいそうです（そりゃそうだ…）</p>&mdash; Atsushi Eno (@atsushieno) <a href="https://twitter.com/atsushieno/statuses/476645011602165760">2014, 6月 11</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>こんな感じっすね。</p>

<p>```csharp MainActivity.cs
[Activity(MainLauncher = true,</p>

<pre><code>ConfigurationChanges = ConfigChanges.ScreenSize | ConfigChanges.Orientation )]
</code></pre>

<p>public class MainActivity : AndroidActivity
{
```</p>

<h2>BACKキーの扱い</h2>

<p>iOS なら <code>NavigationPage.SetHasNavigationBar(page, false)</code> としてしまえば、ナビゲーションバーが表示されなくなるので、前の画面に戻ることはできなくなるが、Android の BACKキーを無効にするにはどうしたら。。。</p>

<h3>自己解決</h3>

<p><code>AndroidActivity</code> のサブクラスで、<code>OnBackPressed</code> を override して実装を潰してしまえばよい。けど画面毎に「戻る／戻れない／Confirm出す」とか細かい制御ができるのかは不明。</p>

<h2>デフォルトスタイル</h2>

<p>iOS は白基調、Androidは黒基調なので、Forms側で <code>TextColor = Color.Black</code> などとすると、当たり前だが Android で見えない。
iOS はスタイル変えるのしんどいので、Android側の Theme を <code>Theme.Holo.Light</code> にしとく。</p>

<p>```csharp MainActivity.cs
[Activity(Label = &ldquo;MyApp&rdquo;,<br/>
 MainLauncher = true,
 Theme = &ldquo;@android:style/Theme.Holo.Light&rdquo;)]
public class MainActivity : AndroidActivity
{</p>

<pre><code>protected override void OnCreate(Bundle bundle)
{
    /* 以下省略 */
</code></pre>

<p>```</p>

<h2>起動時</h2>

<p>Android 側の起動時に ActionBar の付いた空白画面が表示される時間が割とながくて気になる(Galaxy Nexus だけど)。Forms の画面をロードするのに時間がかかるのだろうか？
ActionBar だけでも消したくて Theme を <code>Theme.Holo.Light.NoActionBar</code> にしてみたら Page が表示されなくなった。。。</p>

<p>NoActionBar な Theme を使うと Activity.ActionBar が null になるんだけど、Xamarin.Forms がそれに対応してない気がした（スタックトレース見ると UpdateActionBar で NullReferenceException だし）ので、<a href="https://bugzilla.xamarin.com/buglist.cgi?product=Forms&amp;component=Forms&amp;resolution=---&amp;list_id=92025">Bugzilla</a> に登録してみた、初めて。どうなるやら。</p>

<h2>文字の自動縮小</h2>

<p>iOS の <code>UITextField</code> は <code>adjustsFontSizeToFitWidth</code> を設定するとパーツのサイズに合わせて文字サイズを自動拡縮してくれる機能があったけど、Forms の <code>Label</code> にはそんなものはありません。<code>PageRenderer</code> を使って iOS 独自処理しないとダメ。</p>

<h3>自己解決</h3>

<p>やはり PageRenderer 使うとできた → <a href="http://qiita.com/amay077/items/8eaa595cc2fc88797b2f">Xamarin.Forms の Label から iOS の UILabel を取り出す</a></p>

<h2>iPhone と iPad</h2>

<p>StackLayout や RelativeLayout でUIを書けば、相対的な位置関係は iPhone と同じものが iPad でも再現されるが、サイズをリテラルで指定するところは、特にインテグレーションしてくれるわけでないので、プラットフォーム毎に調整が必要。例えば文字サイズは、iPad では iPhone より大きな値にしないと残念な感じに。</p>

<p>他にも見つけたら書きます。</p>
]]></content>
  </entry>
  
</feed>
