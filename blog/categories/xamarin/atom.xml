<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Xamarin | Experiments Never Fail]]></title>
  <link href="http://amay077.github.io/blog/categories/xamarin/atom.xml" rel="self"/>
  <link href="http://amay077.github.io/"/>
  <updated>2014-02-11T19:49:37+09:00</updated>
  <id>http://amay077.github.io/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[MvvmCross だけじゃない！クロスプラットフォームMVVMフレームワーク「QuickCross」を試す]]></title>
    <link href="http://amay077.github.io/blog/2014/02/11/introduce-quickcross/"/>
    <updated>2014-02-11T19:47:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/02/11/introduce-quickcross</id>
    <content type="html"><![CDATA[<p><a href="http://amay077.github.io/blog/2013/12/25/using-mvvmcross-the-x-platform-mvvm-framework/">以前、MvvmCross を紹介しました</a> が、Xamarin で使える同種のフレームワークはまだいくつかあります。</p>

<!--more-->


<p>今回は、その中の一つ、「QuickCross」を見てみます</p>

<ul>
<li><a href="https://github.com/MacawNL/QuickCross">MacawNL/QuickCross</a></li>
</ul>


<h2>なぜ他のMVVMフレームワークが必要なのか？</h2>

<p><a href="https://github.com/MacawNL/QuickCross#why-another-cross-platform-mvvm-framework">Why another cross-platform Mvvm framework?</a> にて、MvvmCross があるのになぜ？という事を説明しています。</p>

<p>要約すると、MvvmCross は、高機能だが Fat で複雑で、拡張が大変であるのに対し、QuickCross は、軽量で生産性が高く、拡張が簡単である、との事です。</p>

<h2>主な機能</h2>

<p><a href="https://github.com/MacawNL/QuickCross#features">Features</a> より。</p>

<ul>
<li>Xamarin.iOS, Xamarin.Android, Windows Phone, Windows Store Apps に対応。</li>
<li>バイナリは使ってない！Snippet と、プロジェクトにソースコードの追加を行うだけです。</li>
<li>ViewModel や View の追加は package manager console からコマンドを実行して行います。</li>
<li>いくつかのコードスニペットを提供します。</li>
<li>以下略…</li>
</ul>


<h2>仕組み</h2>

<p><img src="https://raw.github.com/MacawNL/QuickCross/master/assets/quickcross_pattern.png" alt="" />
via https://github.com/MacawNL/QuickCross#features</p>

<p>Navigator って概念があるのが MvvmCross と違うとこですかね。</p>

<h2>使い方</h2>

<p><a href="https://github.com/MacawNL/QuickCross#getting-started">Getting Started</a> を見てください。</p>

<p>Nuget の Package manager console を使う必要があるので、Mac と Xamarin Studio 、そして Indie Edition では試せません、残念。
Visual Studio ＋ Xamarin Business Edition以上を使ってる方、試してみてください。</p>

<h2>サンプルを動かしてみた</h2>

<p>Getting Started は試せませんでしたが、github に含まれるサンプルは Mac + Xamarin Studio でも動かせました。</p>

<p><a href="https://github.com/MacawNL/QuickCross/blob/master/QuickCross.ios.sln">QuickCross.ios.sln</a> を Xamarin Studio で開いて実行したところ↓</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/introduce_quickcross_01.png" alt="" /></p>

<p>MvvmCross と同じく、ViewModel などは Shared プロジェクトの方にあります。
Shared プロジェクトは PCL にできるんじゃないかなーと思いやってみましたが、</p>

<ul>
<li>Profile147(.NET4.0) では <code>System.Windows.Input.ICommand</code> が無いと言われ</li>
<li>Profile78(.NET4.5) では、この<a href="https://bugzilla.xamarin.com/show_bug.cgi?id=17247">バグ</a> にエンカウント</li>
</ul>


<p>してビルドできませんでした、残念。</p>

<h2>まとめ</h2>

<p>MvvmCross は確かに大規模すぎて使うのが大変です。拡張するには Plugin を自作する事になりますし。
QuickCross は、すべてのソースコードがプロジェクトにあるので、カスタマイズが手軽に行えそうだというのは分かりました。</p>

<p>Xamarin Starter Edition の場合、64kbyte までのバイナリ制限があるので、MvvmCross は使えませんが、QuickCross なら使えるかも知れません。</p>

<p>ただ残念なのは、Nuget の Package Manager Console を使う必要があるために、Visual Studio が必要で、その為には Xamarin も Business Edition 以上が必要になってしまう所です。</p>

<p>Xamarin Studio のみでも使えるくらい Lightweight だったら、もっと試してみたくなるフレームワークです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C と Java と C# でクロージャ的な書き方の比較]]></title>
    <link href="http://amay077.github.io/blog/2014/01/29/closure-like-statement-comparison-with-objc-java-csharp/"/>
    <updated>2014-01-29T15:52:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/01/29/closure-like-statement-comparison-with-objc-java-csharp</id>
    <content type="html"><![CDATA[<p>クロージャとかラムダとか匿名** とか名前はいろいろですけど、各言語の書き方と動き（特に変数の扱い）について比べてみました。</p>

<p>ついでに非同期処理の例にもなってしまいました。</p>

<!--more-->


<h3>Objective-C</h3>

<p>Blocks を使います。</p>

<p>```objc Obj-C
int x = 1;
__block int y = 2;</p>

<p>dispatch_queue_t q_global = dispatch_get_global_queue(0, 0);
dispatch_async(q_global, ^{</p>

<pre><code>x = 10; // できない(コンパイルエラー
y = 20; // できる

int z = x + y;

[self dispValue:z]; // self の参照カウンタが+1される
</code></pre>

<p>});
```</p>

<p>普通に宣言した変数を Block の中で使うと、自動的に「キャプチャ」され、変数の複製される。この変数には、 Block 内では代入できずコンパイルエラーとなる。
<code>__block</code> を付けた変数は、Block 内外で同じ実体を参照でき、代入もできる。
<code>self</code> やプロパティを Block 内で使用すると参照カウンタがインクリメントされ、明示的に release しないとリークする。
あるいは、Block 外で <code>__weak</code> を付けた変数に代入しておくと、これは参照カウンタがインクリメントされない。</p>

<h3>Java 6 (Android ベースなので…)</h3>

<p>匿名クラスです。</p>

<p>```java Java
int x = 1;
final int y = 2;</p>

<p>ExecutorService executor = Executors.newSingleThreadExecutor();
executor.submit(new Runnable() {</p>

<pre><code>@Override
public void run() {
    y = 20; // できない(コンパイルエラー
    int z = x + y; // できない(コンパイルエラー

    String typeName = this.getClass().getInterfaces()[0].getName(); // Runnable になる
}
</code></pre>

<p>});
```</p>

<p>Java は匿名クラスの実装中に使える変数はかなり制限がある。
普通に宣言した変数は、匿名クラス内では使えない(コンパイルエラー)。
<code>final</code> を付けて宣言した変数は、匿名クラス内では参照のみ可能。ちょうど Objective-C の通常変数を Block 内で使った時と同じ。
Obj-C の <code>self</code> にあたる <code>this</code> は匿名クラス内では、その匿名クラスを示す。</p>

<h3>C＃</h3>

<p>ラムダ式です。</p>

<p>```csharp C#
int x = 1;
const int y = 2;
Task.Factory.StartNew(() =>
{</p>

<pre><code>x = 10; // OK
y = 20; // これはダメ、const だから。
var z = x + y;

var typeName = this.GetType().Name;
</code></pre>

<p>});
```</p>

<p>C# はかなりゆる〜い印象。
普通に宣言した変数を、ラムダ式の中でも自由に read/write できてしまう。write できちゃうのはこわい。
<code>this</code> は、ラムダ式の外側のクラスを示す。
　</p>

<h2>所感</h2>

<p>個人的には、Java のガチガチなのが好きかも。できる事が限定されているのでミスしにくい。
Objective-C は、ローカル変数は良いけど、self とか使っちゃうミス起こしそう。
C# は、普通に書き換えられて超不安、という感じ。なるべく const 使うようにしたい。
　
　
　</p>

<p>しかし記述量は C# が一番少ないですね、Xamarin いいよ Xamarin。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ViewController の ViewDidLoad で this が nil になった件]]></title>
    <link href="http://amay077.github.io/blog/2014/01/18/viewcontroller-is-nil-when-viewdidload/"/>
    <updated>2014-01-18T18:18:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/01/18/viewcontroller-is-nil-when-viewdidload</id>
    <content type="html"><![CDATA[<p>Xamarin Studio + Xcode で Storyboard でアプリを作っていた。複数ある画面の内、ある一つの画面に遷移すると落ちる現象に見舞われていろいろ調べていた。</p>

<!--more-->


<p>Xamarin Studio で該当画面の ViewController の ViewDidLoad にブレークポイントを仕掛けて停止させ、ウォッチしてみたところ、なんと this が「nil」になっていた。</p>

<p>これのおかげで、ViewController に配置した UILabel などにもアクセスできない。</p>

<p>ViewController を作りなおしてみたり、呼び出し方法を変えてみたりいろいろやってみたけど解消せず。</p>

<p>30分ほど悪戦苦闘した後、実機にインストールされている該当アプリを一旦削除し、Xamarin Studio も終了させた後に再起動、ソリューションをクリーンして再ビルドして実行してみたところ、問題が解消した。</p>

<p>なにがしかのトラブルが起きた時は、まずは端末内のアプリを消してみると良いのかも知れない。（これまでの経験的に）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Maps Component for iOS の CoordinateBounds について]]></title>
    <link href="http://amay077.github.io/blog/2014/01/16/notice-for-coordinatebounds-in-gmapiossdk/"/>
    <updated>2014-01-16T18:05:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/01/16/notice-for-coordinatebounds-in-gmapiossdk</id>
    <content type="html"><![CDATA[<p>すごくニッチな話ですけど、Xamarin Components にある Google Maps を Xamarin.iOS で使った。</p>

<!--more-->


<ul>
<li><a href="http://components.xamarin.com/view/googlemapsios">Google Maps /Components</a></li>
</ul>


<p>このライブラリの中に <code>CoordinateBounds</code> という「領域」を表すクラスがある。これは <a href="https://developers.google.com/maps/documentation/ios/reference/interface_g_m_s_coordinate_bounds?hl=ja">GMSCoordinateBounds</a> の Binding だ。</p>

<p>で、CoordinateBounds には <code>Including</code> (<a href="https://developers.google.com/maps/documentation/ios/reference/interface_g_m_s_coordinate_bounds?hl=ja#a63cffdf310ca19c6bab74c9a4034aadd">includingCoordinate</a>) というメソッドがあって、これを呼ぶと指定した座標が入るように領域を拡幅してくれる、便利だ。</p>

<p>で、最初はこのクラスをこう使っていた。</p>

<p><code>csharp
var bounds = new CoordinateBounds();
bounds.Including(new CLLocationCoordinate2D(34d, 134d));
bounds.Including(new CLLocationCoordinate2D(33d, 133d));
bounds.Including(new CLLocationCoordinate2D(35d, 135d));
</code></p>

<p>動かしてみて、この使い方だと <code>bounds</code> から期待した結果が得られないことに気づいた。範囲が -180〜+180 になってしまった。</p>

<p>正しくはこう。</p>

<p>```csharp
var bounds = new CoordinateBounds(</p>

<pre><code>new CLLocationCoordinate2D(34d, 134d),
new CLLocationCoordinate2D(33d, 133d));
</code></pre>

<p>bounds.Including(new CLLocationCoordinate2D(35d, 135d));
```</p>

<p>これだと結果は、正しく [33,133 - 35,135] を返す。</p>

<p>処理上、生成時に２つの座標が揃ってないケースだったので、「あ、デフォルトコンストラクタあるじゃん」と使ってたらハマった。本家 iOS 版の方には引数無しの initXXX は無かった。</p>

<p>Objective-C の仕様上 alloc して init しないのを防げない、んだっけ？
だから、Xamarin.iOS の Binding でデフォルトコンストラクタを隠せないのかな？
突っ込んで調べてないけど、Binding ライブラリを使う時は注意しましょう、ちゃんと本家のAPIリファレンスを見ましょう、というお話でした。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.iOS でエラー “Failed to load AOT module ... in aot-only mode”]]></title>
    <link href="http://amay077.github.io/blog/2014/01/16/failed-to-load-aot-module-in-aot-only-mode/"/>
    <updated>2014-01-16T15:14:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/01/16/failed-to-load-aot-module-in-aot-only-mode</id>
    <content type="html"><![CDATA[<p>Xamarin.iOS で Binding プロジェクトをプロジェクトに追加して実機で実行したら、起動時に落ちるようになってしまった。</p>

<!--more-->


<p>Xamarin.iOS で Binding プロジェクトをプロジェクトに追加して実機で実行したら、起動時に落ちるようになってしまった。</p>

<p>ログには、</p>

<blockquote><p>Failed to load AOT module ‘/xxx/Hoge.dll.dylib' in aot-only mode.</p></blockquote>

<p>というエラーが出ていた。</p>

<p>実機からアプリを削除して、
ソリューションを「再ビルド」したら直った。小ネタ過ぎる。</p>

<h2>参考</h2>

<ul>
<li><a href="http://monotouch.2284126.n4.nabble.com/Failed-to-load-AOT-module-in-aot-only-mode-td4602614.html">MonoTouch - Failed to load AOT module ... in aot-only mode</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
