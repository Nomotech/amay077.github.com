<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Xamarin | Experiments Never Fail]]></title>
  <link href="http://amay077.github.io/blog/categories/xamarin/atom.xml" rel="self"/>
  <link href="http://amay077.github.io/"/>
  <updated>2014-04-04T15:36:49+09:00</updated>
  <id>http://amay077.github.io/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Xamarin でビルドを自動化するには Business 版以上が必要です]]></title>
    <link href="http://amay077.github.io/blog/2014/04/04/command-line-building-requires-buisiness-license/"/>
    <updated>2014-04-04T15:31:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/04/04/command-line-building-requires-buisiness-license</id>
    <content type="html"><![CDATA[<p>Xamarin でも、リリース用アプリのビルド→署名→テストとか、自動化したいじゃないですか。</p>

<!--more-->


<p>Win/Visual Studio の場合は <code>msbuild</code>、Mac/Xamarin Studio の場合は <code>xbuild</code> でそれが可能との情報を得て試してみたところ、、、</p>

<p>```sh
$ xbuild HogeAppAndroid.csproj</p>

<p>XBuild Engine Version 3.2.6.0
Mono, Version 3.2.6.0
Copyright (C) Marek Sieradzki 2005-2008, Novell 2008-2011.</p>

<p>Build started 2014/04/04 13:13:59.</p>

<hr />

<p>Project "...HogeAppAndroid/HogeAppAndroid/HogeAppAndroid.csproj" (default target(s)):</p>

<pre><code>Target _SetLatestTargetFrameworkVersion:
</code></pre>

<p>: error XA9008: Building from the command-line requires a Business License.</p>

<pre><code>Task "ResolveSdks" execution -- FAILED
Done building target "_SetLatestTargetFrameworkVersion" in project "...HogeAppAndroid/HogeAppAndroid/HogeAppAndroid.csproj".-- FAILED
</code></pre>

<p>Done building project "...HogeAppAndroid/HogeAppAndroid/HogeAppAndroid.csproj".-- FAILED
```</p>

<p><strong>“Building from the command-line requires a Business License.”</strong></p>

<p>だそうです。</p>

<p>Starter Edition, Indie Edition では、コマンドラインからのビルドは許可されていないようです。</p>

<ul>
<li><a href="https://store.xamarin.com/">Store - Xamarin</a></li>
</ul>


<p>の比較表ではちょっと分からなかったな。。。</p>

<p>Win/Visual Studio な人は自動的に Business Edition 以上だから問題ないのですが、個人だから Business版買えないよ、Starter/Indie だけど (なんちゃって)CI とかやりたいよ、という人はあきらめるしかないみたいです。</p>

<p>…手動でやります。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.iOS で FromEventPattern を使うときの注意点]]></title>
    <link href="http://amay077.github.io/blog/2014/04/03/notice-for-fromeventpattern-in-xamarin-ios/"/>
    <updated>2014-04-03T15:29:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/04/03/notice-for-fromeventpattern-in-xamarin-ios</id>
    <content type="html"><![CDATA[<p>Reactive Extensions の <code>FromEventPattern</code> を使うと、イベントを <code>IObservable</code> に変換できて、複数のイベントに時系列な関係を与えたり、他のストリーム処理とシームレスに扱えたりします。</p>

<!--more-->


<ul>
<li><a href="http://www.atmarkit.co.jp/fdotnet/introrx/introrx_02/introrx_02_02.html">イベント・プログラミングとRx － ＠IT</a></li>
</ul>


<p>Xamarin .iOS でも .Android でもこの機能を使うことができて大変便利ですが、Xamarin.iOS の場合 AOT による制限に気をつける必要があります。</p>

<p>以下は、なんの変哲もない、「ボタンを押したらタイトルを ”Clicked!” に変える」コードです。</p>

<p><code>csharp
MyButton.TouchUpInside += (s, e) =&gt; MyButton.SetTitle("Clicked!", UIControlState.Normal);
</code></p>

<p>これを FromEventPattern を使うとこう書けます。</p>

<p><code>csharp DoesNotWorkOnDevice.cs
Observable.FromEventPattern(MyButton, "TouchUpInside")
.Subscribe(x =&gt; MyButton.SetTitle("Clicked!", UIControlState.Normal));
</code></p>

<p>このコード、iOSシミュレータでは正常に動作しますが、 <strong>実機では、ビルドは通りますが動作しません。</strong> 実行時にこんなエラーがでます。</p>

<blockquote><p>System.InvalidOperationException: Could not find event 'TouchUpInside' on object of type 'MonoTouch.UIKit.UIButton'.</p></blockquote>

<p><code>TouchUpInside</code> が無いと言われます。</p>

<p>これは AOT により生成されたコードに、このイベントが含まれないのだと推測します。イベント名を文字列リテラルで指定しているので、そこまでの解析は期待できないですよね。</p>

<p>シミュレータで動作したのは、この場合は AOT でなく JIT で動作しているため。以下でも言及されています。</p>

<ul>
<li><a href="http://www.buildinsider.net/mobile/insidexamarin/05">Xamarin.iOSの仕組みとアプリケーションの構成 - Build Insider</a></li>
</ul>


<blockquote><p>対象がiOSシミュレーターである場合と、iOSデバイスである場合とで、大きく異なる。iOSシミュレーターは、エミュレーターではなく、あくまでMac OS Xが動作しているx86 CPUの上で動作している仮想マシンであり、アプリケーションはJITによって動作する。iOSデバイスはARMであり、iOSデバイス用にビルドされたアプリケーションはAOTによってARMのCPU命令に変換されており、ARM上でしか動作しない。</p></blockquote>

<p>Xamarin.iOS では実機で動作させないと安心ならないと言われる所以です。</p>

<p>さて、このケースでは、FromEventPattern の別なオーバーロードを使うことで解決です。</p>

<p><code>csharp WorkOnDevice.cs
Observable.FromEventPattern(
  h =&gt; MyButton.TouchUpInside+=h,
  h =&gt; MyButton.TouchUpInside-=h)
.Subscribe(x =&gt; MyButton.SetTitle("Clicked!", UIControlState.Normal));
</code></p>

<p>Xamarin.iOS の制限事項は以下に。</p>

<ul>
<li><a href="http://docs.xamarin.com/guides/ios/advanced_topics/limitations/">Limitations | Xamarin</a></li>
</ul>


<p>これまでこの制限に引っかかった事がなかったのですが、初めて引っかかりました。</p>

<p>メソッドを文字列リテラルで書いた時点で私の負けです、本当にありがとうございました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.Android で Intent を受けとるには？]]></title>
    <link href="http://amay077.github.io/blog/2014/04/01/receive-intent-by-xamarin-android/"/>
    <updated>2014-04-01T15:26:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/04/01/receive-intent-by-xamarin-android</id>
    <content type="html"><![CDATA[<p>例えば、他のアプリからテキストを「送る」して、自作の Xamarin アプリでそれを受け取りたい時。</p>

<!--more-->


<p>普通の Android アプリ開発だと <code>AndroidManifest.xml</code> にこう書く。</p>

<p>```xml AndroidManifest.xml
<activity
  android:name="com.example.intenttest.MainActivity"
  android:label="@string/app_name" >
  <intent-filter></p>

<pre><code>&lt;action android:name="android.intent.action.MAIN" /&gt;
  &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
</code></pre>

<p>  </intent-filter></p>

<p>  <intent-filter></p>

<pre><code>&lt;action android:name="android.intent.action.SEND" /&gt;
&lt;category android:name="android.intent.category.DEFAULT" /&gt;
&lt;data android:mimeType="text/plain" /&gt;
</code></pre>

<p>  </intent-filter>
</activity>
```</p>

<p>Xamarin.Android では、Activity のソースファイルの属性として、以下のように書く。</p>

<p>```csharp MainActivity.cs
[Activity(Label = "MainActivity", MainLauncher = true)]
[IntentFilter (new []{ Intent.ActionSend },
  Categories = new []{ Intent.CategoryDefault },
  DataMimeType = "text/plain" )]
public class MainActivity : Activity
{</p>

<pre><code>protected override void OnCreate(Bundle bundle)
{
    base.OnCreate(bundle);
</code></pre>

<p>```</p>

<p>テキストでない場合は、mimetype を適宜変更する。省略したら動作しなかった。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS アプリでアラート出してボタンが押されるまで待つ？方法を Objective-C と Xamarin.iOS で比べてみた]]></title>
    <link href="http://amay077.github.io/blog/2014/03/10/using-uialertview-objc-vs-xamarin/"/>
    <updated>2014-03-10T22:09:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/03/10/using-uialertview-objc-vs-xamarin</id>
    <content type="html"><![CDATA[<p>なんか割とニーズがあるみたいで。</p>

<!--more-->


<ul>
<li><a href="http://teapipin.blog10.fc2.com/blog-entry-224.html">【Objective-C】アラート（UIAlertView）でボタンを押すまで次の処理を待つ方法 - creativi.tea</a></li>
<li><a href="http://cocoadays.blogspot.jp/2011/05/ios.html">Cocoaの日々: [iOS] 非同期処理を同期処理に変える</a></li>
<li><a href="http://qiita.com/edo_m18/items/cb1d9061d91e572b58eb">[Objective-C] UIAlertViewを同期処理する - Qiita </a></li>
</ul>


<h2>Objective-C の場合</h2>

<p><code>UIAlertView</code> は、結果を受け取るのが deletgate で、 Objective-C では、(Blocks を使わなければ) 受け取りが別メソッドになってしまう、しかも複数のアラートの結果が同じメソッドに飛んでくるので、tag値で分岐…とかいろいろで、ホントに使うのが面倒ですね。</p>

<p>さらに、「アラートの結果を受け取ってから、次の処理を行う」という処理を素直に記述したいと思うと、上で示したような「アラートを表示して、結果が得られるまで while で待つ」というなんとも不格好なコードになってしまいます。下にも書いてみました。（あ、メンバ変数も使わざるを得ないし。）</p>

<p>```objective-c HogeViewController.m
@implementation HogeViewController {</p>

<pre><code>NSInteger _buttonIndex;
</code></pre>

<p>}</p>

<ul>
<li>(IBAction)buttonTouchUp:(id)sender
{
  UIAlertView *alert = [[UIAlertView alloc] initWithTitle:nil

<pre><code>                          message:NSLocalizedString(@"なにか押して",@"")
                         delegate:self
                cancelButtonTitle:@"Cancel"
                otherButtonTitles:@"OK", nil];
</code></pre>

<p>  [alert show];</p>

<p>  // ボタンが押されるまで待つ
  <em>buttonIndex = -1;
  while (</em>buttonIndex == -1) {</p>

<pre><code>  [[NSRunLoop currentRunLoop]
   runUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.5f]]; // 0.5秒
</code></pre>

<p>  }</p>

<p>  label1.text = [NSString stringWithFormat:@"%d 番目のボタンを押したね", (int)_buttonIndex];
}</p></li>
</ul>


<p>-(void)alertView:(UIAlertView*)alertView clickedButtonAtIndex:(NSInteger)buttonIndex
{</p>

<pre><code>_buttonIndex = buttonIndex;
</code></pre>

<p>}
```</p>

<p><code>[NSRunLoop runUntilDate]</code> なんて VB6 の <code>DoEvents</code> ですもんねなつかしい。</p>

<h2>Xamarin.iOS(C#) の場合</h2>

<p>Objective-C ではややこしかった「アラートを出す→ボタンを押す→次の処理へ」という流れ、 Xamarin.iOS と C# ならこんなにシンプルに書けます。</p>

<p>```csharp HogeViewController.cs
async void OnButtonTouch(object sender, EventArgs e)
{</p>

<pre><code>var buttonIndex = await MsgBox("", "なにか押して", "Cancel", "OK");
label1.Text = buttonIndex.ToString() + "番目を押したね";  
</code></pre>

<p>}</p>

<p>static Task<int> MsgBox(string title, string message,</p>

<pre><code>string cancelButtonTitle, params string[] buttons)
</code></pre>

<p>{</p>

<pre><code>var comp = new TaskCompletionSource&lt;int&gt;();

var alert = new UIAlertView(title, message, null, cancelButtonTitle, buttons);
alert.Clicked += (_, e) =&gt; comp.TrySetResult(e.ButtonIndex);
alert.Show();

return comp.Task;
</code></pre>

<p>}
```</p>

<p>VB6 が懐かしくて <code>MsgBox</code> ってメソッドにしちゃいましたよ。</p>

<p><code>MsgBox</code> は、Task を返す <strong>非同期な</strong> メソッドです。この非同期処理が終了するのは、<code>TaskCompletionSource.TrySetResult</code> が呼び出された時、つまりアラートのボタンが押された時です。この非同期処理の戻り値はもちろん押したボタンのインデックスです。</p>

<p>非同期メソッドである <code>MsgBox</code> を呼び出す側には、キーワード <code>await</code> が付いています。
これをつけると、次行以降の処理は、非同期の MsgBox が完了した後、順次実行されます、つまり待っているわけではなく、どちらかというと、 <strong>処理を後続に付け足す</strong> 感じ。
さらに、この後続処理はUIスレッドで実行されるので、UIパーツへのアクセスも問題ありません。</p>

<p><code>async</code> はメソッド内で <code>await</code> を使うときにつけるお約束。</p>

<p>async/await は一見、ただの同期処理に見えるので理解して使う必要がありますが、Objective-C のコードに比べて、とても簡潔に、流れるように書くことができるのが分かると思います。</p>

<p><strong>C# の非常に強力な言語機能は、<a href="https://xamarin.com/">Xamarin</a> を選択する大きな理由の一つです。</strong></p>

<h2>参考</h2>

<ul>
<li><a href="http://stackoverflow.com/questions/4613071/messagebox-show-and-dialogresult-equivalent-in-monotouch">c# - Messagebox.Show and DialogResult equivalent in MonoTouch - Stack Overflow</a></li>
<li><a href="http://ufcpp.wordpress.com/2012/11/12/asyncawait%e3%81%a8%e5%90%8c%e6%99%82%e5%ae%9f%e8%a1%8c%e5%88%b6%e5%be%a1/">async/awaitと同時実行制御 | ++C++; // 未確認飛行 C ブログ</a></li>
<li><a href="http://www.slideshare.net/bleistift/asyncawait2">async/await不要論</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin によるクロスプラットフォームモバイルアプリ開発、資料と補足]]></title>
    <link href="http://amay077.github.io/blog/2014/02/27/slides-from-my-xamarin-introduction/"/>
    <updated>2014-02-27T21:40:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/02/27/slides-from-my-xamarin-introduction</id>
    <content type="html"><![CDATA[<p>2/26 の <a href="http://atnd.org/events/47898">うずらインキュベータ</a> という勉強会で、Xamarin の話をしました。</p>

<!--more-->




<iframe src="http://www.slideshare.net/slideshow/embed_code/31674661" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px 1px 0; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>


<p> <div style="margin-bottom:5px"> <strong> <a href="https://www.slideshare.net/amay077/xamarin-31674661" title="Xamarin によるクロスプラットフォームモバイルアプリ開発" target="_blank">Xamarin によるクロスプラットフォームモバイルアプリ開発</a> </strong> from <strong><a href="http://www.slideshare.net/amay077" target="_blank">amay 077</a></strong> </div></p>

<p>45分という長い時間話すのは勉強会では初めてだったのですが、なんとか説明し切ることができました。（ちょっとデモが中途半端になってしまいましたが）</p>

<p>資料は <a href="http://qiita.com/tags/xamarin">Qiita に書いてきた</a> 内容のまとめみたいなものですが、少し補足します。</p>

<h2>Xamarin で作った経験あるの？</h2>

<p>仕事では、まだ無いです（<sup>_<sup>;）</sup></sup>
個人アプリでは「<a href="https://itunes.apple.com/us/app/fu-shifoto/id806913229">富士フォト</a>」というのを iOS 用は Xamarin.iOS で作りました。<a href="https://play.google.com/store/apps/details?id=com.amay077.android.fujiphoto">Android</a> は Java ですが Xamarin 化したいな。</p>

<h2>Win+Visual Studio ではダメなの？</h2>

<p>個人の見解ですから（<sup>_<sup>;）</sup></sup>
私も元々は Windowsの開発がメインで Visual Studio の強力さは知っていますが、iOS やるならどういう形にせよ Mac+Xcode を扱わないといけないので、慣れておいた方がよいかなと。</p>

<p>また、Microsoft との提携以降、Microsoft のエバンジェリストさんや MVP の方々が Visual Studio + Xamarin の話をものすごく展開されているので、そちらにお任せした次第です。</p>

<h2>実行モデルのとこ</h2>

<p>JavaSE が .NET に置き換わる図になっていますが、実際には少し違っていて、JavaSE のラッパもあります。例えば文字列型には、<code>System.String</code> と <code>Java.Lang.String</code> があります。当然、理由がなければ前者を使った方がよいわけですが。</p>

<p>iOS のスタックに関しては、実はどこからどこまでが「CocoaTouch」なのかよく分かってません。</p>

<h2>他のクロスプラットフォーム開発ツールとの比較</h2>

<p>Titanium, AIR については2年くらい前に少し触ったことがあります。PhoneGap と DelphiXE についてはスペックを見て＆詳しい方からの情報を元にしてます。</p>

<p>Titanium は次期 <a href="http://titanium-mobile.jp/38">Ti.Next</a> では JavaScriptCore を使ってすんごく速くなるそうですし、AIR も当時よりだいぶ <a href="http://www.slideshare.net/pik256/dev-sumi2014-13c4rev">高速になったらしい</a> です。</p>

<h2>C# のとこ</h2>

<p>https://xamarin.com/csharp よりは悪意のないコードかとｗ
（Objective-C と比較しようとすると Obj-C の方が画面に入らないので Java との比較にしました。）</p>

<p>こんなところで。
何かおかしなところがあったらコメント頂けるとありがたいです。</p>
]]></content>
  </entry>
  
</feed>
