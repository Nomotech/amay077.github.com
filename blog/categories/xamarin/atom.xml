<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Xamarin | Experiments Never Fail]]></title>
  <link href="http://amay077.github.io/blog/categories/xamarin/atom.xml" rel="self"/>
  <link href="http://amay077.github.io/"/>
  <updated>2013-12-18T20:28:29+09:00</updated>
  <id>http://amay077.github.io/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Xamarin.iOS と Rx で iBeacon を使ってみる(つもり)]]></title>
    <link href="http://amay077.github.io/blog/2013/12/11/using-ibeacon-with-xamarin/"/>
    <updated>2013-12-11T00:12:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/12/11/using-ibeacon-with-xamarin</id>
    <content type="html"><![CDATA[<p>こちらは、<a href="http://qiita.com/advent-calendar/2013/ibeacon">iBeacon Advent Calendar 2013</a> と <a href="http://qiita.com/advent-calendar/2013/xamarin">Xamarin Advent Calendar 2013</a> とのクロスポストになります。</p>

<!--more-->


<p>Xamarin とは、.NET で iOS/Android アプリを開発できるプラットフォームです。詳しくは <a href="http://qiita.com/amay077/items/38ee79b3e3e88cf751b9">こちら</a> をどうぞ。</p>

<p>Xamarin.iOS は、 iOS の APIセットが全て C# で使えますので、 iBeacon 関連の API もそのまま使えます。さらに C# や .NET の強力な言語仕様により、より簡潔に、美しく書くことができます。</p>

<h2>Xamarin.iOS で iBeacon を使うサンプル</h2>

<p>Xamarin で iBeacons を使うサンプルは、Xamarin 自体が既に公開されています。</p>

<ul>
<li><a href="http://blog.xamarin.com/play-find-the-monkey-with-ios-7-ibeacons/">Play ‘Find The Monkey’ with iOS 7 iBeacons | Xamarin Blog</a></li>
<li><a href="https://github.com/mikebluestein/FindTheMonkey">mikebluestein/FindTheMonkey</a></li>
</ul>


<p>これらは iOS7 のリリースから僅か7日後のできごとであり、Xamarin の新OSへの対応力に驚いたものでした。</p>

<p>この紹介だけで終わってもアレなので、このサンプルをより「C# っぽく」修正してみたいと思います。</p>

<h2>サンプルをより「C# っぽく」する</h2>

<p>対象にするのは iBeacon の受信の方です。</p>

<ul>
<li><a href="http://reinforce-lab.github.com/blog/2013/10/21/ibeacon/">iBeaconの解説 - Reinforce-Lab.'s Blog</a></li>
<li><a href="http://brightechno.com/blog/archives/220">iBeacon Tips: 正しいビーコン監視方法 | ブライテクノBlog</a></li>
</ul>


<p>などで勉強したところ、受信の流れは下図のようになるかと思います。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/using_ibeacon_with_xamarin_01.png" alt="img" /></p>

<p>全てのメソッドが非同期でコールバックを受け取るタイプ、また並行処理＆同期とか、なんだか見やすいコードになる気がしません。</p>

<p>C# といえば LINQ、そして LINQ を更に拡張する Rx(Reactive Extensions) を使って、この流れをもう少しスッキリと書いてみます。
Rx は、非同期処理やイベントコールバックを一直線なストリームに変換します。また、ストリームの分配や結合の機能を提供します。最初は JavaScript の <a href="http://techblog.yahoo.co.jp/programming/jquery-deferred/">Deferred</a> みたいなもんだと思ってました。が、使ってく内にとんでもなく高機能なものだと分かり(はじめ)ました。</p>

<p>これを使うと、上の図をそのままコードに落としたような、上から下へ辿れる感じで書くことができます。</p>

<p>まず、修正前のサンプルコードはこちら</p>

<ul>
<li><a href="https://github.com/mikebluestein/FindTheMonkey/blob/master/FindTheMonkey/FindTheMonkeyViewController.cs">FindTheMonkey / FindTheMonkeyViewController.cs</a></li>
</ul>


<p>このコード自体、上の流れに沿ってない気もしますが、まあいいや。</p>

<p>これを Rx で書きなおすと、こうなります。</p>

<p>```csharp FindTheMonkeyViewController_after.cs
public override void ViewDidLoad()
{</p>

<pre><code>base.ViewDidLoad();

/* 省略 */

var monkeyUUID = new NSUuid(uuid);
var beaconRegion = new CLBeaconRegion(monkeyUUID, monkeyId);

beaconRegion.NotifyEntryStateOnDisplay = true;
beaconRegion.NotifyOnEntry = true;
beaconRegion.NotifyOnExit = true;

if (!UserInterfaceIdiomIsPhone)
{
/* 省略 */
} else
{

    InitPitchAndVolume();

    locationMgr = new CLLocationManager();

    // ここがキモ
    locationMgr.StartMonitoringAsObservable(beaconRegion) // リージョン監視〜開始通知受信
        .Publish(_ =&gt; // ストリームを A と B に分配
            locationMgr.ReceiveRegionEnteredAsObservable() // A:進入の受信
            .Amb(locationMgr.GetStateForRegionAsObservable(beaconRegion))) // B:リージョン状態要求〜受信
        .SelectMany(_ =&gt; // .Amb で A B どちらか先に来た方を使用
            locationMgr.StartRangingBeaconsAsObservable(beaconRegion)) // レンジング開始〜ビーコン信号受信
        .Subscribe(beacons =&gt; 
        {
            // Beacon が見つかった時に行う処理を書く
        });
}
</code></pre>

<p>}
```</p>

<p>```csharp CLLocationManagerExtensions.cs
public static class CLLocationManagerExtensions
{</p>

<pre><code>// リージョン監視を開始して、開始通知を IObservable で得る拡張メソッド
public static IObservable&lt;CLRegionEventArgs&gt; StartMonitoringAsObservable(
    this CLLocationManager man, CLBeaconRegion beaconRegion)
{
    return Observable.Defer(() =&gt;
    {
        man.StartMonitoring(beaconRegion);
        return Observable.FromEventPattern&lt;CLRegionEventArgs&gt;(man, 
            "DidStartMonitoringForRegion")
                    .FirstAsync()
                    .Select(e =&gt; e.EventArgs);
    });
}

// リージョンへの進入を IObservable で得る拡張メソッド
public static IObservable&lt;CLRegion&gt; ReceiveRegionEnteredAsObservable(
    this CLLocationManager man)
{
    return Observable.FromEventPattern&lt;CLRegionEventArgs&gt;(man, 
        "RegionEntered")
            .FirstAsync()
            .Select(e =&gt; e.EventArgs.Region);
}

// リージョンの状態を要求して、結果を IObservable で得る拡張メソッド
public static IObservable&lt;CLRegion&gt; GetStateForRegionAsObservable(
    this CLLocationManager man, CLBeaconRegion beaconRegion)
{
    return Observable.Defer(() =&gt;
    {
        man.RequestState(beaconRegion);
        return Observable.FromEventPattern&lt;CLRegionStateDeterminedEventArgs&gt;(man, 
            "DidDetermineState")
                    .FirstAsync()
                    .Where(e =&gt; e.EventArgs.State == CLRegionState.Inside)
                    .Select(e =&gt; e.EventArgs.Region);
    });
}

// レンジングを開始してビーコン信号を IObservable で得る拡張メソッド
public static IObservable&lt;IEnumerable&lt;CLBeacon&gt;&gt; StartRangingBeaconsAsObservable(
    this CLLocationManager man, CLBeaconRegion beaconRegion)
{
    return Observable.Defer(() =&gt;
        {
            man.StartRangingBeacons(beaconRegion);
            return Observable.FromEventPattern&lt;CLRegionBeaconsRangedEventArgs&gt;(man, 
                "DidRangeBeacons")
                    .Select(e =&gt; e.EventArgs.Beacons);
        });
}
</code></pre>

<p>}
```</p>

<p><code>locationMgr.StartMonitoringAsObservable</code> で始まるところがキモですね。各々の機能は <code>CLLocationManagerExtensions.cs</code> の拡張メソッドで逃してます。これも C# の利点(たしか Objective-C にもあったっけ)。</p>

<p>リージョン監視の開始通知を受け取ったら <code>Publish</code> で分配。</p>

<p>ひとつは進入を検知したら値を流す(A)、もうひとつは開始位置のリージョン状態を得て、それがリージョン内だったら値を流す(B)。これらは <code>.Amb</code> で合流。 <code>.Amb</code> は右辺と左辺のどちらか先に返された最初の結果を後続に流すというものです。つまり、B がリージョン外だったら自動的に A の <code>didEnterRegion</code> を待つことになります。</p>

<p>最後に、レンジングを開始して受信する度に結果(ビーコン信号)を流します。
Rx は基本的に、複数の結果を逐一返すものですが、<code>StartRangingBeaconsAsObservable</code> 以外は、拡張メソッドで <code>.FirstAsync</code> としていて、つまり「最初の一つ」だけを後続に流すようにしています。</p>

<p>んで、これを購読(<code>.Subscribe</code>)することで処理を開始して、結果を <code>// Beacon が見つかった時に行う処理を書く</code> のところで受け取る仕組みです。</p>

<p>このように Rx を使うことで、非同期のコールバックを含む処理を直列に書け、処理の並列化や合成も簡単に行えます。</p>

<p>Objective-C でも <a href="http://qiita.com/somtd@github/items/8409ddd6d0927c04c1dd">ReactiveCocoa</a> とか使うとできるのかな？(でもやっぱり構文が…)</p>

<p>そんなわけで、少しでも Xamarin に興味持っていただけたら幸いです。(これが言いたかった)</p>

<h3>P.S.</h3>

<p>実はこのコード、まだ…実機で動かしてないんです。iOS Dev Program の契約が切れたまま放置してて、3日くらい前に再登録して支払い済みなんですが、まだ pending 状態で…。登録が完了したらちゃんと実機で動かすつもりですが…動かなかったらごめんなさいして直します。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.iOS + iOS Simulator で Instruments を使う]]></title>
    <link href="http://amay077.github.io/blog/2013/09/03/using-instruments-with-xamarin-ios/"/>
    <updated>2013-09-03T21:29:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/09/03/using-instruments-with-xamarin-ios</id>
    <content type="html"><![CDATA[<p>Xamarin.iOS(旧MonoTouch)では、Xcode のプロファイラである Instruments がそのまま使えます。</p>

<!--more-->


<h2>デモプロジェクト</h2>

<ul>
<li><a href="http://docs.xamarin.com/guides/ios/deployment%2C_testing%2C_and_metrics/instruments_walkthrough">Instruments Walkthrough | xamarin</a></li>
</ul>


<p>にある <code>MemoryDemo.zip</code> をダウンロード、解凍します。2つプロジェクトが含まれていますが、 <code>before</code> を使います。</p>

<h2>手順</h2>

<h3>1. プロジェクトをとりあえず実行</h3>

<p>Xamarin Studio で <code>before/MemoryDemo.sln</code> を開いて、とりあえずビルド、Simulator で実行します。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/using_instruments_with_xamarin_ios_01.png" alt="img" /></p>

<p>上下にスクロールすると、次々と画像を読み込むので Allocate がハンパないよ、ってデモのようです。</p>

<h3>2. Xamarin Studio から Instruments を起動する。</h3>

<p>メニュー - ツール - Launch Instruments で起動します。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/using_instruments_with_xamarin_ios_02.png" alt="img" /></p>

<p>起動はしましたが、勝手にアプリが実行されるわけではありません。ここから少しだけ面倒な手続きが必要です。</p>

<h3>3. iOS Simulator にインストールしたアプリを指定して Instruments を実行する</h3>

<p>Instruments を起動すると、下のような画面になっています。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/using_instruments_with_xamarin_ios_03.png" alt="img" /></p>

<p>左メニューから [iOS Simulator] - [Memory]、右から [Allocations] を選び [Choose] ボタンを押します。</p>

<p>次に、[Target] をクリックして、[Choose Target] - [Choose Target…] と進みます。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/using_instruments_with_xamarin_ios_04.png" alt="img" /></p>

<p>下のような画面になります。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/using_instruments_with_xamarin_ios_05.png" alt="img" /></p>

<p>次に Finder を起動して、iOS Simulator のディレクトリへ移動します。</p>

<p>iOS Simulator のディレクトリは通常、<code>~/Library/Application Support/iPhone Simulator/</code> です。さらにアプリ毎に GUID で分けられているので目的のアプリを探してください。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/using_instruments_with_xamarin_ios_06.png" alt="img" /></p>

<p>アプリのディレクトリを開いたら、その中のアプリケーションファイル(ここでは <code>MemoryDemo</code>) を、先ほど開いておいた Instruments の中へドラッグ＆ドロップします。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/using_instruments_with_xamarin_ios_07.png" alt="img" /></p>

<p>そして [Choose] を押すと、Target が MemoryTest になっているのが分かります。</p>

<p>これでようやく実行できます。赤い●を押します。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/using_instruments_with_xamarin_ios_08.png" alt="img" /></p>

<p>と、iOS Simulator で MemoryTest が実行され、Instruments でプロファイルしている事が確認できます。Simulator でグリグリスクロールすると、Allocations がガンガン増えてく様子が分かります。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/using_instruments_with_xamarin_ios_09.png" alt="img" /></p>

<h3>3. 2度目以降は？</h3>

<p>Instruments でもう一度赤い●を押すと停止します。アプリを更新する時は、Xamarin Studio 側でビルド-実行して iOS Simulator のアプリファイルを更新してから、Instruments で再度、赤い●を押します。</p>

<p>もし Instruments を終了してしまっても、最近使ったアプリは Choose Target に最近使ったアプリとして残るので、またドラッグ＆ドロップすることはありません。</p>

<h2>まとめと参考</h2>

<p>Xamarin.iOS+iOS Simulator での Instruments の導入部分を説明しました。</p>

<p>下に紹介するサイトが公式の情報です。
ここには、実機にインストールしたアプリのプロファイル方法や、Instruments の使い方などが説明されているので合わせてどうぞ。</p>

<ul>
<li><a href="http://docs.xamarin.com/guides/ios/deployment%2C_testing%2C_and_metrics/using_instruments_to_detect_native_leaks_using_markheap">Profiling Xamarin.iOS Applications with Instruments | xamarin</a></li>
<li><a href="http://docs.xamarin.com/guides/ios/deployment%2C_testing%2C_and_metrics/instruments_walkthrough">Instruments Walkthrough | xamarin</a></li>
<li><a href="https://developer.apple.com/library/ios/recipes/instruments_help-launch-into-simulator-help/LaunchIntoSimulator.html">iOS Simulator Help: Setting Instruments to Launch an iOS App in Simulator</a></li>
</ul>


<p>※ <a href="http://docs.xamarin.com/guides/ios/deployment%2C_testing%2C_and_metrics/instruments_walkthrough">Instruments Walkthrough</a> の No.14 の <a href="http://docs.xamarin.com/static/guides/ios/deployment,_testing,_and_metrics/instruments_walkthrough/Images/05_related_code.png">この画像</a> には、Instruments に Xamarin.iOS(C#) のソースコードが表示されているように見えるんだけど、これどうやるのかなあ。。手順通り動かしたつもりが出てこない。。。SourceMap の設定みたいなのが要るのかなあ。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.Android での Google Map(というか Play Service) 利用が、本家より簡単になった件]]></title>
    <link href="http://amay077.github.io/blog/2013/08/03/gmapv2-from-xamarin-component/"/>
    <updated>2013-08-03T15:29:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/08/03/gmapv2-from-xamarin-component</id>
    <content type="html"><![CDATA[<p>Xamarin Components に「Google Play Services」が追加されまして。</p>

<!--more-->


<ul>
<li><a href="http://blog.xamarin.com/introducing-the-google-play-services-component-for-xamarin-android/">Introducing the Google Play Services Component for Xamarin.Android | Xamarin Blog</a></li>
</ul>


<p>これが何を意味するかと言うと、これまで Google Play Service を利用するには、ライブラリプロジェクトを作って、アプリから参照するという煩わしい手順が必要でした。</p>

<p>で、これは Android-Eclipse でも同じく面倒だったわけですが、Xamarin.Android  に新しく提供されるこのコンポーネントを使えば、その手間を省くことができます。この点で Eclipse での開発より簡単になりました。</p>

<p>実際に、Play Services の一つである Google Map Android API v2 を使うアプリを作る手順を書いてみます。</p>

<h2>手順</h2>

<h3>1. Google API Console から API key を取得する</h3>

<p>この手順は、これまでと変わらないので、以下のサイトなどを参考にしてください。
package名が必要になるので、先に決めておきましょう。
ここでは <code>com.amay077.sample.googlemapv2sample</code> とします。</p>

<ul>
<li><a href="http://www.adamrocker.com/blog/334/google-maps-android-api-v2.html">throw Life - Google Maps Android API v2を使ってみた</a></li>
</ul>


<p>取得して API key はメモっておきます。</p>

<h3>2. プロジェクト/ソリューションを作る</h3>

<p>Xamarin Studio を起動します。
ここでは Ice Cream Sandwich 用に作ります。(Android Application の方だと Support Library が要るので少し手順が増えるはず)</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/gmapv2_from_xamarin_component_01.png" alt="img" /></p>

<h3>3. プロジェクトに「Google Play Service」コンポーネントを追加する</h3>

<p>メニュー → プロジェクト → Get More Components から、、、</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/gmapv2_from_xamarin_component_03.png" alt="img" /></p>

<p>Google Play Services を検索して Add to App します。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/gmapv2_from_xamarin_component_04.png" alt="img" /></p>

<p>すると、プロジェクトに Google Play Services が追加されます。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/gmapv2_from_xamarin_component_05.png" alt="img" /></p>

<p>ここで一度、Xamarin Studio を再起動しておいた方が無難です。
このまま継続したら、追加されたアセンブリがうまく読み込まれてない場合がありました。</p>

<h3>4. 実装する</h3>

<p><code>MainActivity.cs</code> は、最初の内容をごっそり削除して以下のようにします。</p>

<p>```c# MainActivity.cs
using Android.App;
using Android.OS;</p>

<p>namespace GoogleMapV2Sample
{</p>

<pre><code>[Activity (Label = "GoogleMapV2Sample", MainLauncher = true)]
public class MainActivity : Activity
{
    protected override void OnCreate(Bundle bundle)
    {
        base.OnCreate(bundle);

        // Set our view from the "main" layout resource
        SetContentView(Resource.Layout.Main);
    }
}
</code></pre>

<p>}
```</p>

<p>画面定義である <code>Main.axml</code> も以下のように置き換えます。</p>

<p>```xml Resources/layout/Main.axml
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;fragment xmlns:android="http://schemas.android.com/apk/res/android"</p>

<pre><code>android:id="@+id/map"
android:layout_width="match_parent"
android:layout_height="match_parent"
class="com.google.android.gms.maps.MapFragment" /&gt;
</code></pre>

<p>```</p>

<h3>5. AndroidManifest.xml への設定いろいろ</h3>

<p>たぶん一番面倒なところです。</p>

<p>まず Xamarin.Android では、最初は AndroidManifest.xml が生成されていないので、メニュー → プロジェクト → xxx のオプション から、下図のように [Add Android manifest] します。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/gmapv2_from_xamarin_component_06.png" alt="img" /></p>

<p>次に作成された AndroidManifest.xml を開いて、以下のようにします。</p>

<p>※1 のところは、最初に決めた Package名に、※2 の時は、先に取得しておいた API key に置き換えてください。</p>

<p>```xml Properties/AndroidManifest.xml
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"</p>

<pre><code>android:versionCode="1" 
android:versionName="1.0" 
package="com.amay077.sample.googlemapv2sample"&gt;  &lt;--------※1


&lt;uses-feature android:glEsVersion="0x00020000" android:required="true" /&gt;
&lt;uses-permission android:name="android.permission.INTERNET" /&gt;
&lt;uses-permission android:name="com.google.android.providers.gsf.permission.READ_GSERVICES" /&gt;
&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;


&lt;uses-permission 
    android:name="com.amay077.sample.playservicesample.permission.MAPS_RECEIVE" /&gt;   &lt;--------※1
&lt;permission 
    android:name="com.amay077.sample.playservicesample.permission.MAPS_RECEIVE"   &lt;--------※1
    android:protectionLevel="signature" /&gt;

&lt;application android:label="GoogleMapV2Sample"&gt;
    &lt;meta-data 
        android:name="com.google.android.maps.v2.API_KEY" 
        android:value="AIzaByD1jiFER3le_HFrkOrEhaNIsemoNoDesuU" /&gt;  &lt;--------※2
&lt;/application&gt;
</code></pre>

<p></manifest>
```</p>

<h3>6. 動かす</h3>

<p>設定が正しくできていれば、地図が表示されるはずです。
アプリが落ちるなら Main.cs や Main.axml が、地図が表示されないなら AndroidManifest.xml や Google API Console での設定が間違っていると思います。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/gmapv2_from_xamarin_component_07.png" alt="img" /></p>

<h2>まとめなど</h2>

<p>Google Play Service コンポーネントを使うことでライブラリプロジェクトをなくす事ができました。慣れた人にはどうってこと無い話ですが、説明する人には面倒で、始めて行う人には混乱の元になってたと思います。</p>

<p>もう一つ特筆すべきは、このコンポーネントを Google 自身が開発、提供していることです。</p>

<p>これだけでなく、<a href="http://components.xamarin.com/view/googlemapsios/">Google Map SDK for iOS</a> や <a href="http://components.xamarin.com/view/googleadmob/">Admob 用のコンポーネント</a>も Google 自身が提供しています。</p>

<p>また Microsoft も <a href="http://components.xamarin.com/view/azure-mobile-services/">Azure Mobile Service</a> を自身が提供していますし、なんなんでしょうこのプラットフォーマーの Xamarin への参入ぶりは。</p>

<p>このように本家が開発していることにより、信頼性、機能網羅性、新機能への追従などがとても充実しており、安心して使うことができます。</p>

<p>最後に、</p>

<blockquote class="twitter-tweet"><p>おおおお、すげえ！これでめんどいビルド手順必要なくなった！Google++！でも、Gmaps iOSの1.4アップデートと、Retina対応のため128dpタイルへの対応もしてください…。 / “Google Play Servi…” <a href="http://t.co/mjnN7sE0t7">http://t.co/mjnN7sE0t7</a></p>&mdash; Кочизуфан (@kochizufan) <a href="https://twitter.com/kochizufan/statuses/363116371351052290">August 2, 2013</a></blockquote>


<script async src="http://amay077.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>とのことなのでよろしくおねがいします。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin Studio で複数のソリューションを開く方法]]></title>
    <link href="http://amay077.github.io/blog/2013/07/28/open-multi-solution-in-xamarin-studio/"/>
    <updated>2013-07-28T13:52:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/07/28/open-multi-solution-in-xamarin-studio</id>
    <content type="html"><![CDATA[<p>わかりにくいのでメモっておく。</p>

<!--more-->


<h3>1. ソリューションをひとつ開く</h3>

<h3>2. ２つ目のソリューションを開く</h3>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/open_multi_solution_in_xamarin_studio_01.png" alt="img1" /> この時、「現在のワークスペースを閉じる」のチェックを <strong>外す</strong></p>

<h3>3. すると２つ目のソリューションが追加されてます。</h3>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/open_multi_solution_in_xamarin_studio_02.png" alt="img1" /></p>

<p>ソリューションを新規作成する時には行えないようです。
分かりにくいよママン。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pull up to Close を実装してみる、Xamarin.iOS で]]></title>
    <link href="http://amay077.github.io/blog/2013/07/28/implementing-pull-up-to-close-using-xamarin-ios/"/>
    <updated>2013-07-28T13:51:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/07/28/implementing-pull-up-to-close-using-xamarin-ios</id>
    <content type="html"><![CDATA[<p>イマドキのスマホアプリでは Pull to Refresh（引っ張って更新）を実装してるアプリをよく目にするのですが、RSS Reader の Feedly では Pull up to Close（上に引っぱって閉じる）も採用しています。</p>

<p>この操作性がなかなか使いやすかったので、自分でも実装してみました。</p>

<!--more-->


<h2>デモ</h2>

<p>こんな感じ。
WebView なんですが、一番下までスクロールして、さらに上に引っ張ると "Pull up to Close" → "Release to Close" とラベルが変わり、そこで離すとコールバックします。</p>

<iframe width="640" height="360" src="http://www.youtube.com/embed/AP6xPqwwXMI?feature=player_detailpage" frameborder="0" allowfullscreen></iframe>


<h2>実装してみたコード</h2>

<p><a href="http://xamarin.com/">Xamarin.iOS</a> ですから、C# です。</p>

<p>UIWebView でやってますが、ScrollView なコントロールならだいたい同じ感じでいけるんじゃないかと思います。</p>

<p>```c# PullUpToCloseSampleViewController.cs
public partial class PullUpToCloseSampleViewController : UIViewController
{</p>

<pre><code>public PullUpToCloseSampleViewController() : base ("PullUpToCloseSampleViewController", null)
{
}

public override void ViewDidLoad()
{
    base.ViewDidLoad();

    // WebView が持ってる ScrollView、よく使うので変数化しておく
    // webView は Interface Builder で UIWebView を Outlet にしたもの。
    var scrollView = webView.ScrollView;

    // Bounces の影を消す via http://stackoverflow.com/questions/8480571/removing-shadows-from-uiwebview
    scrollView.Subviews.Where(v =&gt; v is UIImageView)
        .ToList().ForEach(v =&gt; v.Hidden = true);

    // 上に引っ張った時に見える背景とラベル
    var bounceBackground = new UIView(
        new RectangleF(0f, 0f, webView.Frame.Width, webView.Frame.Height));
    bounceBackground.BackgroundColor = UIColor.LightGray;
    var bounceLabel = new UILabel(
        new RectangleF(0f, webView.Frame.Height - 30f, webView.Frame.Width, 30f));
    bounceLabel.Text = "Pull up to Close";
    bounceLabel.TextAlignment = UITextAlignment.Center;
    bounceLabel.BackgroundColor = UIColor.Clear;
    bounceLabel.Opaque = false;

    // 背景とラベルを WebView の一番奥に追加する
    webView.InsertSubview(bounceLabel, 0);
    webView.InsertSubview(bounceBackground, 0);

    // 適当な URL を読み込み
    webView.LoadRequest(NSUrlRequest.FromUrl(new NSUrl("http://yahoo.co.jp/")));

    // 閉じるのに必要な分だけ上に引っ張ったら true になる
    var canClose = false;

    // ドラッグ開始時にフラグOFF(一応)
    scrollView.DraggingStarted += (sender, e) =&gt; 
    {
        canClose = false;
    };

    // ドラッグ終了時、必要量引っ張っていたら OnCloseByPullUp を呼ぶ
    scrollView.DraggingEnded += (sender, e) =&gt; 
    {
        if (canClose)
        {
            OnCloseByPullUp();
        }
    };

    // スクロールした時にいろいろやる
    scrollView.Scrolled += (sender, e) =&gt; 
    {
        var labelFrame = bounceLabel.Frame;

        // コンテンツの一番下まで表示してさらに引っ張ったサイズ
        var offsetY = (scrollView.Frame.Height + scrollView.ContentOffset.Y) 
            - scrollView.ContentSize.Height;

        // 50px 上に引っ張ったら閉じるものとする
        canClose = offsetY &gt; 50f;
        bounceLabel.Text = canClose ? "Release to Close" : "Pull up to Close";

        // ラベルがいつまでも移動しないように
        if (offsetY &gt; labelFrame.Height)
        {
            offsetY = labelFrame.Height;
        }

        // ラベルがドラッグと共に下からせり出してくるように
        labelFrame.Y = scrollView.Frame.Height - offsetY;
        bounceLabel.Frame = labelFrame;
    };
}

// "Release to Close" で離すと呼ばれる
void OnCloseByPullUp()
{
    var v = new UIAlertView("", "Close this view",  null, "Close");
    v.Show ();
}
</code></pre>

<p>}
```</p>

<h2>やってる事</h2>

<ol>
<li>ScrollView の「引っ張った時に見える場所（= Bounce というらしい）」の影を消す。 via http://stackoverflow.com/questions/8480571/removing-shadows-from-uiwebview</li>
<li>背景と、ラベルを WebView 内の一番奥に挿入する（引っ張った時にのみ見えるように）</li>
<li>あとはイベントハンドラでの処理。スクロール中に、「最下部で引っ張り中」だったら "Pull up to Close" ラベルをアニメーションさせながら表示する。50px 以上引っ張ってたら "Release to Close" にラベルを変える。「閉じられるよ」フラグも ON にしとく。</li>
<li>ドラッグ終了イベントで、「閉じられるよ」フラグが立ってたら、コールバックする。</li>
</ol>


<h2>今後</h2>

<p>もうちょっとライブラリっぽくしたいですね。あと引っ張り中にアイコンとか表示させたい。</p>
]]></content>
  </entry>
  
</feed>
