<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: reactive4java | Experiments Never Fail]]></title>
  <link href="http://amay077.github.io/blog/categories/reactive4java/atom.xml" rel="self"/>
  <link href="http://amay077.github.io/"/>
  <updated>2013-10-05T23:46:58+09:00</updated>
  <id>http://amay077.github.io/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Cold を Hot にできる。そう、Publish ならね。]]></title>
    <link href="http://amay077.github.io/blog/2012/10/03/rx-cold-to-hot/"/>
    <updated>2012-10-03T19:13:00+09:00</updated>
    <id>http://amay077.github.io/blog/2012/10/03/rx-cold-to-hot</id>
    <content type="html"><![CDATA[<p>Rx いいよ Rx とか言っておきながら、いままで Cold と Hot の違いについて、ちゃんとわかってませんでしたスイマセン。</p>

<!--more-->


<p>そのため、</p>

<ul>
<li><a href="http://qiita.com/items/07762776102dbc84b1c7">reactive4java で端末の方位を取得しつづける - Qiita</a></li>
<li><a href="http://qiita.com/items/e15ba88d51938531b1a3">reactive4java で位置を取得し続ける - Qiita</a></li>
</ul>


<p>で作ったサンプルプログラム、盛大にバグってましたorz</p>

<h2>Cold な Observable と Hot な Observable</h2>

<p>音楽プレーヤ iPod に例えると自分なりにしっくり来ました。
Observable が iPod で、Observer は聴く人。
なんとこの iPod はイヤホンジャックがたくさんあります。
そしてさらにこの iPod はイヤホンを接続するだけで再生が始まり、抜くと停止します。</p>

<p>Cold な iPod では、聴く人がイヤホンを接続すると、音楽が最初から再生されます。
次の人がイヤホンを接続すると、また音楽が最初から再生されます。(最初の人は、再生されなおすわけじゃないよ。)</p>

<p>Hot な iPod では、最初に聴く人がイヤホンを接続すると、音楽が再生され始めます。
次の人が、イヤホンを接続すると、その人は途中から聴くことになります。一つのストリーミング放送をみんなで聴くみたいな。
最後の人がイヤホンを外すと、再生が止まります(この辺はストリーミングと微妙に感覚が異なる、ストリーミングって、聴いてる人が居ようが居まいが流され続けるってイメージだから)。</p>

<h2>何が問題か</h2>

<p>以上を踏まえた上で、<a href="http://qiita.com/items/e15ba88d51938531b1a3">reactive4java で位置を取得し続ける - Qiita</a> で作ったプログラムのどこが問題だったかというと。</p>

<p>位置を聞くために接続をすると、その都度、<code>locMan.requestLocationUpdates</code> が呼ばれているという事です。上記の音楽プレーヤで例えると、<code>player.start()</code> です。</p>

<p>位置情報の取得は、ホントに無限ストリーミングなので、一見問題無さげに見えますが、２つリスナを登録するのは頂けません。(中には複数のリスナを登録できない API もあるでしょう、ありました。それで気づいたんです。)</p>

<p>これは最初の register でのみ <code>locMan.requestLocationUpdates</code> が実行され、2番目以降の register では、observer.next だけが呼ばれるようにしないといけません。
そのためには、register した複数の observer を保持・管理する必要があります。うげー。</p>

<h2>そこで Publish ですよ。</h2>

<p>.publish() を Observable のおしりにくっつけます。はい、これだけ。本当に。簡単すぎて「いいの？」って思っちゃうくらい。</p>

<p>``java getCurrectLocationAsHotObservable.java
/<em>*
 * 位置を取得し続ける(Hot)
 </em>/
public static ObservableBuilder<Location> getCurrentLocationAsHotObservable(</p>

<pre><code>final Context context, final String provider) {
return ObservableBuilder.from(
    getCurrentlocationAsObservable(context, provider)
    ).publish(); // Cold → Hot へ変換！
</code></pre>

<p>}
```</p>

<p>これだけで、複数の人が位置を聴きに来ても、<code>locMan.requestLocationUpdates</code> が呼ばれるのは１回だけである、Hot な Observable になります。Rx すげえよ Rx！</p>

<p>reactive4java のソースを読んだところ、前述の「複数の observer を保持・管理して、最初だけリスナ登録して、誰もいなくなったらリスナ解除する」みたいな面倒なことを publish の中(正確には observeOn)で行なってくれているようです。</p>

<p>ますます Reactive Extensions が好きになりましたよ。</p>

<h2>.NET の Reactive Extensions と reactive4java の違い</h2>

<p>.NET の Reactive Extenstions では、Publish は、<code>IConnectableObservable&lt;T&gt;</code> を返すそうです。そして <code>Subscribe</code> しただけでは再生は開始されず、<code>Connect</code> した時に再生されるのだ、とも。</p>

<p>一方、<a href="http://reactive4java.googlecode.com/svn/trunk/Reactive4Java/docs/javadoc/index.html">reactive4java</a> では、<code>publish</code> は、普通の <code>Observable&lt;T&gt;</code> を返します。Observable には register(.NET の Subscribe に相当)しかないので、これを呼び出した時に再生が開始されます。</p>

<p>特に reactive4java の挙動で困っていませんが、今後のバージョンアップで .NET 側に合わせられるかも知れません。
ConnecableObservable という interface は既に用意されていますが、使われていないようです。</p>

<h2>参考</h2>

<ul>
<li><a href="http://xin9le.net/archives/104">Rx入門 (14) – Cold to Hot変換 : xin9le note</a></li>
<li><a href="http://d.hatena.ne.jp/okazuki/20120212/1329059831">Reactive Extensions再入門 その３６「ColdからHotへ！Publishメソッドと参照カウンタ？RefCountメソッド」 - かずきのBlog@Hatena</a></li>
<li><a href="http://neue.cc/2010/06/24_263.html">neue cc - Reactive Extensions for .NET (Rx) メソッド探訪第7回:IEnumerable vs IObservable</a></li>
</ul>


<p>Rx の神々のみなさんが懇切丁寧に解説してくださってるのに、失敗しないと気づかない自分のバカバカ！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[reactive4java で位置を取得し続ける]]></title>
    <link href="http://amay077.github.io/blog/2012/10/03/locate-using-reactive4java/"/>
    <updated>2012-10-03T15:21:00+09:00</updated>
    <id>http://amay077.github.io/blog/2012/10/03/locate-using-reactive4java</id>
    <content type="html"><![CDATA[<p><a href="http://qiita.com/items/07762776102dbc84b1c7">前回</a>に続き、 reactive4java ネタ。
調子に乗って Android で位置を取得し続けるのを reactive4java を使ってやってみた。</p>

<!--more-->


<p>```java LocationFunctions.java
/<em>*
 * 位置を取得し続ける(finish は呼ばれない)
 </em>/
public static Observable<Location> getCurrentLocationAsObservable(</p>

<pre><code>    final Context context, final String provider) {
return Reactive.createWithCloseable(new Func1&lt;Observer&lt;? super Location&gt;, Closeable&gt;() {
    private volatile boolean _stop = false;

    @Override
    public Closeable invoke(final Observer&lt;? super Location&gt; observer) {
        final LocationManager locMan = (LocationManager)context.getSystemService(Context.LOCATION_SERVICE);

        final LocationListener listener = new LocationListener() {

            @Override
            public void onStatusChanged(String provider, int status, Bundle extras) { }

            @Override
            public void onProviderEnabled(String provider) { }

            @Override
            public void onProviderDisabled(String provider) {
                observer.error(
                    new InvalidParameterException("LocationProvider disabled."));
            }

            @Override
            public void onLocationChanged(Location location) {
                if (_stop) {
                    return;
                }

                // 発火
                observer.next(location);
            }
        };

        // 位置取得開始
        locMan.requestLocationUpdates(provider, 0, 0, listener, Looper.getMainLooper());

        return new Closeable() {
            @Override
            public void close() throws IOException {
                if (_stop) {
                    return;
                }
                _stop = true;
                locMan.removeUpdates(listener);
                observer.finish();
            }
        };
    }
});
</code></pre>

<p>}
```</p>

<p>使い方は、方位の時とほとんど同じ。パラメータが Float から Location に代わっただけ。</p>

<p><code>_stop</code> フラグは、Listener を unregister しても溜まってるデータは流しちゃうんじゃないか、という事で用意した。
方位のやつは AtomicBoolean を使ったけどこっちは volatile でやってる。確かどっかで 'AtomicBoolean の方が確実に Atomic' って言ってた気がするけど、そもそもそんなに神経質になるところじゃないか。</p>

<p>Observable にすることで、「ｎ秒間位置を取得して貯めて、その中で一番精度の良いものを通す」みたいなことも簡単にできる。</p>

<p>Android の場合、購読開始時に registerXXXListener、Close で unregisterXXXEventListener てのがひとつのパターン。
たぶん BroadcastReceiver にも適用できる。</p>

<p>XXXListener も BroadcastReceiver も Observable でラップしちゃえば、その後は同じように扱えるので便利♪</p>

<h2>追記 9.27</h2>

<p>実はこのプログラム、Cold でしたー。というわけで、Hot についての記事を書きました。
* <a href="http://qiita.com/items/3a7bda9d0fdcb9248800">Cold を Hot にできる。そう、Publish ならね。 - Qiita</a></p>

<h2>参考</h2>

<ul>
<li><a href="http://qiita.com/items/07762776102dbc84b1c7">reactive4java で端末の方位を取得しつづける - Qiita</a></li>
<li><a href="http://stackoverflow.com/questions/3786825/java-volatile-boolean-vs-atomicboolean">Java: volatile boolean vs AtomicBoolean - Stack Overflow</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
