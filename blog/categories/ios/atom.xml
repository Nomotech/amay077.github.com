<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Experiments Never Fail]]></title>
  <link href="http://amay077.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://amay077.github.io/"/>
  <updated>2014-03-19T00:35:13+09:00</updated>
  <id>http://amay077.github.io/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS アプリでアラート出してボタンが押されるまで待つ？方法を Objective-C と Xamarin.iOS で比べてみた]]></title>
    <link href="http://amay077.github.io/blog/2014/03/10/using-uialertview-objc-vs-xamarin/"/>
    <updated>2014-03-10T22:09:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/03/10/using-uialertview-objc-vs-xamarin</id>
    <content type="html"><![CDATA[<p>なんか割とニーズがあるみたいで。</p>

<!--more-->


<ul>
<li><a href="http://teapipin.blog10.fc2.com/blog-entry-224.html">【Objective-C】アラート（UIAlertView）でボタンを押すまで次の処理を待つ方法 - creativi.tea</a></li>
<li><a href="http://cocoadays.blogspot.jp/2011/05/ios.html">Cocoaの日々: [iOS] 非同期処理を同期処理に変える</a></li>
<li><a href="http://qiita.com/edo_m18/items/cb1d9061d91e572b58eb">[Objective-C] UIAlertViewを同期処理する - Qiita </a></li>
</ul>


<h2>Objective-C の場合</h2>

<p><code>UIAlertView</code> は、結果を受け取るのが deletgate で、 Objective-C では、(Blocks を使わなければ) 受け取りが別メソッドになってしまう、しかも複数のアラートの結果が同じメソッドに飛んでくるので、tag値で分岐…とかいろいろで、ホントに使うのが面倒ですね。</p>

<p>さらに、「アラートの結果を受け取ってから、次の処理を行う」という処理を素直に記述したいと思うと、上で示したような「アラートを表示して、結果が得られるまで while で待つ」というなんとも不格好なコードになってしまいます。下にも書いてみました。（あ、メンバ変数も使わざるを得ないし。）</p>

<p>```objective-c HogeViewController.m
@implementation HogeViewController {</p>

<pre><code>NSInteger _buttonIndex;
</code></pre>

<p>}</p>

<ul>
<li>(IBAction)buttonTouchUp:(id)sender
{
  UIAlertView *alert = [[UIAlertView alloc] initWithTitle:nil

<pre><code>                          message:NSLocalizedString(@"なにか押して",@"")
                         delegate:self
                cancelButtonTitle:@"Cancel"
                otherButtonTitles:@"OK", nil];
</code></pre>

<p>  [alert show];</p>

<p>  // ボタンが押されるまで待つ
  <em>buttonIndex = -1;
  while (</em>buttonIndex == -1) {</p>

<pre><code>  [[NSRunLoop currentRunLoop]
   runUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.5f]]; // 0.5秒
</code></pre>

<p>  }</p>

<p>  label1.text = [NSString stringWithFormat:@"%d 番目のボタンを押したね", (int)_buttonIndex];
}</p></li>
</ul>


<p>-(void)alertView:(UIAlertView*)alertView clickedButtonAtIndex:(NSInteger)buttonIndex
{</p>

<pre><code>_buttonIndex = buttonIndex;
</code></pre>

<p>}
```</p>

<p><code>[NSRunLoop runUntilDate]</code> なんて VB6 の <code>DoEvents</code> ですもんねなつかしい。</p>

<h2>Xamarin.iOS(C#) の場合</h2>

<p>Objective-C ではややこしかった「アラートを出す→ボタンを押す→次の処理へ」という流れ、 Xamarin.iOS と C# ならこんなにシンプルに書けます。</p>

<p>```csharp HogeViewController.cs
async void OnButtonTouch(object sender, EventArgs e)
{</p>

<pre><code>var buttonIndex = await MsgBox("", "なにか押して", "Cancel", "OK");
label1.Text = buttonIndex.ToString() + "番目を押したね";  
</code></pre>

<p>}</p>

<p>static Task<int> MsgBox(string title, string message,</p>

<pre><code>string cancelButtonTitle, params string[] buttons)
</code></pre>

<p>{</p>

<pre><code>var comp = new TaskCompletionSource&lt;int&gt;();

var alert = new UIAlertView(title, message, null, cancelButtonTitle, buttons);
alert.Clicked += (_, e) =&gt; comp.TrySetResult(e.ButtonIndex);
alert.Show();

return comp.Task;
</code></pre>

<p>}
```</p>

<p>VB6 が懐かしくて <code>MsgBox</code> ってメソッドにしちゃいましたよ。</p>

<p><code>MsgBox</code> は、Task を返す <strong>非同期な</strong> メソッドです。この非同期処理が終了するのは、<code>TaskCompletionSource.TrySetResult</code> が呼び出された時、つまりアラートのボタンが押された時です。この非同期処理の戻り値はもちろん押したボタンのインデックスです。</p>

<p>非同期メソッドである <code>MsgBox</code> を呼び出す側には、キーワード <code>await</code> が付いています。
これをつけると、次行以降の処理は、非同期の MsgBox が完了した後、順次実行されます、つまり待っているわけではなく、どちらかというと、 <strong>処理を後続に付け足す</strong> 感じ。
さらに、この後続処理はUIスレッドで実行されるので、UIパーツへのアクセスも問題ありません。</p>

<p><code>async</code> はメソッド内で <code>await</code> を使うときにつけるお約束。</p>

<p>async/await は一見、ただの同期処理に見えるので理解して使う必要がありますが、Objective-C のコードに比べて、とても簡潔に、流れるように書くことができるのが分かると思います。</p>

<p><strong>C# の非常に強力な言語機能は、<a href="https://xamarin.com/">Xamarin</a> を選択する大きな理由の一つです。</strong></p>

<h2>参考</h2>

<ul>
<li><a href="http://stackoverflow.com/questions/4613071/messagebox-show-and-dialogresult-equivalent-in-monotouch">c# - Messagebox.Show and DialogResult equivalent in MonoTouch - Stack Overflow</a></li>
<li><a href="http://ufcpp.wordpress.com/2012/11/12/asyncawait%e3%81%a8%e5%90%8c%e6%99%82%e5%ae%9f%e8%a1%8c%e5%88%b6%e5%be%a1/">async/awaitと同時実行制御 | ++C++; // 未確認飛行 C ブログ</a></li>
<li><a href="http://www.slideshare.net/bleistift/asyncawait2">async/await不要論</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin によるクロスプラットフォームモバイルアプリ開発、資料と補足]]></title>
    <link href="http://amay077.github.io/blog/2014/02/27/slides-from-my-xamarin-introduction/"/>
    <updated>2014-02-27T21:40:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/02/27/slides-from-my-xamarin-introduction</id>
    <content type="html"><![CDATA[<p>2/26 の <a href="http://atnd.org/events/47898">うずらインキュベータ</a> という勉強会で、Xamarin の話をしました。</p>

<!--more-->




<iframe src="http://www.slideshare.net/slideshow/embed_code/31674661" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px 1px 0; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>


<p> <div style="margin-bottom:5px"> <strong> <a href="https://www.slideshare.net/amay077/xamarin-31674661" title="Xamarin によるクロスプラットフォームモバイルアプリ開発" target="_blank">Xamarin によるクロスプラットフォームモバイルアプリ開発</a> </strong> from <strong><a href="http://www.slideshare.net/amay077" target="_blank">amay 077</a></strong> </div></p>

<p>45分という長い時間話すのは勉強会では初めてだったのですが、なんとか説明し切ることができました。（ちょっとデモが中途半端になってしまいましたが）</p>

<p>資料は <a href="http://qiita.com/tags/xamarin">Qiita に書いてきた</a> 内容のまとめみたいなものですが、少し補足します。</p>

<h2>Xamarin で作った経験あるの？</h2>

<p>仕事では、まだ無いです（<sup>_<sup>;）</sup></sup>
個人アプリでは「<a href="https://itunes.apple.com/us/app/fu-shifoto/id806913229">富士フォト</a>」というのを iOS 用は Xamarin.iOS で作りました。<a href="https://play.google.com/store/apps/details?id=com.amay077.android.fujiphoto">Android</a> は Java ですが Xamarin 化したいな。</p>

<h2>Win+Visual Studio ではダメなの？</h2>

<p>個人の見解ですから（<sup>_<sup>;）</sup></sup>
私も元々は Windowsの開発がメインで Visual Studio の強力さは知っていますが、iOS やるならどういう形にせよ Mac+Xcode を扱わないといけないので、慣れておいた方がよいかなと。</p>

<p>また、Microsoft との提携以降、Microsoft のエバンジェリストさんや MVP の方々が Visual Studio + Xamarin の話をものすごく展開されているので、そちらにお任せした次第です。</p>

<h2>実行モデルのとこ</h2>

<p>JavaSE が .NET に置き換わる図になっていますが、実際には少し違っていて、JavaSE のラッパもあります。例えば文字列型には、<code>System.String</code> と <code>Java.Lang.String</code> があります。当然、理由がなければ前者を使った方がよいわけですが。</p>

<p>iOS のスタックに関しては、実はどこからどこまでが「CocoaTouch」なのかよく分かってません。</p>

<h2>他のクロスプラットフォーム開発ツールとの比較</h2>

<p>Titanium, AIR については2年くらい前に少し触ったことがあります。PhoneGap と DelphiXE についてはスペックを見て＆詳しい方からの情報を元にしてます。</p>

<p>Titanium は次期 <a href="http://titanium-mobile.jp/38">Ti.Next</a> では JavaScriptCore を使ってすんごく速くなるそうですし、AIR も当時よりだいぶ <a href="http://www.slideshare.net/pik256/dev-sumi2014-13c4rev">高速になったらしい</a> です。</p>

<h2>C# のとこ</h2>

<p>https://xamarin.com/csharp よりは悪意のないコードかとｗ
（Objective-C と比較しようとすると Obj-C の方が画面に入らないので Java との比較にしました。）</p>

<p>こんなところで。
何かおかしなところがあったらコメント頂けるとありがたいです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MVVMフレームワーク「ReactiveUI」を Xamarin.iOS で使ってみる]]></title>
    <link href="http://amay077.github.io/blog/2014/02/27/using-reactiveui-on-xamarin-ios/"/>
    <updated>2014-02-27T21:34:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/02/27/using-reactiveui-on-xamarin-ios</id>
    <content type="html"><![CDATA[<p>ReactiveUI は、Reactive Extensions を全面的に取り入れた クロスプラットフォームな MVVMフレームワークです。</p>

<!--more-->


<ul>
<li><a href="http://www.reactiveui.net/">ReactiveUI</a></li>
</ul>


<p>作者は GitHub の中の人 <a href="http://twitter.com/xpaulbettsx">Paul Betts</a> 氏、<a href="http://xamarin.com/mvp">Xamarin の MVP</a> でもあります。</p>

<p>元々は WPF, Silverlight, WinRT, Windows Phone に対応していましたが、Xamarin.iOS や Xamarin.Android, Xamarin.Mac にも <a href="http://blog.paulbetts.org/index.php/2013/03/12/reactiveui-4-5-is-released/">対応が進んで来た</a> ので、使ってみる事にしました。</p>

<p>Visual Studio + WPF 等なら、nuget から取得できて楽なんでしょうけども、なにせ Mac なので、Xamarin Studio のみでいきます。</p>

<h2>とりあえず使ってみる</h2>

<p>Github が公開した <a href="http://log.paulbetts.org/open-source-githubs-xamarin-starter-apps/">GitHub's Xamarin starter apps</a>, これに ReactiveUI も含まれているので、こちらを Clone して Xamarin Studio で開いてビルド、すぐ動きます。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/using_reactiveui_01.png" alt="" /></p>

<p>これ、ViewModel側で UUID を生成して、View側の Label にバインドしているのですが、何ともシンプル過ぎて…。</p>

<p>それでもこのフレームワークの構成を知るには十分です。</p>

<h2>ReactiveUI に必要なもの</h2>

<p>ソリューションツリーを見ると次の4つのプロジェクトがあります。</p>

<ul>
<li>Starter-Core-Android</li>
<li>Starter-Core-iOS</li>
<li>Starter-Android</li>
<li>Starter-iOS</li>
</ul>


<h3>ViewModel-Model層</h3>

<p>Starter-Core-xxx は、ディレクトリ的には同じ場所にあり、Android用とiOS用のプロジェクトファイル(.csproj)が用意してあるだけです。ここはアプリケーションの ViewModel-Model層になります。PCL化はされていないようですね(その内、とサイトに書いてありました)。</p>

<p>サンプルで用意されてる ViewModel を見てみます。</p>

<p>```csharp TestViewModel.cs
using System;
using ReactiveUI;
using System.Runtime.Serialization;</p>

<p>namespace Starter.Core.ViewModels
{</p>

<pre><code>[DataContract]
public class TestViewModel : ReactiveObject
{
    string _TheGuid;
    [DataMember] public string TheGuid {
        get { return _TheGuid; }
        set { this.RaiseAndSetIfChanged(ref _TheGuid, value); }
    }

    public TestViewModel()
    {
        TheGuid = Guid.NewGuid().ToString();
    }
}
</code></pre>

<p>}
```</p>

<p>MvvmCross とか、他の MVVM-FW とだいたい同じですね(そりゃそうだ)。
基底クラスの <code>ReactiveObject</code> が、BaseViewModel的な役割をします。(が、Reactive を冠しているだけに、随所で Rx の力が発揮される、はずです←まだ分かってない)</p>

<p>このコードでは、TestViewModel の生成と同時に、Guid を生成して、<code>TheGuid</code> プロパティに設定しています。</p>

<h3>View層</h3>

<p>Starter-Android, Starter-iOS はそれぞれの View層になります。</p>

<p>Starter-iOS の TestViewController.cs を見てみます。</p>

<p>```csharp TestViewController.cs
namespace Starter.Views
{</p>

<pre><code>public partial class TestViewController : ReactiveViewController, IViewFor&lt;TestViewModel&gt;
{
    [省略]

    public override async void ViewDidLoad()
    {
        base.ViewDidLoad();
        this.OneWayBind(ViewModel, vm =&gt; vm.TheGuid, v =&gt; v.TheGuid.Text);

        ViewModel = await BlobCache.LocalMachine.GetOrCreateObject("TestViewModel", () =&gt; {
            return new TestViewModel();
        });
    }

    TestViewModel _ViewModel;
    public TestViewModel ViewModel {
        get { return _ViewModel; }
        set { this.RaiseAndSetIfChanged(ref _ViewModel, value); }
    }

    [省略]
}
</code></pre>

<p>}
```</p>

<p><code>UIViewController</code> ではなく <code>ReactiveViewController</code> から派生させてます。この辺もよくあるやり方。<code>IViewFor</code> は、今はスルーで。</p>

<p>バインドは <code>this.OneWayBind</code> で。
ViewModel の TheGuid プロパティを、View の TheGuidラベルの Text プロパティへ単方向(OneWay)バインドしてます。</p>

<p>TestViewModel の生成は、ここでは Akavache というストレージライブラリの生成を待ってから行っていますが、Akavache を使わない場合は普通に <code>this.ViewModel = new TestViewModel()</code> で OK でしょう。</p>

<p>これで、TestViewModelの生成 → Guidの生成 → vm.TheGuidプロパティへ設定 → vm より TheGuid の変更が通知される → View側のBindingが変更を検知 → Viewのラベルを書き換える、という流れになります。</p>

<h2>ちょっと拡張してみる</h2>

<h3>双方向バインディング</h3>

<p>ViewModel→View だけでなく、View→ViewModel もやってみましょう。</p>

<p>まず TestViewModel にプロパティを追加します。
プロパティは <code>MyName</code> とします。
初期値として "Enter your name" とでも設定しましょうか。</p>

<p>```csharp TestViewModel.cs
namespace Starter.Core.ViewModels
{</p>

<pre><code>[DataContract]
public class TestViewModel : ReactiveObject
{
    string _TheGuid;
    [DataMember] public string TheGuid {
        get { return _TheGuid; }
        set { this.RaiseAndSetIfChanged(ref _TheGuid, value); }
    }

    string _myName;
    [DataMember] public string MyName {
        get { return _myName; }
        set { this.RaiseAndSetIfChanged(ref _myName, value); }
    }

    public TestViewModel()
    {
        TheGuid = Guid.NewGuid().ToString();

        this.MyName = "Enter your name";
    }
}
</code></pre>

<p>}
```</p>

<p>次に Interface Builder で TestViewController に、UITextField と UILabel を追加し、Outlet を "MyText", "MyLabel" とします。これで Xamarin.iOS から <code>MyText</code>, <code>MyLabel</code> でインスタンスにアクセスできるはず、ですよね。</p>

<p><code>MyText</code>, <code>MyLabel</code> に、vm.MyName をバインドします。</p>

<p>```csharp TestViewController.cs
namespace Starter.Views
{</p>

<pre><code>public partial class TestViewController : ReactiveViewController, IViewFor&lt;TestViewModel&gt;
{
    [省略]

    public override async void ViewDidLoad()
    {
        base.ViewDidLoad();
        this.OneWayBind(ViewModel, vm =&gt; vm.TheGuid, v =&gt; v.TheGuid.Text);

        this.Bind(ViewModel, vm=&gt; vm.MyName, v =&gt; v.MyText.Text);
        this.OneWayBind(ViewModel, vm =&gt; vm.MyName, v =&gt; v.MyLabel.Text);

        ViewModel = await BlobCache.LocalMachine.GetOrCreateObject("TestViewModel", () =&gt; {
            return new TestViewModel();
        });
    }

    [省略]
}
</code></pre>

<p>}
```</p>

<p>編集できる <code>MyText</code> は <code>this.Bind</code> を使って双方向バインドします。プロパティの値を表示するだけの <code>MyLabel</code> は、 <code>this.OneWayBind</code> で。</p>

<p>これで動かしてみます。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/using_reactiveui_02.gif" alt="" /></p>

<p>UITextField への入力が、vm.MyName へ適用され、その変更を MyLabel に表示させる、という流れです。</p>

<p>今日はこの辺で。まだ全然 Reactive じゃないですが、次回以降、Command の実装やバインディングについて試してみようと思います。</p>

<p>ここまでのコードは、</p>

<ul>
<li>https://github.com/amay077/starter-mobile/tree/N_plus_1</li>
</ul>


<p>に置いておきます。徐々に進化させていこうと思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MvvmCross だけじゃない！クロスプラットフォームMVVMフレームワーク「QuickCross」を試す]]></title>
    <link href="http://amay077.github.io/blog/2014/02/11/introduce-quickcross/"/>
    <updated>2014-02-11T19:47:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/02/11/introduce-quickcross</id>
    <content type="html"><![CDATA[<p><a href="http://amay077.github.io/blog/2013/12/25/using-mvvmcross-the-x-platform-mvvm-framework/">以前、MvvmCross を紹介しました</a> が、Xamarin で使える同種のフレームワークはまだいくつかあります。</p>

<!--more-->


<p>今回は、その中の一つ、「QuickCross」を見てみます</p>

<ul>
<li><a href="https://github.com/MacawNL/QuickCross">MacawNL/QuickCross</a></li>
</ul>


<h2>なぜ他のMVVMフレームワークが必要なのか？</h2>

<p><a href="https://github.com/MacawNL/QuickCross#why-another-cross-platform-mvvm-framework">Why another cross-platform Mvvm framework?</a> にて、MvvmCross があるのになぜ？という事を説明しています。</p>

<p>要約すると、MvvmCross は、高機能だが Fat で複雑で、拡張が大変であるのに対し、QuickCross は、軽量で生産性が高く、拡張が簡単である、との事です。</p>

<h2>主な機能</h2>

<p><a href="https://github.com/MacawNL/QuickCross#features">Features</a> より。</p>

<ul>
<li>Xamarin.iOS, Xamarin.Android, Windows Phone, Windows Store Apps に対応。</li>
<li>バイナリは使ってない！Snippet と、プロジェクトにソースコードの追加を行うだけです。</li>
<li>ViewModel や View の追加は package manager console からコマンドを実行して行います。</li>
<li>いくつかのコードスニペットを提供します。</li>
<li>以下略…</li>
</ul>


<h2>仕組み</h2>

<p><img src="https://raw.github.com/MacawNL/QuickCross/master/assets/quickcross_pattern.png" alt="" />
via https://github.com/MacawNL/QuickCross#features</p>

<p>Navigator って概念があるのが MvvmCross と違うとこですかね。</p>

<h2>使い方</h2>

<p><a href="https://github.com/MacawNL/QuickCross#getting-started">Getting Started</a> を見てください。</p>

<p>Nuget の Package manager console を使う必要があるので、Mac と Xamarin Studio 、そして Indie Edition では試せません、残念。
Visual Studio ＋ Xamarin Business Edition以上を使ってる方、試してみてください。</p>

<h2>サンプルを動かしてみた</h2>

<p>Getting Started は試せませんでしたが、github に含まれるサンプルは Mac + Xamarin Studio でも動かせました。</p>

<p><a href="https://github.com/MacawNL/QuickCross/blob/master/QuickCross.ios.sln">QuickCross.ios.sln</a> を Xamarin Studio で開いて実行したところ↓</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/introduce_quickcross_01.png" alt="" /></p>

<p>MvvmCross と同じく、ViewModel などは Shared プロジェクトの方にあります。
Shared プロジェクトは PCL にできるんじゃないかなーと思いやってみましたが、</p>

<ul>
<li>Profile147(.NET4.0) では <code>System.Windows.Input.ICommand</code> が無いと言われ</li>
<li>Profile78(.NET4.5) では、この<a href="https://bugzilla.xamarin.com/show_bug.cgi?id=17247">バグ</a> にエンカウント</li>
</ul>


<p>してビルドできませんでした、残念。</p>

<h2>まとめ</h2>

<p>MvvmCross は確かに大規模すぎて使うのが大変です。拡張するには Plugin を自作する事になりますし。
QuickCross は、すべてのソースコードがプロジェクトにあるので、カスタマイズが手軽に行えそうだというのは分かりました。</p>

<p>Xamarin Starter Edition の場合、64kbyte までのバイナリ制限があるので、MvvmCross は使えませんが、QuickCross なら使えるかも知れません。</p>

<p>ただ残念なのは、Nuget の Package Manager Console を使う必要があるために、Visual Studio が必要で、その為には Xamarin も Business Edition 以上が必要になってしまう所です。</p>

<p>Xamarin Studio のみでも使えるくらい Lightweight だったら、もっと試してみたくなるフレームワークです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS と Android で画面表示時のコールバックを比較する]]></title>
    <link href="http://amay077.github.io/blog/2014/01/29/displaying-view-lifecycle-comparison-ios-android/"/>
    <updated>2014-01-29T15:55:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/01/29/displaying-view-lifecycle-comparison-ios-android</id>
    <content type="html"><![CDATA[<p>モバイル開発における画面のライフサイクル、重要ですね。
iOS と Android で「ざっくりとは同じでしょ？」などと思っていましたが、調べてみたら結構違ってました。</p>

<!--more-->


<p>と言うのも、こちら</p>

<ul>
<li><a href="http://blog.jarinosuke.com/entry/uiviewcontroller_view_coding_pattern">メモリ管理・レイアウトの観点からみた UIViewController の view の扱い - jarinosuke blog</a></li>
</ul>


<p>のエントリが大変参考になったので、「Android と比べるとどうか？」と興味が沸いたのです。</p>

<h2>画面が表示される時</h2>

<p>iOS/Android の <code>UIViewController</code>, <code>Activity</code> に備わってるコールバックの、画面表示時での発生順をそれぞれ調べて発生順に並べてみました。同じような意味のコールバックは横に並べて書きました。</p>

<table>
<thead>
<tr>
<th></th>
<th>順番</th>
<th>イベント</th>
<th>iOS(UIViewController)</th>
<th>Android(Activity)</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>1</td>
<td>クラスが生成された時</td>
<td>init</td>
<td>ctor(コンストラクタ)</td>
</tr>
<tr>
<td></td>
<td>2</td>
<td>画面がロードされる前</td>
<td>loadView</td>
<td>onCreate</td>
</tr>
<tr>
<td></td>
<td>3</td>
<td>(画面が再度開始される前)</td>
<td></td>
<td>onRestart ※停止状態(onStop)から復帰する時のみ</td>
</tr>
<tr>
<td></td>
<td>4</td>
<td>画面が開始される前</td>
<td></td>
<td>onStart</td>
</tr>
<tr>
<td></td>
<td>5</td>
<td>画面がロードされた後</td>
<td>viewDidLoad</td>
<td>onPostCreate</td>
</tr>
<tr>
<td></td>
<td>6</td>
<td>画面が表示され始める前</td>
<td></td>
<td>onResume ※一時停止(Pause)からの復帰はここから</td>
</tr>
<tr>
<td></td>
<td>7</td>
<td>画面が表示され始めた後</td>
<td></td>
<td>onPostResume</td>
</tr>
<tr>
<td></td>
<td>8</td>
<td>UIの配置が行われる前</td>
<td>viewWillLayoutSubviews</td>
<td></td>
</tr>
<tr>
<td></td>
<td>9</td>
<td>UIの配置が行われた後</td>
<td>viewDidLayoutSubviews</td>
<td></td>
</tr>
<tr>
<td></td>
<td>10</td>
<td>画面が表示される直前</td>
<td> viewWillAppear </td>
<td></td>
</tr>
<tr>
<td></td>
<td>11</td>
<td>画面が表示された直後</td>
<td>viewDidAppear</td>
<td></td>
</tr>
<tr>
<td></td>
<td>12</td>
<td>画面にフォーカスが移った直後</td>
<td></td>
<td>onWindowFocusChanged(true) ※表示される度に呼ばれる</td>
</tr>
</tbody>
</table>


<h3>onCreate は生成前？後？</h3>

<p>iOS というか CocoaTouch の命名文化って、will とか did とか、時系列が明確に分かるものが多いので良いですね。
それに比べて Android は…。 onCreate は前？後？ onPostCreate があるので「前」ですね。</p>

<h3>UIパーツのサイズはいつ決まるのか？</h3>

<p>iOS の方は 9. <code>viewDidLayoutSubviews</code> の時です。
冒頭で紹介したエントリにも以下のように書かれています。</p>

<blockquote><p>self.view の subviews.frame の調整、すなわちレイアウト処理は全てここで記述するべきです。</p></blockquote>

<p>Android の方は問題です。
<code>Button</code> などの生成は <code>onCreate</code> で行うのが一般的ですが、この時点では、まだレイアウトされていません。なので大抵の場合 <code>button1.Height = 0</code> です。
では、いつのタイミングで <code>button1.Height</code> に適切な値が格納されるかと言うと…、 12. <code>onWindowFocusChanged(true)</code> まで待たないといけません。しかもこのコールバックは、Focus が変わる度に呼ばれるので、「最初の１回」だけを取得しようと思ったら別のフラグが必要になります、あーめんどい。</p>

<p>続きは</p>

<ul>
<li><a href="http://stackoverflow.com/questions/4393612/when-can-i-first-measure-a-view">android - When Can I First Measure a View? - Stack Overflow</a></li>
</ul>


<p>で。私は <code>View.post</code> する方法が一番簡単だと思いました。</p>

<h3>onResume/onPostResume の命名が...</h3>

<p>「画面が表示され始める前/画面が表示され始めた後」なんて無理やりな名前を付けてしまいました。
特に <code>onPostResume</code> は無理がありすぎ。
名前からは <code>viewDidAppear</code> に相当するとも捉えられますが、まだこの時点ではレイアウトが完了していないという、中途半端なタイミングです。何のために使えば良いのでしょう？</p>

<h3>回転したらどうなるの？</h3>

<p>iOS の場合は、8.<code>viewWillLayoutSubviews</code> からやり直しです。つまり、ここに適切に縦横対応のレイアウト処理を記述しておけば、<code>didRotateFromInterfaceOrientation</code>など、他のコールバックでの処理は通常必要ないと思います。</p>

<p>Android の場合は、AndroidManifest.xml への設定なしだと、なんと 1.コンストラクタ からやりなおしです。とその前に当然 <code>onDestroy</code> や <code>OnSaveInstanceState</code> が呼ばれるわけですが、、、それはまた別の機会に。</p>

<h2>まとめっぽいもの</h2>

<p>iOS プログラミングでは今まで <code>viewDidLoad</code> で、UIパーツを生成してレイアウト処理してるプログラムが多いように思いますが、それは間違いで、「loadView で生成して、viewDidLayoutSubviews でレイアウト」とするのが最も効率的なようです。</p>

<p>Android でも、onCreate でレイアウト処理するとハマることがありそうです(<a href="http://qiita.com/amay077/items/070ac1db6b52dd03505f">実際ありました</a>)。ちょっと注意しといた方がよさそうです。</p>

<p>「画面が破棄される時」「メモリが足りなくなった時」「回転した時」とか、書くこと沢山あるんですけど、ありすぎてもうダメです。</p>

<h2>参考</h2>

<h3>iOS</h3>

<ul>
<li><a href="https://developer.apple.com/library/ios/Documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController">UIViewController Class Reference</a></li>
<li><a href="http://blog.jarinosuke.com/entry/uiviewcontroller_view_coding_pattern">メモリ管理・レイアウトの観点からみた UIViewController の view の扱い - jarinosuke blog</a></li>
<li><a href="https://gist.github.com/shinyaohira/6482235">iOS View Controllerプログラミングガイド</a></li>
</ul>


<h3>Android</h3>

<ul>
<li><a href="http://developer.android.com/training/basics/activity-lifecycle/starting.html">Starting an Activity | Android Developers</a></li>
<li><a href="http://developer.android.com/reference/android/app/Activity.html">Activity | Android Developers</a></li>
<li><a href="http://qiita.com/amay077/items/070ac1db6b52dd03505f">moveCamera(CameraUpdateFactory.newLatLngBounds(… で落ちる</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
