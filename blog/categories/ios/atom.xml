<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Experiments Never Fail]]></title>
  <link href="http://blog.amay077.net/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://blog.amay077.net/"/>
  <updated>2014-07-17T20:55:52+09:00</updated>
  <id>http://blog.amay077.net/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Xamarin.Forms の Label から iOS の UILabel を取り出す]]></title>
    <link href="http://blog.amay077.net/blog/2014/06/13/convert-xamarin-forms-label-to-native-uilabel/"/>
    <updated>2014-06-13T15:34:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/06/13/convert-xamarin-forms-label-to-native-uilabel</id>
    <content type="html"><![CDATA[<p><a href="http://qiita.com/amay077/items/12979585ac3e2dcacacb">Xamarin.Forms でどうにかしたい iOS と Android の違い</a> の「文字の自動縮小」の自己回答。</p>

<!--more-->


<p>Xamarin.Forms で定義した <code>Label</code> は、iOS では <code>UILabel</code> となるはずなので、その過程のどこかでフックできれば <code>UILabel.AdjustsFontSizeToFitWidth</code> が仕込める、と目論んで、ホントにできたのでメモ。</p>

<h2>要点</h2>

<p><del>Forms→ネイティブのフックは PageRenderer でできる。その中で得られる UIView（のサブクラス）は、Label と UILabel の両方の参照を持っているので、あとは使うだけ。</del></p>

<p><strong>ページでなく、UIパーツレベルでフックできたので、全面的に書き換えた。</strong></p>

<h2>やってみる</h2>

<p>参考にしたのは https://github.com/xamarin/xamarin-forms-samples/tree/master/Forms2Native 。</p>

<p>このサンプルをちょっと改造して試した。</p>

<p>まずは Forms側の MySecondPage.cs を修正。</p>

<p>```csharp MySecondPage.cs
public class MySecondPage : ContentPage
{</p>

<pre><code>public Label MyLabel { get; private set; }

public MySecondPage ()
{
    this.MyLabel = new Label
    {
        Text = "Too loooooooooooooooooooooooong label",
        Font = Font.SystemFontOfSize(30d),
        LineBreakMode = LineBreakMode.NoWrap
    };

    Content = new StackLayout
    {
        Orientation = StackOrientation.Vertical,
        VerticalOptions = LayoutOptions.CenterAndExpand,
        Children = 
        {
            this.MyLabel
        }
    };
}
</code></pre>

<p>}
```</p>

<p>ラベルを配置。とても文字が長いので全部は表示しきれない。</p>

<p>次に iOS側に MyLabelRenderer.cs を作成。</p>

<p>```csharp MyLabelRenderer.cs
using System;
using Xamarin.Forms;
using Forms2Native;
using Xamarin.Forms.Platform.iOS;
using MonoTouch.UIKit;</p>

<p>[assembly:ExportRenderer(typeof(Label), typeof(MyLabelRenderer))]</p>

<p>namespace Forms2Native
{</p>

<pre><code>public class MyLabelRenderer : LabelRenderer
{
    protected override void OnElementChanged(ElementChangedEventArgs&lt;Label&gt; e)
    {
        base.OnElementChanged(e);
        this.Control.AdjustsFontSizeToFitWidth = true;
    }
}
</code></pre>

<p>}
```</p>

<p><code>ExportRenderer</code> で「Formsの<code>Label</code>は、<code>MyLabelRenderer</code>を使う」と定義している。
するとすべての <code>Label</code> の生成時を <code>OnElementChanged</code> でフックでき、<code>Control</code> で <code>UILabel</code> は取り出せるので、あとはご自由に、という感じ。</p>

<p>この実装だと、すべての Label に Ajusts が適用されてしまう。個別に行いたい場合は、Forms側に Labelから派生した <code>AjustableLabel</code> を作成して使い、<code>ExportRenderer(typeof(Label),…</code> のところを <code>ExportRenderer(typeof(AjustableLabel),…</code> にすればいけるはず。そしてこの方法はカスタムビューを作る手順に通じる（というかそのもの？）はず。</p>

<p>ちなみにこの <code>OnElementChanged</code> は、Nuget の Xamarin.Formsパッケージの Ver1.1.0.6201から利用できる。</p>

<h2>実行する</h2>

<p>こんな感じで、ちゃんと文字サイズが縮小されました。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/getting_uilabel_from_xamarin_forms.png" alt="" /></p>

<p>Android の方も同じ要領でいけるは…ず。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.Forms でどうにかしたい iOS と Android の違い]]></title>
    <link href="http://blog.amay077.net/blog/2014/06/10/difference-ios-and-android-in-xamarin-forms/"/>
    <updated>2014-06-10T15:30:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/06/10/difference-ios-and-android-in-xamarin-forms</id>
    <content type="html"><![CDATA[<p>Xamarin.Forms で簡単な iOS/Android 両対応アプリを作ってみてて、悩ましい点がいくつか見つかってるので、挙げてみる。</p>

<!--more-->


<h2><del>不可視の扱い</del></h2>

<p><del>Forms 側のパーツには <code>IsVisible = true | false</code> がある。
iOS は <code>true | false</code> なのでいいけど、Android の Visibility は、 <code>Visible | Invisible | Gone</code> の3つある。</del></p>

<p><del>Forms 側での <code>IsVisible = false</code> は、Android では <code>Invisible</code> に相当するみたい。つまり StackLayout とかで「不可視なパーツが <strong>詰められない</strong>」。 iOS の <code>Visible = false</code> は <strong>詰められる</strong> 模様。</del></p>

<p><code>IsVisible = false</code> は Android ではちゃんと <code>Gone</code> になってました、すいませんでした。</p>

<h2>空文字の扱い</h2>

<p>IsVisible と勘違いしてたのはこっちだった。</p>

<p>StackLayout に、Label を2つ積んで、上の Label を空文字にすると、iOSでは詰められるけど、Androidでは空白が空くみたい。こっちはちゃんと裏をとった(汗)</p>

<p>https://gist.github.com/amay077/cf0f4ca1aa14d54bac9a</p>

<h2>画面回転時の再構築</h2>

<p>Android だと、画面を回転させると <code>onCreate</code> からやり直しなのは常識。
Forms アプリを Android で動かして回転させると、なんと <strong>RootPage まで戻って</strong> しまう。なんじゃこりゃ。</p>

<h2>回避方法</h2>

<blockquote class="twitter-tweet" lang="ja"><p><a href="https://twitter.com/amay077">@amay077</a> あとAndroidの回転問題（バグです）はとりあえず ConfigurationChanges = ConfigChanges.ScreenSize | ConfigChanges.Orientation で回避するといいそうです（そりゃそうだ…）</p>&mdash; Atsushi Eno (@atsushieno) <a href="https://twitter.com/atsushieno/statuses/476645011602165760">2014, 6月 11</a></blockquote>


<script async src="http://blog.amay077.net//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>こんな感じっすね。</p>

<p>```csharp MainActivity.cs
[Activity(MainLauncher = true,</p>

<pre><code>ConfigurationChanges = ConfigChanges.ScreenSize | ConfigChanges.Orientation )]
</code></pre>

<p>public class MainActivity : AndroidActivity
{
```</p>

<h2>BACKキーの扱い</h2>

<p>iOS なら <code>NavigationPage.SetHasNavigationBar(page, false)</code> としてしまえば、ナビゲーションバーが表示されなくなるので、前の画面に戻ることはできなくなるが、Android の BACKキーを無効にするにはどうしたら。。。</p>

<h3>自己解決</h3>

<p><code>AndroidActivity</code> のサブクラスで、<code>OnBackPressed</code> を override して実装を潰してしまえばよい。けど画面毎に「戻る／戻れない／Confirm出す」とか細かい制御ができるのかは不明。</p>

<h2>デフォルトスタイル</h2>

<p>iOS は白基調、Androidは黒基調なので、Forms側で <code>TextColor = Color.Black</code> などとすると、当たり前だが Android で見えない。
iOS はスタイル変えるのしんどいので、Android側の Theme を <code>Theme.Holo.Light</code> にしとく。</p>

<p>```csharp MainActivity.cs
[Activity(Label = "MyApp",<br/>
 MainLauncher = true,
 Theme = "@android:style/Theme.Holo.Light")]
public class MainActivity : AndroidActivity
{</p>

<pre><code>protected override void OnCreate(Bundle bundle)
{
    /* 以下省略 */
</code></pre>

<p>```</p>

<h2>起動時</h2>

<p>Android 側の起動時に ActionBar の付いた空白画面が表示される時間が割とながくて気になる(Galaxy Nexus だけど)。Forms の画面をロードするのに時間がかかるのだろうか？
ActionBar だけでも消したくて Theme を <code>Theme.Holo.Light.NoActionBar</code> にしてみたら Page が表示されなくなった。。。</p>

<p>NoActionBar な Theme を使うと Activity.ActionBar が null になるんだけど、Xamarin.Forms がそれに対応してない気がした（スタックトレース見ると UpdateActionBar で NullReferenceException だし）ので、<a href="https://bugzilla.xamarin.com/buglist.cgi?product=Forms&amp;component=Forms&amp;resolution=---&amp;list_id=92025">Bugzilla</a> に登録してみた、初めて。どうなるやら。</p>

<h2>文字の自動縮小</h2>

<p>iOS の <code>UITextField</code> は <code>adjustsFontSizeToFitWidth</code> を設定するとパーツのサイズに合わせて文字サイズを自動拡縮してくれる機能があったけど、Forms の <code>Label</code> にはそんなものはありません。<code>PageRenderer</code> を使って iOS 独自処理しないとダメ。</p>

<h3>自己解決</h3>

<p>やはり PageRenderer 使うとできた → <a href="http://qiita.com/amay077/items/8eaa595cc2fc88797b2f">Xamarin.Forms の Label から iOS の UILabel を取り出す</a></p>

<h2>iPhone と iPad</h2>

<p>StackLayout や RelativeLayout でUIを書けば、相対的な位置関係は iPhone と同じものが iPad でも再現されるが、サイズをリテラルで指定するところは、特にインテグレーションしてくれるわけでないので、プラットフォーム毎に調整が必要。例えば文字サイズは、iPad では iPhone より大きな値にしないと残念な感じに。</p>

<p>他にも見つけたら書きます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS4.x 対応のソースコードから「新しいAPI」を使っている箇所を探す]]></title>
    <link href="http://blog.amay077.net/blog/2014/05/14/find-new-api-in-ios4-supported-code/"/>
    <updated>2014-05-14T15:26:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/05/14/find-new-api-in-ios4-supported-code</id>
    <content type="html"><![CDATA[<p>　アプリを iOS4.x でも動作させたい場合、Xcode のプロジェクト設定で Deployment Target を "4.x" (4.3とか) に設定します。
一方で Base SDK は最新のものしか選べません、今だと "7.1"。</p>

<!--more-->


<p>　この状態だと、コード中で iOS5以降に追加された API を使っていると、iOS4.x端末では当然クラッシュします。</p>

<p>　Target を 4.x にしてるんだから、クラッシュしそうなコードがあったら Xcode が検出して警告して欲しいんですが、そういう機能はないみたいです。(実はあるのでしょうか？ Android だと警告どころかビルドエラーになるので、iOSアプリ開発は大変不便だな、と思ってしまいます。Obj-C は JavaScript みたいなもんだから仕方がない、のは分かりますが)</p>

<p>　 <a href="http://oclint.org/">OCLint</a> という静的コード解析ツールを見つけましたが、機能をざっと見ても、APIバージョンをチェックするものはなさそうです。（試したことはありません）</p>

<p>　しかし「動かしてみないと分からない」のは不安すぎるので、なんとかして「新しいAPIを使っていないか？」をチェックする方法を考えて、行ってみました。</p>

<h2>新しいAPIを使っている箇所を見つける方法</h2>

<h3>A. iOS Developer Center に API の更新内容がまとめられたページがあります。</h3>

<ul>
<li><a href="https://developer.apple.com/library/ios/releasenotes/General/iOS50APIDiff/index.html#//apple_ref/doc/uid/TP40011042">iOS 4.3 to iOS 5.0 API Differences</a></li>
<li><a href="https://developer.apple.com/LIBRARY/ios/releasenotes/General/iOS60APIDiffs/index.html">iOS 5.1 to iOS 6.0 API Differences</a></li>
<li><a href="https://developer.apple.com/LIBRARY/IOS/releasenotes/General/iOS70APIDiffs/index.html">iOS 6.1 to iOS 7.0 API Differences</a></li>
</ul>


<h3>B. これらのページから「変更のあった API のリスト」を抽出します。</h3>

<p>具体的には以下のようなリストを作ります。</p>

<blockquote><p>Added vImageAlphaBlend_ARGB8888
Added vImageAlphaBlend_ARGBFFFF
…</p></blockquote>

<p>この作業は自動化したいのですが、お試しなので手動でテキストエディタと <strong>EXCEL</strong> を駆使して作成しました。</p>

<h3>C. あとは、自分のソースコードに対して、順次 grep をかけるスクリプトを作ります。</h3>

<p>修正リストの中には、 <code>-[ALAsset setImageData:metadata:completionBlock:]</code> のように名前付き引数だったりする API もあるので、正規表現でなるべくヒットするように置換します。</p>

<p><code>sh find_new_api.sh
grep -nr "ALAsset.*setImageData.*metadata.*completionBlock:.*;" ./src/*
grep -nr "vImageAlphaBlend_ARGB8888.*;" ./src/*
grep -nr "vImageAlphaBlend_ARGBFFFF.*;" ./src/*
…
</code></p>

<h3>D. このスクリプトを実行して何か出たら、そこが「新しいAPIを使ってる箇所」です。</h3>

<h2>まとめ</h2>

<h3>注意点</h3>

<ul>
<li>クラス自体が追加されているものも、メソッドの追加として探しているので、他のクラスと誤認することがあります。</li>
<li>正規表現が完全に正しいかよくわかりません（ソースコードに改行含む場合とか）</li>
</ul>


<p>簡単で、不格好な方法ですが、十分に機能してくれますし、開発者の知識やテストだけに頼るのに比べれば随分と安心できます。</p>

<p>APIの更新情報を JSON か何かで提供してくれたら、もうちょっと楽なんですけども。。。</p>

<p>iOSアプリの開発者のみなさんは、どうやって iOS の下位バージョン互換性を担保しているのでしょうか？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.iOS で FromEventPattern を使うときの注意点]]></title>
    <link href="http://blog.amay077.net/blog/2014/04/03/notice-for-fromeventpattern-in-xamarin-ios/"/>
    <updated>2014-04-03T15:29:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/04/03/notice-for-fromeventpattern-in-xamarin-ios</id>
    <content type="html"><![CDATA[<p>Reactive Extensions の <code>FromEventPattern</code> を使うと、イベントを <code>IObservable</code> に変換できて、複数のイベントに時系列な関係を与えたり、他のストリーム処理とシームレスに扱えたりします。</p>

<!--more-->


<ul>
<li><a href="http://www.atmarkit.co.jp/fdotnet/introrx/introrx_02/introrx_02_02.html">イベント・プログラミングとRx － ＠IT</a></li>
</ul>


<p>Xamarin .iOS でも .Android でもこの機能を使うことができて大変便利ですが、Xamarin.iOS の場合 AOT による制限に気をつける必要があります。</p>

<p>以下は、なんの変哲もない、「ボタンを押したらタイトルを ”Clicked!” に変える」コードです。</p>

<p><code>csharp
MyButton.TouchUpInside += (s, e) =&gt; MyButton.SetTitle("Clicked!", UIControlState.Normal);
</code></p>

<p>これを FromEventPattern を使うとこう書けます。</p>

<p><code>csharp DoesNotWorkOnDevice.cs
Observable.FromEventPattern(MyButton, "TouchUpInside")
.Subscribe(x =&gt; MyButton.SetTitle("Clicked!", UIControlState.Normal));
</code></p>

<p>このコード、iOSシミュレータでは正常に動作しますが、 <strong>実機では、ビルドは通りますが動作しません。</strong> 実行時にこんなエラーがでます。</p>

<blockquote><p>System.InvalidOperationException: Could not find event 'TouchUpInside' on object of type 'MonoTouch.UIKit.UIButton'.</p></blockquote>

<p><code>TouchUpInside</code> が無いと言われます。</p>

<p>これは AOT により生成されたコードに、このイベントが含まれないのだと推測します。イベント名を文字列リテラルで指定しているので、そこまでの解析は期待できないですよね。</p>

<p>シミュレータで動作したのは、この場合は AOT でなく JIT で動作しているため。以下でも言及されています。</p>

<ul>
<li><a href="http://www.buildinsider.net/mobile/insidexamarin/05">Xamarin.iOSの仕組みとアプリケーションの構成 - Build Insider</a></li>
</ul>


<blockquote><p>対象がiOSシミュレーターである場合と、iOSデバイスである場合とで、大きく異なる。iOSシミュレーターは、エミュレーターではなく、あくまでMac OS Xが動作しているx86 CPUの上で動作している仮想マシンであり、アプリケーションはJITによって動作する。iOSデバイスはARMであり、iOSデバイス用にビルドされたアプリケーションはAOTによってARMのCPU命令に変換されており、ARM上でしか動作しない。</p></blockquote>

<p>Xamarin.iOS では実機で動作させないと安心ならないと言われる所以です。</p>

<p>さて、このケースでは、FromEventPattern の別なオーバーロードを使うことで解決です。</p>

<p><code>csharp WorkOnDevice.cs
Observable.FromEventPattern(
  h =&gt; MyButton.TouchUpInside+=h,
  h =&gt; MyButton.TouchUpInside-=h)
.Subscribe(x =&gt; MyButton.SetTitle("Clicked!", UIControlState.Normal));
</code></p>

<p>Xamarin.iOS の制限事項は以下に。</p>

<ul>
<li><a href="http://docs.xamarin.com/guides/ios/advanced_topics/limitations/">Limitations | Xamarin</a></li>
</ul>


<p>これまでこの制限に引っかかった事がなかったのですが、初めて引っかかりました。</p>

<p>メソッドを文字列リテラルで書いた時点で私の負けです、本当にありがとうございました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS アプリでアラート出してボタンが押されるまで待つ？方法を Objective-C と Xamarin.iOS で比べてみた]]></title>
    <link href="http://blog.amay077.net/blog/2014/03/10/using-uialertview-objc-vs-xamarin/"/>
    <updated>2014-03-10T22:09:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/03/10/using-uialertview-objc-vs-xamarin</id>
    <content type="html"><![CDATA[<p>なんか割とニーズがあるみたいで。</p>

<!--more-->


<ul>
<li><a href="http://teapipin.blog10.fc2.com/blog-entry-224.html">【Objective-C】アラート（UIAlertView）でボタンを押すまで次の処理を待つ方法 - creativi.tea</a></li>
<li><a href="http://cocoadays.blogspot.jp/2011/05/ios.html">Cocoaの日々: [iOS] 非同期処理を同期処理に変える</a></li>
<li><a href="http://qiita.com/edo_m18/items/cb1d9061d91e572b58eb">[Objective-C] UIAlertViewを同期処理する - Qiita </a></li>
</ul>


<h2>Objective-C の場合</h2>

<p><code>UIAlertView</code> は、結果を受け取るのが deletgate で、 Objective-C では、(Blocks を使わなければ) 受け取りが別メソッドになってしまう、しかも複数のアラートの結果が同じメソッドに飛んでくるので、tag値で分岐…とかいろいろで、ホントに使うのが面倒ですね。</p>

<p>さらに、「アラートの結果を受け取ってから、次の処理を行う」という処理を素直に記述したいと思うと、上で示したような「アラートを表示して、結果が得られるまで while で待つ」というなんとも不格好なコードになってしまいます。下にも書いてみました。（あ、メンバ変数も使わざるを得ないし。）</p>

<p>```objective-c HogeViewController.m
@implementation HogeViewController {</p>

<pre><code>NSInteger _buttonIndex;
</code></pre>

<p>}</p>

<ul>
<li>(IBAction)buttonTouchUp:(id)sender
{
  UIAlertView *alert = [[UIAlertView alloc] initWithTitle:nil

<pre><code>                          message:NSLocalizedString(@"なにか押して",@"")
                         delegate:self
                cancelButtonTitle:@"Cancel"
                otherButtonTitles:@"OK", nil];
</code></pre>

<p>  [alert show];</p>

<p>  // ボタンが押されるまで待つ
  <em>buttonIndex = -1;
  while (</em>buttonIndex == -1) {</p>

<pre><code>  [[NSRunLoop currentRunLoop]
   runUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.5f]]; // 0.5秒
</code></pre>

<p>  }</p>

<p>  label1.text = [NSString stringWithFormat:@"%d 番目のボタンを押したね", (int)_buttonIndex];
}</p></li>
</ul>


<p>-(void)alertView:(UIAlertView*)alertView clickedButtonAtIndex:(NSInteger)buttonIndex
{</p>

<pre><code>_buttonIndex = buttonIndex;
</code></pre>

<p>}
```</p>

<p><code>[NSRunLoop runUntilDate]</code> なんて VB6 の <code>DoEvents</code> ですもんねなつかしい。</p>

<h2>Xamarin.iOS(C#) の場合</h2>

<p>Objective-C ではややこしかった「アラートを出す→ボタンを押す→次の処理へ」という流れ、 Xamarin.iOS と C# ならこんなにシンプルに書けます。</p>

<p>```csharp HogeViewController.cs
async void OnButtonTouch(object sender, EventArgs e)
{</p>

<pre><code>var buttonIndex = await MsgBox("", "なにか押して", "Cancel", "OK");
label1.Text = buttonIndex.ToString() + "番目を押したね";  
</code></pre>

<p>}</p>

<p>static Task<int> MsgBox(string title, string message,</p>

<pre><code>string cancelButtonTitle, params string[] buttons)
</code></pre>

<p>{</p>

<pre><code>var comp = new TaskCompletionSource&lt;int&gt;();

var alert = new UIAlertView(title, message, null, cancelButtonTitle, buttons);
alert.Clicked += (_, e) =&gt; comp.TrySetResult(e.ButtonIndex);
alert.Show();

return comp.Task;
</code></pre>

<p>}
```</p>

<p>VB6 が懐かしくて <code>MsgBox</code> ってメソッドにしちゃいましたよ。</p>

<p><code>MsgBox</code> は、Task を返す <strong>非同期な</strong> メソッドです。この非同期処理が終了するのは、<code>TaskCompletionSource.TrySetResult</code> が呼び出された時、つまりアラートのボタンが押された時です。この非同期処理の戻り値はもちろん押したボタンのインデックスです。</p>

<p>非同期メソッドである <code>MsgBox</code> を呼び出す側には、キーワード <code>await</code> が付いています。
これをつけると、次行以降の処理は、非同期の MsgBox が完了した後、順次実行されます、つまり待っているわけではなく、どちらかというと、 <strong>処理を後続に付け足す</strong> 感じ。
さらに、この後続処理はUIスレッドで実行されるので、UIパーツへのアクセスも問題ありません。</p>

<p><code>async</code> はメソッド内で <code>await</code> を使うときにつけるお約束。</p>

<p>async/await は一見、ただの同期処理に見えるので理解して使う必要がありますが、Objective-C のコードに比べて、とても簡潔に、流れるように書くことができるのが分かると思います。</p>

<p><strong>C# の非常に強力な言語機能は、<a href="https://xamarin.com/">Xamarin</a> を選択する大きな理由の一つです。</strong></p>

<h2>参考</h2>

<ul>
<li><a href="http://stackoverflow.com/questions/4613071/messagebox-show-and-dialogresult-equivalent-in-monotouch">c# - Messagebox.Show and DialogResult equivalent in MonoTouch - Stack Overflow</a></li>
<li><a href="http://ufcpp.wordpress.com/2012/11/12/asyncawait%e3%81%a8%e5%90%8c%e6%99%82%e5%ae%9f%e8%a1%8c%e5%88%b6%e5%be%a1/">async/awaitと同時実行制御 | ++C++; // 未確認飛行 C ブログ</a></li>
<li><a href="http://www.slideshare.net/bleistift/asyncawait2">async/await不要論</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
