<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c# | Experiments Never Fail]]></title>
  <link href="http://blog.amay077.net/blog/categories/c-number/atom.xml" rel="self"/>
  <link href="http://blog.amay077.net/"/>
  <updated>2014-08-07T00:51:47+09:00</updated>
  <id>http://blog.amay077.net/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Xamarin.Forms、Android での BACK キーの制御]]></title>
    <link href="http://blog.amay077.net/blog/2014/06/17/hooking-back-key-in-xamarin-forms/"/>
    <updated>2014-06-17T01:00:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/06/17/hooking-back-key-in-xamarin-forms</id>
    <content type="html"><![CDATA[<p><a href="http://qiita.com/amay077/items/12979585ac3e2dcacacb">Xamarin.Forms でどうにかしたい iOS と Android の違い</a> の「BACKキーの制御」の <strong>現時点(1.1.0.6201)</strong> での回答。</p>

<!--more-->


<p>Android の BACKキーの制御を、Xamarin.Forms ではどう扱えるかを調べた。</p>

<h2>シナリオ</h2>

<p>Xamarin.Forms による画面１(MainPage)、２(SecondPage)があり、MainPage では BACKキーで戻る(=アプリ終了)事ができるが、SecondPage ではBACKキーが効かない、ようにしたい。</p>

<h2>対策</h2>

<p>まず画面１と２はこんな感じ。ボタンを押したら画面２へ遷移するだけ。</p>

<p>```csharp Pages.cs
// 画面１
public class MainPage : ContentPage
{</p>

<pre><code>public MainPage() 
{
    var button = new Button
    {
        Text = "To Second",
        VerticalOptions = LayoutOptions.Center,
    };

    button.Clicked += (sender, e) =&gt; 
    {
        this.Navigation.PushAsync(new SecondPage());
    };

    Content = button;
}
</code></pre>

<p>}</p>

<p>// 画面２
public class SecondPage : ContentPage
{</p>

<pre><code>public SecondPage()
{
    Content = new Label
    {
        Text = "Second"
    };
}
</code></pre>

<p>}
```</p>

<p>ここからが本題。
まず Android側のエントリポイントである <code>MainActivity.cs</code> は以下のように、<code>ContentPage</code> プロパティを設ける。そして <code>OnBackPressed</code> メソッドを override して、MainPage だったら OnBackPressed を親へ伝搬する。</p>

<p>```csharp MainActivity.cs
[Activity(Label = &ldquo;ScrollTest.Android.Android&rdquo;, MainLauncher = true)]
public class MainActivity : AndroidActivity
{</p>

<pre><code>protected override void OnCreate(Bundle bundle)
{
    base.OnCreate(bundle);

    Xamarin.Forms.Forms.Init(this, bundle);

    SetPage(new NavigationPage(new MainPage()));
}

internal Page ContentPage
{
    get;
    set;
}

public override void OnBackPressed()
{
    if (this.ContentPage is MainPage)
    {
        base.OnBackPressed();
    }
}
</code></pre>

<p>}
```</p>

<p>次に、MainActivity.ContentPage への設定を行うコードは以下の通り。
PageRenderer を拡張して ExportRenderer することで、すべての Page にフックをかけ、Page の表示時に MainActivity.ContentPage に設定する。</p>

<p>```csharp MyPageRenderer.cs
using System;
using Xamarin.Forms.Platform.Android;
using Android.App;
using Xamarin.Forms;
using ScrollTest.Android;
using Android.Views;
using Android.Graphics;</p>

<p>[assembly:ExportRenderer(typeof(ContentPage), typeof(MyPageRenderer))]</p>

<p>namespace ScrollTest.Android
{</p>

<pre><code>public class MyPageRenderer : PageRenderer
{
    protected override void OnElementChanged(ElementChangedEventArgs&lt;Xamarin.Forms.Page&gt; e)
    {
        base.OnElementChanged(e);

        // なんとなく不安なので weak にしてみた
        var activity = new WeakReference&lt;MainActivity&gt;(this.Context as MainActivity);

        e.NewElement.Appearing += (_, __) =&gt;
        {
            MainActivity a;
            if (activity.TryGetTarget(out a)) {
                a.ContentPage = e.NewElement;    
            }
        };
    }
}
</code></pre>

<p>}
```</p>

<p>これで、画面１(MainPage)の時だけ BACKキーが効くようにできる。</p>

<h3><code>Appearing</code> イベントが必要なの？</h3>

<p>　Xamarin.Forms の Android実装では、画面遷移の度に <strong>「同じインスタンスの MainActivity」</strong> が使いまわされる、さらに <code>OnElementChanged</code> は、各Pageにつき１度しか発生しない。その為、画面１→２→１と遷移すると <code>MainActivity.ContentPage</code> は <code>SecondPage</code> のままになってしまう。ので <code>Appearing</code> イベントで表示の度に MainActivity.ContentPage を設定する必要がある。</p>

<h3><code>AndroidActivity</code> に static な <code>BackPressed</code> イベントがあるんだけど…</h3>

<p>イベントハンドラの定義は
<code>public delegate bool BackButtonPressedEventHandler(object sender, EventArgs e);</code>
となっていて、<code>true</code> を返すと BACK キーを無効にできるようなのだけど、<code>sender</code> は <code>MainActivity</code>だし、<code>EventArgs</code> は Page を取得できないしで使えないじゃん。。。</p>

<p>なんだかすごく発展途上な気がする、その内いろいろ整備されそうなので、それまで待った方が良い気がします。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.Forms の Label から iOS の UILabel を取り出す]]></title>
    <link href="http://blog.amay077.net/blog/2014/06/13/convert-xamarin-forms-label-to-native-uilabel/"/>
    <updated>2014-06-13T15:34:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/06/13/convert-xamarin-forms-label-to-native-uilabel</id>
    <content type="html"><![CDATA[<p><a href="http://qiita.com/amay077/items/12979585ac3e2dcacacb">Xamarin.Forms でどうにかしたい iOS と Android の違い</a> の「文字の自動縮小」の自己回答。</p>

<!--more-->


<p>Xamarin.Forms で定義した <code>Label</code> は、iOS では <code>UILabel</code> となるはずなので、その過程のどこかでフックできれば <code>UILabel.AdjustsFontSizeToFitWidth</code> が仕込める、と目論んで、ホントにできたのでメモ。</p>

<h2>要点</h2>

<p><del>Forms→ネイティブのフックは PageRenderer でできる。その中で得られる UIView（のサブクラス）は、Label と UILabel の両方の参照を持っているので、あとは使うだけ。</del></p>

<p><strong>ページでなく、UIパーツレベルでフックできたので、全面的に書き換えた。</strong></p>

<h2>やってみる</h2>

<p>参考にしたのは <a href="https://github.com/xamarin/xamarin-forms-samples/tree/master/Forms2Native">https://github.com/xamarin/xamarin-forms-samples/tree/master/Forms2Native</a> 。</p>

<p>このサンプルをちょっと改造して試した。</p>

<p>まずは Forms側の MySecondPage.cs を修正。</p>

<p>```csharp MySecondPage.cs
public class MySecondPage : ContentPage
{</p>

<pre><code>public Label MyLabel { get; private set; }

public MySecondPage ()
{
    this.MyLabel = new Label
    {
        Text = "Too loooooooooooooooooooooooong label",
        Font = Font.SystemFontOfSize(30d),
        LineBreakMode = LineBreakMode.NoWrap
    };

    Content = new StackLayout
    {
        Orientation = StackOrientation.Vertical,
        VerticalOptions = LayoutOptions.CenterAndExpand,
        Children = 
        {
            this.MyLabel
        }
    };
}
</code></pre>

<p>}
```</p>

<p>ラベルを配置。とても文字が長いので全部は表示しきれない。</p>

<p>次に iOS側に MyLabelRenderer.cs を作成。</p>

<p>```csharp MyLabelRenderer.cs
using System;
using Xamarin.Forms;
using Forms2Native;
using Xamarin.Forms.Platform.iOS;
using MonoTouch.UIKit;</p>

<p>[assembly:ExportRenderer(typeof(Label), typeof(MyLabelRenderer))]</p>

<p>namespace Forms2Native
{</p>

<pre><code>public class MyLabelRenderer : LabelRenderer
{
    protected override void OnElementChanged(ElementChangedEventArgs&lt;Label&gt; e)
    {
        base.OnElementChanged(e);
        this.Control.AdjustsFontSizeToFitWidth = true;
    }
}
</code></pre>

<p>}
```</p>

<p><code>ExportRenderer</code> で「Formsの<code>Label</code>は、<code>MyLabelRenderer</code>を使う」と定義している。
するとすべての <code>Label</code> の生成時を <code>OnElementChanged</code> でフックでき、<code>Control</code> で <code>UILabel</code> は取り出せるので、あとはご自由に、という感じ。</p>

<p>この実装だと、すべての Label に Ajusts が適用されてしまう。個別に行いたい場合は、Forms側に Labelから派生した <code>AjustableLabel</code> を作成して使い、<code>ExportRenderer(typeof(Label),…</code> のところを <code>ExportRenderer(typeof(AjustableLabel),…</code> にすればいけるはず。そしてこの方法はカスタムビューを作る手順に通じる（というかそのもの？）はず。</p>

<p>ちなみにこの <code>OnElementChanged</code> は、Nuget の Xamarin.Formsパッケージの Ver1.1.0.6201から利用できる。</p>

<h2>実行する</h2>

<p>こんな感じで、ちゃんと文字サイズが縮小されました。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/getting_uilabel_from_xamarin_forms.png" alt="" /></p>

<p>Android の方も同じ要領でいけるは…ず。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rx で Chain of Responsibility]]></title>
    <link href="http://blog.amay077.net/blog/2014/05/13/chain-of-resposibility-using-rx/"/>
    <updated>2014-05-13T15:24:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/05/13/chain-of-resposibility-using-rx</id>
    <content type="html"><![CDATA[<p>今さらだけど GoF の Chain of Responsibility パターン。「自分に処理できないタスクは上へ投げる」ってやつ。Reactive な感じでやるとこんな感じかなあと思って書いてみた。</p>

<!--more-->


<p>```csharp
void Main()
{</p>

<pre><code>var document = "有給届";

var kakariCho = CreateManager("係長", document, d =&gt; String.Equals(document, "遅刻届"));
var kaCho = CreateManager("課長", document, d =&gt; String.Equals(document, "有給届"));
var buCho = CreateManager("部長", document, d =&gt; String.Equals(document, "退職届"));

Observable.Concat(new [] { 
    kakariCho,  // 係長
    kaCho,      // 課長
    buCho       // 部長
})
.FirstOrDefault() // 最初の１人に承認されたら終了
.Timeout(TimeSpan.FromDays(1)) // 猶予１日
.Subscribe(x =&gt; Debug.WriteLine(String.IsNullOrEmpty(x) 
    ? "あなたの届書は却下されました" 
    : x + "が承認しました"));
</code></pre>

<p>}</p>

<p>/// 管理職を作成する（役職名、渡された届書、自分に承認できる届書）
IObservable<string> CreateManager(string managerTitle, string document, Predicate<string> canIAccept)
{</p>

<pre><code>return Observable.Create&lt;string&gt;(o =&gt; Task.Run(() =&gt; 
{
    if (canIAccept(document)) 
    {
        o.OnNext(managerTitle); // 承認
    }
    o.OnCompleted();
}));
</code></pre>

<p>}
```</p>

<p>管理職の人を <code>IObservable</code> に見立てて、自分が処理できるなら <code>OnNext</code> を呼ぶ、処理できないなら <code>OnNext</code> は呼ばずに <code>OnComplete</code> しちゃう。
で、係長・課長・部長の IObservable を <code>Concat</code> で役職の低い順につなげて、 <code>FirstOrDefault()</code> で最初の承認がもらえるまで待つ、みたいな。</p>

<p>係長・課長・部長が誰も承認しなかった時、タイムアウトするまで待ちが発生しちゃうのが難点。→ <code>Take(1)</code> じゃなくて <code>FirstOrDefault</code> すればいいみたい。誰も承認しなかった場合 <code>default(string)</code> つまり空文字が流れてくる。</p>

<p>あと、係長→課長→部長と管理職のハンコリレーが必要な場合に対応できていない、Concat なので係長の結果を課長に引き継いでないから。</p>

<p>んーどうしようか。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.iOS で FromEventPattern を使うときの注意点]]></title>
    <link href="http://blog.amay077.net/blog/2014/04/03/notice-for-fromeventpattern-in-xamarin-ios/"/>
    <updated>2014-04-03T15:29:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/04/03/notice-for-fromeventpattern-in-xamarin-ios</id>
    <content type="html"><![CDATA[<p>Reactive Extensions の <code>FromEventPattern</code> を使うと、イベントを <code>IObservable</code> に変換できて、複数のイベントに時系列な関係を与えたり、他のストリーム処理とシームレスに扱えたりします。</p>

<!--more-->


<ul>
<li><a href="http://www.atmarkit.co.jp/fdotnet/introrx/introrx_02/introrx_02_02.html">イベント・プログラミングとRx － ＠IT</a></li>
</ul>


<p>Xamarin .iOS でも .Android でもこの機能を使うことができて大変便利ですが、Xamarin.iOS の場合 AOT による制限に気をつける必要があります。</p>

<p>以下は、なんの変哲もない、「ボタンを押したらタイトルを ”Clicked!” に変える」コードです。</p>

<p><code>csharp
MyButton.TouchUpInside += (s, e) =&gt; MyButton.SetTitle("Clicked!", UIControlState.Normal);
</code></p>

<p>これを FromEventPattern を使うとこう書けます。</p>

<p><code>csharp DoesNotWorkOnDevice.cs
Observable.FromEventPattern(MyButton, "TouchUpInside")
.Subscribe(x =&gt; MyButton.SetTitle("Clicked!", UIControlState.Normal));
</code></p>

<p>このコード、iOSシミュレータでは正常に動作しますが、 <strong>実機では、ビルドは通りますが動作しません。</strong> 実行時にこんなエラーがでます。</p>

<blockquote><p>System.InvalidOperationException: Could not find event &lsquo;TouchUpInside&rsquo; on object of type &lsquo;MonoTouch.UIKit.UIButton&rsquo;.</p></blockquote>

<p><code>TouchUpInside</code> が無いと言われます。</p>

<p>これは AOT により生成されたコードに、このイベントが含まれないのだと推測します。イベント名を文字列リテラルで指定しているので、そこまでの解析は期待できないですよね。</p>

<p>シミュレータで動作したのは、この場合は AOT でなく JIT で動作しているため。以下でも言及されています。</p>

<ul>
<li><a href="http://www.buildinsider.net/mobile/insidexamarin/05">Xamarin.iOSの仕組みとアプリケーションの構成 &ndash; Build Insider</a></li>
</ul>


<blockquote><p>対象がiOSシミュレーターである場合と、iOSデバイスである場合とで、大きく異なる。iOSシミュレーターは、エミュレーターではなく、あくまでMac OS Xが動作しているx86 CPUの上で動作している仮想マシンであり、アプリケーションはJITによって動作する。iOSデバイスはARMであり、iOSデバイス用にビルドされたアプリケーションはAOTによってARMのCPU命令に変換されており、ARM上でしか動作しない。</p></blockquote>

<p>Xamarin.iOS では実機で動作させないと安心ならないと言われる所以です。</p>

<p>さて、このケースでは、FromEventPattern の別なオーバーロードを使うことで解決です。</p>

<p><code>csharp WorkOnDevice.cs
Observable.FromEventPattern(
  h =&gt; MyButton.TouchUpInside+=h,
  h =&gt; MyButton.TouchUpInside-=h)
.Subscribe(x =&gt; MyButton.SetTitle("Clicked!", UIControlState.Normal));
</code></p>

<p>Xamarin.iOS の制限事項は以下に。</p>

<ul>
<li><a href="http://docs.xamarin.com/guides/ios/advanced_topics/limitations/">Limitations | Xamarin</a></li>
</ul>


<p>これまでこの制限に引っかかった事がなかったのですが、初めて引っかかりました。</p>

<p>メソッドを文字列リテラルで書いた時点で私の負けです、本当にありがとうございました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LINQ to Objects と Java8-Stream API の対応表]]></title>
    <link href="http://blog.amay077.net/blog/2014/03/20/linq-to-objects-vs-java8-stream-api/"/>
    <updated>2014-03-20T15:15:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/03/20/linq-to-objects-vs-java8-stream-api</id>
    <content type="html"><![CDATA[<p>Java8 で <code>filter</code> や <code>map</code> が使えるようになったー！
というわけで .NET の LINQ to Objects との対応表を作ってみました。</p>

<!--more-->


<ul>
<li>LINQ &ndash; <a href="http://msdn.microsoft.com/ja-jp/library/system.linq.enumerable(v=vs.110">Enumerable クラス (System.Linq)</a>.aspx)</li>
<li>Java8 &ndash; <a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Stream (Java Platform SE 8 )</a></li>
</ul>


<p>の比較です。</p>

<p>Java の方は</p>

<ul>
<li><a href="http://download.java.net/jdk8/docs/api/java/util/stream/Collectors.html">Collectors (Java Platform SE 8 )</a></li>
</ul>


<p>も使います。</p>

<p>まだ試したものは少ないので間違ってるかもしれない ＆ カテゴライズが適当 なので、編集リクエストしてもらえるとありがたいです。</p>

<table>
<thead>
<tr>
<th></th>
<th> 機能 </th>
<th> LINQ </th>
<th> Java8 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> <strong>【基本的なやつ】</strong> </td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td> 抽出 </td>
<td> Where </td>
<td> filter </td>
</tr>
<tr>
<td></td>
<td> 射影 </td>
<td> Select </td>
<td> map </td>
</tr>
<tr>
<td></td>
<td> 並べ替え </td>
<td> OrderBy / OrderByDescending </td>
<td> sorted </td>
</tr>
<tr>
<td></td>
<td> 後続を並べ替え </td>
<td> ThenBy / ThenByDescending </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> 平坦化して射影 </td>
<td> SelectMany </td>
<td> flatMap </td>
</tr>
<tr>
<td></td>
<td> <strong>【抽出系】</strong> </td>
<td>  </td>
<td>  </td>
</tr>
<tr>
<td></td>
<td> ｎ件飛ばす </td>
<td> Skip </td>
<td> skip </td>
</tr>
<tr>
<td></td>
<td> 条件を満たすまで飛ばす </td>
<td> SkipWhile </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> ｎ件まで流す </td>
<td> Take </td>
<td> limit </td>
</tr>
<tr>
<td></td>
<td> 条件を満たすまで流す </td>
<td> TakeWhile </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> <strong>【合成系】</strong> </td>
<td>  </td>
<td>  </td>
</tr>
<tr>
<td></td>
<td> 連結 </td>
<td> Concat </td>
<td> concat </td>
</tr>
<tr>
<td></td>
<td> 積集合 </td>
<td> Intersect </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> 和集合 </td>
<td> Union </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> 差集合 </td>
<td> Except </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> 内部結合 </td>
<td> Join </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> 外部結合</td>
<td> GroupJoin </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> 並びを逆にする </td>
<td> Reverse </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> 2つの値を揃えて流す </td>
<td> Zip </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> <strong>【グループ化、集計系】</strong> </td>
<td>  </td>
<td>  </td>
</tr>
<tr>
<td></td>
<td> 重複を無くす </td>
<td> Distinct </td>
<td> distinct </td>
</tr>
<tr>
<td></td>
<td> 畳み込み </td>
<td> Aggregate </td>
<td> reduce </td>
</tr>
<tr>
<td></td>
<td> グループ化 </td>
<td> GroupBy </td>
<td> Collectors.groupingBy </td>
</tr>
<tr>
<td></td>
<td> 平均 </td>
<td> Average </td>
<td> IntStream.average /  Collectors.summarizingXXX </td>
</tr>
<tr>
<td></td>
<td> 件数 </td>
<td> Count / LongCount </td>
<td> count </td>
</tr>
<tr>
<td></td>
<td> 最大 </td>
<td> Max </td>
<td> max </td>
</tr>
<tr>
<td></td>
<td> 最小 </td>
<td> Min </td>
<td> min </td>
</tr>
<tr>
<td></td>
<td> 合計 </td>
<td> Sum </td>
<td> IntStream.sum / Collectors.summarizingXXX</td>
</tr>
<tr>
<td></td>
<td> 先頭 </td>
<td> First / FirstOrDefault </td>
<td> findFirst </td>
</tr>
<tr>
<td></td>
<td> 終端 </td>
<td> Last / LastOrDefault </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> とりあえず値を得る </td>
<td> </td>
<td> findAny </td>
</tr>
<tr>
<td></td>
<td> 集計用の汎用関数？ </td>
<td> </td>
<td> collect </td>
</tr>
<tr>
<td></td>
<td> 1件の値を得る </td>
<td> Single / SingleOrDefault </td>
<td> </td>
</tr>
<tr>
<td></td>
<td> 空なら既定値を返す </td>
<td> DefaultIfEmpty </td>
<td> </td>
</tr>
<tr>
<td></td>
<td> 全データが条件にマッチするか？ </td>
<td> All </td>
<td> allMatch </td>
</tr>
<tr>
<td></td>
<td> いずれかのデータが条件にマッチするか？ </td>
<td> Any </td>
<td> anyMatch </td>
</tr>
<tr>
<td></td>
<td> いずれかのデータも条件にマッチしないか？ </td>
<td> </td>
<td> noneMatch </td>
</tr>
<tr>
<td></td>
<td> <strong>【生成系】</strong> </td>
<td>  </td>
<td>  </td>
</tr>
<tr>
<td></td>
<td> 空っぽ </td>
<td> Empty </td>
<td> empty </td>
</tr>
<tr>
<td></td>
<td> 範囲を生成 </td>
<td> Range </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> 繰り返す </td>
<td> Repeat </td>
<td> n/a </td>
</tr>
<tr>
<td></td>
<td> 無限リスト生成 </td>
<td> </td>
<td> generate / iterate </td>
</tr>
<tr>
<td></td>
<td> <strong>【その他】</strong> </td>
<td>  </td>
<td>  </td>
</tr>
<tr>
<td></td>
<td> </td>
<td> SequenceEqual </td>
<td> </td>
</tr>
<tr>
<td></td>
<td> 列挙 </td>
<td> ToList().ForEach </td>
<td> forEach </td>
</tr>
<tr>
<td></td>
<td> なんか Action を挟む(デバッグ用？) </td>
<td> </td>
<td> peek </td>
</tr>
</tbody>
</table>


<p>ううむ、合成系の機能はほとんどないようです…ので自力でやるしか。
以下、サンプル。</p>

<h2>サンプル</h2>

<p>LINQ の方は Mac+Mono(Xamarin) で試しています（ぼそり</p>

<h3>抽出(Where)、並べ替え(OrderBy)、射影(Select)</h3>

<p>0〜9 を、偶数値だけ抽出して、降順にソートして、値を10倍して、出力。</p>

<p><code>csharp C#
Enumerable.Range(0, 10)
  .Where(x =&gt; x % 2 == 0)
  .OrderByDescending(x =&gt; x)
  .Select(x =&gt; x * 10)
  .ToList().ForEach(Console.WriteLine);
</code></p>

<p><code>java Java
Arrays.asList(0,1,2,3,4,5,6,7,8,9).stream()
  .filter(x -&gt; x % 2 == 0)
  .sorted((x, y) -&gt; y - x)
  .map(x -&gt; x * 10)
  .forEach(System.out::println);
</code></p>

<p><code>
80 60 40 20 0
</code></p>

<h3>平坦化して射影(SelectMany)</h3>

<p>1〜5のリストから、「n×10から始まるn件」のリストを生成。(結果見たほうが分かりやすいな（^_^;)</p>

<p><code>csharp C#
Enumerable.Range(1, 5)
  .SelectMany(x =&gt; Enumerable.Range(10 * x, x))
  .ToList().ForEach(Console.WriteLine);
</code></p>

<p><code>java Java
Arrays.asList(1,2,3,4,5).stream()
  .flatMap(x -&gt; IntStream.range(x * 10, x * 10 + x).boxed())
  .forEach(System.out::println);
</code></p>

<p><code>
10
20 21
30 31 32
40 41 42 43
50 51 52 53 54
</code></p>

<h3>抽出系(Take, Skip)</h3>

<p>1〜10のリストの3件飛ばして、5件取得。</p>

<p><code>csharp C#
Enumerable.Range(1, 10)
  .Skip(3)
  .Take(5)
  .ToList().ForEach(Console.WriteLine);
</code></p>

<p><code>java Java
// 無限リストでも limit あるから大丈夫
Stream.iterate(1, x-&gt; x++)
  .skip(3)
  .limit(5)
  .forEach(System.out::println);
</code></p>

<p><code>
4 5 6 7 8
</code></p>

<p>LINQ には件数でなく条件を指定できる <code>TakeWhile</code> <code>SkipWhile</code> がありますが、Java にはなさそうなので <code>filter</code> で代用しないといけなさそう。</p>

<p><code>csharp C#
Enumerable.Range(1, 10)
  .SkipWhile(x =&gt; x &lt; 4)
  .TakeWhile(x =&gt; x &lt; 9)
  .ToList().ForEach(Console.WriteLine);
</code></p>

<h3>連結(Concat)</h3>

<p>2つのリストをつなげる</p>

<p><code>csharp C#
new int[] { 1, 2, 3 }.Concat(new int[]{ 30, 20, 10 })
.ToList().ForEach(Console.WriteLine);
</code></p>

<p><code>java Java
Stream.concat(
  Arrays.asList(1,2,3).stream(),
  Arrays.asList(30,20,10).stream())
.forEach(System.out::println);
</code></p>

<p>なんで static メソッドやねん…。</p>

<p><code>
1 2 3 30 20 10
</code></p>

<h3>積集合(Intersect)、和集合(Union)、差集合(Except)</h3>

<p>積集合：2つのリストから重複をなくす。
和集合：2つのリストをマージする。
差集合：リスト1を基準にリスト2との差分を得る。</p>

<p>```csharp C#
var list1 = new int[]{1,2,3,4,5,6};
var list2 = new int[]{8,7,6,5,4};</p>

<p>list1.Intersect(list2)
  .ToList().ForEach(Console.WriteLine);</p>

<p>list1.Union(list2)
  .ToList().ForEach(Console.WriteLine);</p>

<p>list1.Except(list2)
  .ToList().ForEach(Console.WriteLine);
```</p>

<p>```java Java
// 自力で実現かよｗ
list1.stream().filter(x &ndash;> list2.stream().anyMatch(y &ndash;> y == x))
  .forEach(System.out::println);</p>

<p>Stream.concat(list1.stream(),
  list2.stream().filter(x &ndash;> list1.stream().noneMatch(y &ndash;> y == x)))
  .forEach(System.out::println);</p>

<p>list1.stream().filter(x &ndash;> list2.stream().noneMatch(y &ndash;> y == x))
  .forEach(System.out::println);
```</p>

<p><code>
4 5 6 // 積
1 2 3 4 5 6 8 7 // 和
1 2 3 // 差
</code></p>

<h3>内部結合(Join)</h3>

<p>商品マスタと売上テーブルを INNER JOIN する的な。</p>

<p>```csharp C#
var master = new [] {</p>

<pre><code>new { Id = 1, Name = "Apple" },
new { Id = 2, Name = "Grape" }
</code></pre>

<p>};</p>

<p>var sales = new [] {</p>

<pre><code>new { Id = 1, Sales = 100 },
new { Id = 2, Sales = 200 },
new { Id = 2, Sales = 300 },
new { Id = 3, Sales = 400 },
</code></pre>

<p>};</p>

<p>master.Join(sales,
  outer=>outer.Id,
  inner=>inner.Id,
  (o, i) => new { o.Name, i.Sales })
.ToList().ForEach(Console.WriteLine);
```</p>

<p>```java Java
// 自力
List&lt;Pair&lt;Integer, String>> master = Arrays.asList(
  new Pair&lt;>(1, &ldquo;Apple&rdquo;),
  new Pair&lt;>(2, &ldquo;Grape&rdquo;)
);</p>

<p>List&lt;Pair&lt;Integer, Integer>> sales = Arrays.asList(
  new Pair&lt;>(1, 100),
  new Pair&lt;>(2, 200),
  new Pair&lt;>(2, 300),
  new Pair&lt;>(3, 400)
);</p>

<p>master.stream()
  .flatMap(outer &ndash;> sales.stream()</p>

<pre><code>.filter(inner -&gt; outer.getKey() == inner.getKey())
.map(z-&gt; new Pair&lt;String, Integer&gt;(outer.getValue(), z.getValue())))
</code></pre>

<p>  .forEach(System.out::println);
```</p>

<p><code>
{ Name = Apple, Sales = 100 }
{ Name = Grape, Sales = 200 }
{ Name = Grape, Sales = 300 }
</code></p>

<h3>外部結合(GroupJoin)</h3>

<p>商品マスタと売上テーブルを OUTER JOIN する的な。結合先のテーブルに行が見つからなかったものは null になる。</p>

<p>```csharp C#
var master = new [] {</p>

<pre><code>new { Id = 1, Name = "Apple" },
new { Id = 2, Name = "Grape" },
new { Id = 5, Name = "Orange" },
</code></pre>

<p>};</p>

<p>var sales = new [] {  // Orange は無い</p>

<pre><code>new { Id = 1, Sales = 100},
new { Id = 2, Sales = 200},
new { Id = 3, Sales = 400},
</code></pre>

<p>};</p>

<p>master.GroupJoin(sales,
  outer=>outer.Id,
  inner=>inner.Id,
  (o, i) => new { o.Name, FirstOfSales = i.Select(</p>

<pre><code>x=&gt;(int?)x.Sales).FirstOrDefault() }) // 無かったら null にしたいので null許容型にしてから FirstOrDefault
</code></pre>

<p>.ToList().ForEach(Console.WriteLine);
```</p>

<p>たぶん普通は First じゃなくて Sum とか使うんだろう。</p>

<p>```java Java
// これも自力
List&lt;Pair&lt;Integer, String>> master = Arrays.asList(
  new Pair&lt;>(1, &ldquo;Apple&rdquo;),
  new Pair&lt;>(2, &ldquo;Grape&rdquo;),
  new Pair&lt;>(5, &ldquo;Orange&rdquo;)
);</p>

<p>List&lt;Pair&lt;Integer, Integer>> sales = Arrays.asList(
  new Pair&lt;>(1, 100),
  new Pair&lt;>(2, 200),
  new Pair&lt;>(2, 300),
  new Pair&lt;>(3, 400)
);</p>

<p>master.stream().map(outer->new Pair&lt;String, Optional<Integer>>(outer.getValue(),
  sales.stream()</p>

<pre><code>.filter(inner-&gt;inner.getKey() == outer.getKey()) // Id でフィルタ
  .map(x-&gt;x.getValue()) // Sales だけに射影
  .findFirst())) // 同一Id中の先頭
</code></pre>

<p>  .forEach(System.out::println);
```</p>

<p>```
[.NET]
{ Name = Apple, FirstOfSales = 100 }
{ Name = Grape, FirstOfSales = 200 }
{ Name = Orange, FirstOfSales = } // 相手が居ないやつは null になる</p>

<p>[Java]
Apple=Optional[100]
Grape=Optional[200]
Orange=Optional.empty // Option だから empty になるのは良い
```</p>

<h3>2つの値を揃えて流す(Zip)</h3>

<p>２つのリストの値をひとつずつセットにして流す。</p>

<p>```csharp C#
var arr1 = new int[] { 1, 2, 3, 4, 5 };
var arr2 = new string[] { &ldquo;hoge&rdquo;, &ldquo;fuga&rdquo;, &ldquo;piyo&rdquo; };</p>

<p>arr1.Zip(arr2, (x, y) =>  new {x, y})</p>

<pre><code>.ToList()
.ForEach(Console.WriteLine);
</code></pre>

<p>```</p>

<p><code>java Java
// FIXME どうやるの？ Streams.zip はどこいった？
</code></p>

<p><code>
{ x = 1, y = hoge }
{ x = 2, y = fuga }
{ x = 3, y = piyo }
</code></p>

<h3>重複を無くす(Distinct)</h3>

<p>重複する数値リストから重複をなくす。</p>

<p><code>csharp C#
new int[]{1,3,4,3,2,4}
  .Distinct()
  .ToList().ForEach(Console.WriteLine);
</code></p>

<p><code>java Java
Arrays.asList(1,3,4,3,2,4).stream()
  .distinct()
  .forEach(System.out::println);
</code></p>

<p><code>
1 3 4 2
</code></p>

<h3>畳み込み</h3>

<p>いろいろな集計の素、畳み込み。言語により fold とか reduce とか aggregate とか、いろいろな呼び名がありますね。
よい例が浮かなかったので Max を実装してみました。</p>

<p>```csharp C#
var max = new int[]{1,5,3,7,2,4}</p>

<pre><code>.Aggregate(Int32.MinValue, (x, y) =&gt; Math.Max(x, y));
</code></pre>

<p>Console.WriteLine(max);
```</p>

<p><code>java Java
int max = Arrays.asList(1,5,3,7,2,4).stream()
  .reduce(Integer.MIN_VALUE, (x, y) -&gt; Math.max(x, y));
System.out.println(max);
</code></p>

<p><code>
7
</code></p>

<h3>グループ化</h3>

<p>リストの要素をキーにしてグループ化する。Salesは合計を計算する。</p>

<p>```csharp C#
var sales = new [] {</p>

<pre><code>new { Id = 1, Sales = 100 },
new { Id = 2, Sales = 200 },
new { Id = 2, Sales = 300 },
new { Id = 3, Sales = 400 },
</code></pre>

<p>};</p>

<p>sales.GroupBy(x=>x.Id, (Id, groupedSales) => new {Id,</p>

<pre><code>SumOfSales = groupedSales.Sum( element =&gt; element.Sales) // Sales は合計する
</code></pre>

<p>  })
  .ToList().ForEach(Console.WriteLine);
```</p>

<p>（LINQ ではありませんが、 <code>List.LookUp</code> を使って実現することもできるようです → <a href="http://qiita.com/amay077/items/9d2941283c4a5f61f302#comment-82388821b902ad7999b0">コメント:2014/03/22 00:29</a>）</p>

<p>```java Java
// javafx に Pair があったので Tuple 代わりに使っちゃった
List&lt;Pair&lt;Integer, Integer>> list1 = Arrays.asList(
  new Pair&lt;>(1, 100),
  new Pair&lt;>(2, 200),
  new Pair&lt;>(2, 300),
  new Pair&lt;>(3, 400)
);</p>

<p>list1.stream().collect(Collectors.groupingBy(x &ndash;> x.getKey()))
  .entrySet().stream() // group化の結果が Map なので、エントリを Stream 化
  .map(x &ndash;> new Pair&lt;Integer, Integer>(</p>

<pre><code>x.getKey(), // Key が Id に相当
x.getValue().stream().collect(Collectors.summingInt(y-&gt;y.getValue())))) // Value が List なのでまた Stream 化して合計を得る
</code></pre>

<p>  .forEach(System.out::println);</p>

<p>// Collectors.groupingBy 使わずに Map.merge を使ったほうが分かりやすい気も。。。
list1.stream().collect(
  () &ndash;> new HashMap&lt;Integer, Integer>(),
  (map, item) &ndash;> map.merge(item.getKey(), item.getValue(), (x, y) &ndash;> x + y), // 同じキーの値を加算してく
  (left, right) &ndash;> left.putAll(right))
  .forEach((k, v) &ndash;> System.out.println(k + &ldquo;:&rdquo; + v));
```</p>

<p>Java の方、カオスすぎる…。.NET の <code>IGrouping</code> を Map でやってるからだな。</p>

<p>```
[.NET]
{ Id = 1, SumOfSales = 100 }
{ Id = 2, SumOfSales = 500 } // ID=2 の Sales が合計されている
{ Id = 3, SumOfSales = 400 }</p>

<p>[Java]
1=100
2=500
3=400
```</p>

<h3>合計(Sum)、最大(Max)、最小(Min)、平均(Average)、件数(Count)、先頭(First)、終端(Last)</h3>

<p>集計いろいろ。</p>

<p><code>csharp C#
var list1 = Enumerable.Range(0, 10);
Console.WriteLine("Sum={0}", list1.Sum());
Console.WriteLine("Max={0}", list1.Max());
Console.WriteLine("Min={0}", list1.Min());
Console.WriteLine("Count={0}", list1.Count());
Console.WriteLine("First={0}", list1.First());
Console.WriteLine("Last={0}", list1.Last());
Console.WriteLine("Average={0}", list1.Average());
</code></p>

<p>```java Java
List<Integer> list1 = Arrays.asList(0,1,2,3,4,5,6,7,8,9);
IntSummaryStatistics stats = list1.stream().collect(Collectors.summarizingInt(x &ndash;> x)); // Max,Min,Count,Average が取得できる
System.out.println(&ldquo;Sum=&rdquo; + stats.getSum());
System.out.println(&ldquo;Max=&rdquo; + stats.getMax());
System.out.println(&ldquo;Min=&rdquo; + stats.getMin());
System.out.println(&ldquo;Count=&rdquo; + stats.getCount());
System.out.println(&ldquo;First=&rdquo; + list1.stream().findFirst().orElse(-1)); // summarizing では取れない
System.out.println(&ldquo;Last=&rdquo; + list1.stream().sorted((x,y) &ndash;> y-x).findFirst().orElse(-1)); // 微妙
System.out.println(&ldquo;Average=&rdquo; + stats.getAverage());</p>

<p>System.out.println(&ldquo;Average=&rdquo; + IntStream.range(0, 10).average()); // 型指定 Stream なら average, sum がある（結果は Option に包まれる）
```</p>

<p><code>
Sum=45
Max=9
Min=0
Count=10
First=0
Last=9
Average=4.5
</code></p>

<p>…疲れた。。。</p>
]]></content>
  </entry>
  
</feed>
