<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c# | Experiments Never Fail]]></title>
  <link href="http://blog.amay077.net/blog/categories/c-number/atom.xml" rel="self"/>
  <link href="http://blog.amay077.net/"/>
  <updated>2016-10-29T11:32:01+09:00</updated>
  <id>http://blog.amay077.net/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[DroidKaigi2017 に Xamarin ネタでトーク応募したよ]]></title>
    <link href="http://blog.amay077.net/blog/2016/10/25/submit-cfp-for-droidkaigi2017/"/>
    <updated>2016-10-25T02:42:51+09:00</updated>
    <id>http://blog.amay077.net/blog/2016/10/25/submit-cfp-for-droidkaigi2017</id>
    <content type="html"><![CDATA[<p>神からの啓示がありまして、 <a href="https://droidkaigi.github.io/2017/">DroidKaigi2017</a> のトークに応募しました。</p>

<!--more-->


<p>昨年 DroidKaigi2016 を聞きにいきました。 Kotlin、Go Mobile のセッションがありました。</p>

<p>当時 Xamarin はまだプロプライエタリな有償の製品でした。今はほとんどオープンソースのプロダクトです。</p>

<p>これはワンチャンあるで！</p>

<p>応募内容は以下です。「○○界隈」いうのがあまり好きではないので、そういうのにこだわらない話をしたいと思っています。</p>

<hr />

<h2>Title</h2>

<p>Xamarin.Android で始めるクロスプラットフォームモバイルアプリ開発</p>

<h2>Abstract</h2>

<h3>対象者</h3>

<ul>
<li>Android中級者〜</li>
<li>C# 初心者〜</li>
</ul>


<h3>概要</h3>

<p>Xamarin（ざまりん）は C# によるクロスプラットフォームモバイルアプリ開発ツールです。
Microsoft が2016年4月に買収して、一気に知名度が上がりました。</p>

<p>このセッションでは、 Xamarin とは、Xamarin.Android とは何か、C# や .NET Framework(Mono) の強力な言語・ライブラリ機能について触れ、通常の Android アプリ開発と Xamarin を使ったアプリ開発はどこが違って、どこが同じなのかを説明します。</p>

<p>また、今日のモバイルアプリ開発では、DataBinding、MVVM、Reactive Extensions(Rx) といった、Microsoft が源流となっている手法が広まって来ています。
Xamarin を使うと、MVVMパターンと Rx を使用し、大部分のコードを共有できる Android/iOS 両対応アプリケーションを開発できます。如何にしてコードを共有するか、できない場合にどのような解決策が用意されているかについてお話します。</p>

<h3>目次（仮）</h3>

<h4>1. Xamarin とは？</h4>

<ul>
<li>Xamarin とは何か</li>
<li>Xamarin.Android とは何か</li>
<li>C# の利点(Java, Swift との比較)</li>
</ul>


<h4>2. クロスプラットフォームアプリ開発とコードの共有</h4>

<ul>
<li>MVVMパターン</li>
<li>Reactive Extensions / ReactiveProperty</li>
<li>Portable Class Library(PCL)によるコード共有</li>
<li>プラットフォーム固有の処理を行う方法</li>
</ul>


<h4>3. Open Xamarin、Open Microsoft</h4>

<ul>
<li>Xamarin で使えるライブラリ(C#, Java)</li>
<li>All Xamarin SDKs are open source</li>
<li>.NET Standard</li>
</ul>


<h4>4. Xamarin の使いどころ</h4>

<ul>
<li>採用すべきケースとしなくてよいケース</li>
</ul>


<h2>Topic</h2>

<p>開発環境・ツール (Productivity and Tooling)</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.iOS でインターネット通信が可能かを取得する]]></title>
    <link href="http://blog.amay077.net/blog/2016/08/26/ger_is_network_available_on_xamarin_ios/"/>
    <updated>2016-08-26T23:59:59+09:00</updated>
    <id>http://blog.amay077.net/blog/2016/08/26/ger_is_network_available_on_xamarin_ios</id>
    <content type="html"><![CDATA[<p>Xamarin.iOS で、「端末からインターネット通信が可能か？」を調べたい。</p>

<!--more-->


<p>Objective-C だと <a href="https://github.com/tonymillion/Reachability">Reachability</a>、swift だと <a href="https://github.com/ashleymills/Reachability.swift">Reachability.swift</a> を使うようだけど、 Xamarin.iOS ではどうするか？</p>

<ul>
<li><a href="http://d.hatena.ne.jp/scientre/20150527/get_network_status_in_swift">Swift でネットワーク状況を調べる &ndash; メモ用紙</a></li>
</ul>


<p>Bindingライブラリがあるのかな？と思ったら、サンプルで C# のソースコードが提供されていた。</p>

<ul>
<li><a href="https://developer.xamarin.com/recipes/ios/network/reachability/detect_if_network_is_available/">Detect if Network is Available &ndash; Xamarin</a></li>
</ul>


<p>の <a href="https://github.com/xamarin/monotouch-samples/blob/master/ReachabilitySample/reachability.cs"><code>reachability.cs</code></a> がそれ。
（名前から察して Reachability.swift を C# で書きなおしたもの？詳しくは見てないけど。）</p>

<p>で、このサンプルの <code>Reachability</code> を使うと、以下のような感じで、「インターネット通信が可能か？」を調べられる。</p>

<p>```csharp
public bool IsNetworkAvailable
{</p>

<pre><code>get
{
    return Reachability.InternetConnectionStatus() != NetworkStatus.NotReachable;
}
</code></pre>

<p>}
```</p>

<p>WiFi とかセルラーとか細かいステータスもあるので、あとはコードを見てください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NavigationPage + MasterDetailPage の時に iOS の NavigationBar の左ボタンをカスタマイズする]]></title>
    <link href="http://blog.amay077.net/blog/2016/07/22/customizing_left_button_on_%20NavigationBar_in_using_navigationpage_with_masterdetailpage/"/>
    <updated>2016-07-22T23:59:59+09:00</updated>
    <id>http://blog.amay077.net/blog/2016/07/22/customizing_left_button_on_ NavigationBar_in_using_navigationpage_with_masterdetailpage</id>
    <content type="html"><![CDATA[<p>Xamarin.Forms では、左からスライドして出てくるメニューを持つ画面を <code>MasterDetailPage</code> で作成します。</p>

<!--more-->


<ul>
<li><a href="https://developer.xamarin.com/guides/xamarin-forms/user-interface/navigation/master-detail-page/">Master-Detail Page &ndash; Xamarin</a></li>
</ul>


<p>一方、普通に画面遷移していく場合は ContentPage などを <code>NavigationPage</code> でラップしてあげます。</p>

<ul>
<li><a href="https://developer.xamarin.com/guides/xamarin-forms/user-interface/navigation/hierarchical/">Hierarchical Navigation &ndash; Xamarin</a></li>
</ul>


<h2>やりたいこと</h2>

<p>何がしたいかというと、両者を組み合わせたいんです。こういうことってよくありませんかね？</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/customizing_left_navvigationbar_button_in_masterdetail_with_navigation_pages_01.png" alt="" /></p>

<p>起動画面で「新規ユーザー登録」があって、「ユーザー登録画面」を経て、メインの画面に遷移する、メイン画面にはスライドメニューがある、というパターン。これを Xamarin.Forms でやりたいのです。</p>

<h2>問題</h2>

<p>ところが、 <code>NavigationPage</code> で遷移していく画面の中に <code>MasterDetailPage</code> があると、 <code>NavigationPage</code> の方が勝ってしまい、ナビゲーションバーには「BACK」ボタンが表示されてしまいます。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/customizing_left_navvigationbar_button_in_masterdetail_with_navigation_pages_02.png" alt="" /></p>

<p>これを消そうと、<code>MasterDetailPage</code> のコンストラクタで <code>NavigationPage.SetHasBackButton(this, false)</code> してみます。</p>

<p>その結果がこれ。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/customizing_left_navvigationbar_button_in_masterdetail_with_navigation_pages_03.png" alt="" /></p>

<p>Android の方は望む結果になったけど、iOSの方はうーん…、BACKボタンは消えたけど、メニューを表示させるボタンが出ません。</p>

<p>しょうがないので、iOS の場合だけ、ナビゲーションバーの左ボタンをどうにかして追加してみます。</p>

<h2>私が求めていたソリューション（CustomRenderer編）</h2>

<p>Xamarin.Forms のお供、CustomRenderer です。</p>

<ul>
<li><a href="https://developer.xamarin.com/guides/xamarin-forms/custom-renderer/">Customizing Controls on Each Platform &ndash; Xamarin</a></li>
<li><a href="http://ticktack.hatenablog.jp/entry/2016/06/11/124751">【Xamarin.Forms】ViewRendererと仲良くなるための簡易チュートリアル &ndash; ぴーさんログ</a></li>
</ul>


<p><code>MasterDetailPage</code> の iOS向けCustomRenderer を作って、ネイティブ側でナビゲーションバーをカスタマイズしてみます。</p>

<p>```csharp CustomMasterDetailRenderer.cs
using System;
using MasterDetail.iOS;
using MonoTouch.UIKit;
using Xamarin.Forms;
using Xamarin.Forms.Platform.iOS;</p>

<p>[assembly: ExportRenderer(typeof(MasterDetailPage), typeof(CustomMasterDetailRenderer))]
namespace MasterDetail.iOS
{</p>

<pre><code>public class CustomMasterDetailRenderer : PhoneMasterDetailRenderer
{
    public override void ViewWillAppear(bool animated)
    {
        base.ViewWillAppear(animated);

        var page = Element as MasterDetailPage;

        var navigationItem = this.NavigationController.TopViewController.NavigationItem;
        navigationItem.LeftBarButtonItems = new UIBarButtonItem[]
        {
            new UIBarButtonItem("MENU", UIBarButtonItemStyle.Plain, (_, __) =&gt; 
            { 
                page.IsPresented = !page.IsPresented; 
            })
        };
    }
}
</code></pre>

<p>}
```
「MENU」ってボタンを、ナビゲーションバーの左側に追加しています。
こんな CustomRenderer を iOS 側のプロジェクトに追加して実行してみます。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/customizing_left_navvigationbar_button_in_masterdetail_with_navigation_pages_04.png" alt="" /></p>

<p>オーケーオーケー、これが私が求めていたソリューションです。</p>

<h2>私が求めていたソリューション（Effects編）</h2>

<p>が、CustomRenderer にはいくつか考えなければならないことがあります。</p>

<ul>
<li>上で作った <code>CustomMasterDetailRenderer.cs</code> は <code>PhoneMasterDetailRenderer</code> というクラスを継承しています。が、実はこれは iPhone 用で、実はタブレット（iPad）用に <code>TabletMasterDetailRenderer</code> というクラスもあります。これの CustomRenderer も用意しなければなりませんか？</li>
<li>CustomRenderer はベースとなる ViewRenderer を「継承」して作ります。そして C# は多重継承を許していません、この意味が分かるな？別の機能を拡張したいと思ったら<code>CustomMasterDetailRenderer</code>から派生させるしかなくなります。</li>
</ul>


<p>で、 Xamarin.Forms には、v2.1 から既存機能の拡張に Effects という選択肢が加わりました。</p>

<ul>
<li><a href="https://developer.xamarin.com/guides/xamarin-forms/effects/">Customizing Controls with Effects &ndash; Xamarin</a></li>
<li><a href="http://ticktack.hatenablog.jp/entry/2016/01/26/020248">【Xamarin.Forms 2.1.0(プレビュー)】Effects &ndash; ぴーさんログ</a></li>
</ul>


<p>では、<code>CustomMasterDetailRenderer.cs</code> を Effects に変えてみましょう。</p>

<p>```csharp CustomMasterDetailEffect.cs
using System;
using MasterDetail.iOS;
using MonoTouch.UIKit;
using Xamarin.Forms;
using Xamarin.Forms.Platform.iOS;</p>

<p>[assembly: ResolutionGroupName(&ldquo;mycompany&rdquo;)]
[assembly: ExportEffect(typeof(CustomMasterDetailEffect), &ldquo;CustomMasterDetailEffect&rdquo;)]
namespace MasterDetail.iOS
{</p>

<pre><code>public class CustomMasterDetailEffect : PlatformEffect
{
    protected override void OnAttached()
    {
        var page = Element as MasterDetailPage;
        page.Appearing += Page_Appearing;
    }

    protected override void OnDetached()
    {
        var page = Element as MasterDetailPage;
        page.Appearing -= Page_Appearing;
    }

    void Page_Appearing(object sender, EventArgs e)
    {
        var vc = GetParentViewController();
        var page = Element as MasterDetailPage;

        var navigationItem = vc.NavigationController.TopViewController.NavigationItem;
        navigationItem.LeftBarButtonItems = new UIBarButtonItem[]
        {
            new UIBarButtonItem("MENU", UIBarButtonItemStyle.Plain, (_, __) =&gt; 
            { 
                page.IsPresented = !page.IsPresented; 
            })
        };
    }

    UIViewController GetParentViewController()
    {
        UIResponder responder = this.Container;
        while ((responder = responder.NextResponder) != null)
        {
            if (responder is UIViewController)
            {
                return (UIViewController)responder;
            }
        }
        return null;
    }
}
</code></pre>

<p>}
```</p>

<p>Effect は、 <code>ResolutionGroupName</code> と <code>ExportEffect</code> で定義した名称を使って、PCL側プロジェクトで Page に追加します。</p>

<p>```csharp RootPage.cs
public class RootPage : MasterDetailPage
{</p>

<pre><code>public RootPage ()
{
    NavigationPage.SetHasBackButton(this, false);
    // Effect を追加する
    Effects.Add(Effect.Resolve("mycompany.CustomMasterDetailEffect"));

    // 以下省略
</code></pre>

<p>```</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/customizing_left_navvigationbar_button_in_masterdetail_with_navigation_pages_05.png" alt="" /></p>

<p>こちらも、CustomRenderer と同じことができました。</p>

<p>が、ちょっと黒魔術っぽいの使ってます。</p>

<ul>
<li><code>Effects.Container</code> から取得できるのは <code>UIView</code> です。親の <code>UIViewController</code> を得るには、 <code>GetParentViewController()</code> でやってるような事をしなければなりません</li>
<li>CustomRenderer はそれ自体は <code>ViewController</code> だったので <code>ViewWillAppear()</code> など画面のライフサイクルコールバックを override することができました。が、Effects から ViewController のライフサイクルイベントをハンドリングできません。代わりに Xamarin.Forms 側の <code>Page</code> のライフサイクルから <code>Appearing</code> イベントで処理するようにしています。そのため、「MENU」ボタンが表示されるタイミングが若干遅れます。</li>
</ul>


<h2>CustomRenderer と Effects 、どちらを使えばいいの？</h2>

<ul>
<li>CustomRenderer はできる事は多いが、複数の CustomRenderer を適用することはできない</li>
<li>Effects はできる事は少ないが、複数の機能拡張を同時に適用できる</li>
</ul>


<p>以上を考えると、</p>

<ol>
<li>まずあなたの行いたいことが Effects で実現できないか、試してみる</li>
<li>Effects でできないレベルなら CustomRenderer を選択する</li>
</ol>


<p>となるでしょう。</p>

<p>本件のネタは、 Effects ではかなりムリをして実現しているので、CustomRenderer の方が相応しいと思われます。
が、CustomRenderer はここぞという時にとっておきたい気もします。
このさじ加減は、作るアプリの規模・深度、汎用性、再利用性などによって変わってくるでしょう。Effects の方が汎用性・再利用性は高いですが、ネイティブのUIパーツをごっそり入れ替えるような深い事は、CustomRenderer でなければできません。</p>

<p>今回のプログラムは Github に上げてあります。（<code>CustomMasterDetailRenderer.cs</code> はコメントアウトしてあって、Effects の方を活かしてます。）</p>

<ul>
<li><a href="https://github.com/amay077/XFNavigationWithMasterDetailSample/blob/master/README.md">XFNavigationWithMasterDetailSample/README.md at master · amay077/XFNavigationWithMasterDetailSample</a></li>
</ul>


<p>私は「Effects で頑張りたい派」かな。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[非同期処理の書き方を Java と Swift と Xamarin で比較する]]></title>
    <link href="http://blog.amay077.net/blog/2016/07/19/comparison_async_logic_with_java_swift_xamarin/"/>
    <updated>2016-07-19T23:59:59+09:00</updated>
    <id>http://blog.amay077.net/blog/2016/07/19/comparison_async_logic_with_java_swift_xamarin</id>
    <content type="html"><![CDATA[<p>「重たい処理を非同期で実行して、結果をメインスレッドで画面に表示」を、</p>

<!--more-->


<ul>
<li>Android-Java</li>
<li>iOS-Swift</li>
<li>Xamarin(Android も iOS も同じ)</li>
</ul>


<p>で比較。</p>

<hr />

<h2>Android</h2>

<p>```java
@Override
public void onClick(View view) {</p>

<pre><code>new AsyncTask&lt;Void, Void, Long&gt;() {
    @Override
    protected Long doInBackground(Void[] p) {
        // ワーカースレッド
        long ret = 0;
        for (long i = 0; i &lt; 1000000000; i++)
            ret += i;
        return ret;
    }

    @Override
    protected void onPostExecute(Long result) {
        // UIスレッド
        text1.setText(String.valueOf(result));
    }
}.execute((Void)null);
</code></pre>

<p>}
```</p>

<hr />

<h2>Swift</h2>

<p>```java
@IBAction func onTouchUpInside(sender: AnyObject) {</p>

<pre><code>weak var weakSelf = self
dispatch_async(dispatch_get_global_queue(
    DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), {
    // ワーカースレッド
    var ret:Int = 0
    for i in 0...1000000000 {
        ret += i
    }

    dispatch_async(dispatch_get_main_queue(), {
        // UIスレッド
        weakSelf?.label1.text = String(ret)
    });
});
</code></pre>

<p>}
```</p>

<hr />

<h2>Xamarin(Android も iOS も)</h2>

<p>```csharp
Task<long> FatProc() => Task.Run<long>(() => {</p>

<pre><code>long ret = 0;
for (long i = 0; i &lt; 1000000000; i++)
    ret += i;
return ret;
</code></pre>

<p>});</p>

<p>button1.TouchUpInside += async (_, e) => {</p>

<pre><code>var ret = await FatProc(); // ワーカースレッド
label1.Text = ret.ToString(); // UIスレッド
</code></pre>

<p>};
```</p>

<hr />

<h2>Xamarin はいいぞ！</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ボタンをタップした時に○○する、を Java と Swift と Xamarin で比較する]]></title>
    <link href="http://blog.amay077.net/blog/2016/07/15/comparison_on_click_with_java_swift_xamarin/"/>
    <updated>2016-07-15T23:59:59+09:00</updated>
    <id>http://blog.amay077.net/blog/2016/07/15/comparison_on_click_with_java_swift_xamarin</id>
    <content type="html"><![CDATA[<p>たぶん一番書くやつを</p>

<!--more-->


<ul>
<li>Android-Java</li>
<li>Android-Xamarin</li>
<li>iOS-Swift</li>
<li>iOS-Xamarin</li>
</ul>


<p>で比較。</p>

<hr />

<h2>Android-Java</h2>

<p>```java MainActivity.java
button1.setOnClickListener(new View.OnClickListener() {</p>

<pre><code>@Override
public void onClick(View view) {
    label1.setText("pushed!!");        
}
</code></pre>

<p>});</p>

<h2>```</h2>

<h2>Xamarin.Android(C#)</h2>

<p>```csharp MainActivity.cs
buttonOk.Click += (_, e)</p>

<pre><code>=&gt; label1.Text = "pushed!!";
</code></pre>

<h2>```</h2>

<h2>iOS-Swift</h2>

<p>```java ViewController.swift
buttonOK.addTarget(self, action:</p>

<pre><code>#selector(ViewController.onTouch(_:)), 
forControlEvents: .TouchUpInside)
</code></pre>

<p>・・・
func onTouch(sender: AnyObject) {</p>

<pre><code>label1.text = "pushed!!"
</code></pre>

<p>}</p>

<h2>```</h2>

<h2>Xamarin.iOS(C#)</h2>

<p>```csharp ViewColtroller.cs
buttonOk.TouchUpInside += (_, e)</p>

<pre><code>=&gt; label1.Text = "pushed!!";
</code></pre>

<h2>```</h2>

<h2>まとめ</h2>

<p><strong>Xamarin はいいぞ！</strong></p>
]]></content>
  </entry>
  
</feed>
