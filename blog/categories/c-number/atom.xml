<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c# | Experiments Never Fail]]></title>
  <link href="http://blog.amay077.net/blog/categories/c-number/atom.xml" rel="self"/>
  <link href="http://blog.amay077.net/"/>
  <updated>2016-02-05T01:34:02+09:00</updated>
  <id>http://blog.amay077.net/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Task→Observable 変換でハマったこと]]></title>
    <link href="http://blog.amay077.net/blog/2016/01/16/misunderstood-task-to-observable-conversion/"/>
    <updated>2016-01-16T23:59:59+09:00</updated>
    <id>http://blog.amay077.net/blog/2016/01/16/misunderstood-task-to-observable-conversion</id>
    <content type="html"><![CDATA[<p>.NET の <code>Task&lt;T&gt;</code> は、Reactive Extensions が提供する拡張メソッド <code>ToObservable()</code> で <code>IObservable&lt;T&gt;</code> に変換できます。</p>

<p>なにも考えずに <code>ToObservable()</code> を連発していたら、盛大にハマったのでメモ。</p>

<!--more-->


<h2>Task.Run().ToObservable() とか、意味ないっしょ</h2>

<p>ダメなコード。</p>

<p>```csharp
var i = 0;
IObservable<int> incrementObservable = Task.Run (() => {</p>

<pre><code>i++;
Debug.WriteLine($"increment! - {i}");
return i;
</code></pre>

<p>})
.ToObservable ();</p>

<p>Debug.WriteLine(&ldquo;Ready&hellip;&rdquo;);</p>

<p>incrementObservable // インクリメント</p>

<pre><code>.Repeat(3) // ３回繰り返す
.Subscribe(
    x  =&gt; Debug.WriteLine($"OnNext({x})"),
    ex =&gt; Debug.WriteLine($"OnError({ex.ToString()})"),
    () =&gt; Debug.WriteLine("OnCompleted"));
</code></pre>

<p>```</p>

<p><code>incrementObservable</code> は、副作用ありありですが、外部変数 i を +1 して後続に流す <code>IObservable&lt;int&gt;</code> です。
　これを <code>.Repeat(3)</code> して <code>.Subscribe</code> してますから、
　</p>

<blockquote><p>Ready&hellip;
increment! &ndash; 1
OnNext(1)
increment! &ndash; 2
OnNext(2)
increment! &ndash; 3
OnNext(3)
OnCompleted</p></blockquote>

<p>という出力を期待してました。
が、実際の出力はこう。</p>

<blockquote><p>increment! &ndash; 1
Ready&hellip;
OnNext(1)
OnNext(1)
OnNext(1)
OnCompleted</p></blockquote>

<p>Subscribe する前に Task が実行されてるし、 repeat してるのに increment されない。。。</p>

<p>「・・・ん？ Task.Run().ToObservable() って、タスクを実行した結果を IObservable 化してるだけじゃね？」</p>

<p>コード見たまんまなんですが、これに気づくのに１時間かかりました。。。</p>

<p>期待通り動くのはこう↓。</p>

<p>```csharp
var i = 0;
IObservable<int> incrementObservable = Observable.FromAsync(()=>Task.Run(() => {</p>

<pre><code>i++;
Debug.WriteLine($"increment! - {i}");
return i;
</code></pre>

<p>}));</p>

<p>Debug.WriteLine(&ldquo;Ready&hellip;&rdquo;);</p>

<p>incrementObservable // インクリメント</p>

<pre><code>.Repeat(3) // ３回繰り返す
.Subscribe(
    x  =&gt; Debug.WriteLine($"OnNext({x})"),
    ex =&gt; Debug.WriteLine($"OnError({ex.ToString()})"),
    () =&gt; Debug.WriteLine("OnCompleted"));
</code></pre>

<p>```</p>

<p><code>Observable.FromAsync</code> で Task の実行そのものを IObservable 化します。
これの結果は正しくこう↓なりました。</p>

<blockquote><p>Ready&hellip;
increment! &ndash; 1
OnNext(1)
increment! &ndash; 2
OnNext(2)
increment! &ndash; 3
OnNext(3)
OnCompleted</p></blockquote>

<h2>Task は１回しか実行できない</h2>

<p>ところで、 <code>Task&lt;T&gt;</code> は一度実行すると、２度目は実行できません。（Furure や Promise もそうだっけ）</p>

<p>```csharp
var i = 0;
Task<int> incrementTask = new Task<int>(() => {</p>

<pre><code>i++;
Debug.WriteLine($"increment! - {i}");
return i;
</code></pre>

<p>});</p>

<p>incrementTask.RunSynchronously();
incrementTask.RunSynchronously();
```</p>

<p>このコードは２回目の <code>RunSynchronously()</code> で例外がでます。</p>

<p>となると、 <code>incrementTask.ToObservable()</code> したとしても、期待通り動いてくれなさそうです。
（そもそも Task は <code>Start</code> などしないと実行されないので、Observable のチェインの中でいつ呼ぶの？）</p>

<p>というわけで、 <code>Task.ToObservable()</code> は、どういう時に使えばいいのかよくわかりませんでした。だれか教えて下さい。（汗）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIAlertController を async/await 対応させて便利に使う]]></title>
    <link href="http://blog.amay077.net/blog/2014/12/24/using-uialertcontroller-with-async-await/"/>
    <updated>2014-12-24T00:00:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/12/24/using-uialertcontroller-with-async-await</id>
    <content type="html"><![CDATA[<p>　これは <a href="http://qiita.com/advent-calendar/2014/xamarin">Xamarin Advent Calendar 2014 23日目</a> の記事です。</p>

<p>　なんか空いてたのでエントリーしましたが、急だったので軽い話です。</p>

<!--more-->


<ul>
<li><a href="http://qiita.com/amay077/items/56abeeaa188f33cd56de">iOS アプリでアラート出してボタンが押されるまで待つ？方法を Objective-C と Xamarin.iOS で比べてみた &ndash; Qiita</a></li>
</ul>


<p>の焼き直しみたいなものです。</p>

<p>　iOS8 では、<code>UIAlertDialog</code> が非推奨になり、代わりに <code>UIAlertController</code> を使えとのこと。</p>

<p>　普通に使うとこうなります。</p>

<p>```csharp
button1.TouchUpInside += (sender, e) =>
{</p>

<pre><code>var alert = UIAlertController.Create("", "こんぼう をすてますか？", UIAlertControllerStyle.Alert);
alert.AddAction(UIAlertAction.Create("はい", 
    UIAlertActionStyle.Default, x=&gt; label1.Text = "こんぼう をすてました")); 
alert.AddAction(UIAlertAction.Create("いいえ",  
    UIAlertActionStyle.Default, x=&gt; {})); 

this.PresentViewController(alert, true, null);
</code></pre>

<p>};
```</p>

<p>　このくらいなら問題ありません。</p>

<p>　次に、こんぼう をすてる前にもう一度問いかけるようにします。
２つ目の <code>UIAlertController</code> が入れ子になってしまって見づらい、 <strong>残念な感じ</strong> です。</p>

<p>```csharp
button1.TouchUpInside += (sender, e) =>
{</p>

<pre><code>var alert = UIAlertController.Create("", "こんぼう をすてますか？", UIAlertControllerStyle.Alert);
alert.AddAction(UIAlertAction.Create("はい", 
    UIAlertActionStyle.Default, x=&gt; 
    {
        // 念押しの確認ダイアログ（入れ子でつらい
        var alert2 = UIAlertController.Create("", "ほんとうにすてますか？", UIAlertControllerStyle.Alert);
        alert2.AddAction(UIAlertAction.Create("もちろん", UIAlertActionStyle.Default, _=&gt; 
        {
            label1.Text = "こんぼう をすてました"
        }));
    alert2.AddAction(UIAlertAction.Create("やめる",  UIAlertActionStyle.Default, _=&gt; {})); 

    // アラート２の表示
    this.PresentViewController(alert2, true, null);
})); 

// アラート１の表示
alert.AddAction(UIAlertAction.Create("いいえ",  UIAlertActionStyle.Default, x=&gt; {})); 

this.PresentViewController(alert, true, null);
</code></pre>

<p>};
```</p>

<p>　Objective-C や Swift なら、ここで打つ手は今のところ無いでしょう。
しかし <strong>Xamarin には、C# には async/await がありまぁす！</strong>
アラートの表示を async/await（というか Task）対応してみましょう。</p>

<p>```csharp
private Task<int> ShowDialog(string message, string button1Title, string button2Title)
{</p>

<pre><code>var comp = new TaskCompletionSource&lt;int&gt;();

var alert = UIAlertController.Create("", message, UIAlertControllerStyle.Alert);
alert.AddAction(UIAlertAction.Create(button1Title, UIAlertActionStyle.Default, x=&gt; 
{
    comp.SetResult(1); // OKボタン
})); 
alert.AddAction(UIAlertAction.Create(button2Title,  UIAlertActionStyle.Default, x=&gt; 
{
    comp.SetResult(0); // Cancel
})); 

this.PresentViewController(alert, true, null);

return comp.Task;
</code></pre>

<p>}
```</p>

<p><code>Task&lt;int&gt;</code> を返すメソッド <code>ShowDialog</code> です。<code>UIAlertController</code> のボタンが押されたら <code>SetResult</code> して Task の値を決定します。</p>

<p>　このメソッドを使う方は、こうなります。</p>

<p>```csharp
button1.TouchUpInside += async (sender, e) =>
{</p>

<pre><code>if (await ShowDialog("こんぼう をすてますか？", "はい", "いいえ") == 0) 
    return;

if (await ShowDialog("ほんとうにすてますか？", "もちろん", "やめる") == 0) 
    return;

label1.Text = "こんぼう をすてました";
</code></pre>

<p>};
```</p>

<p>なんて見やすいコードになったことでしょう。すばらしい！</p>

<p>入れ子でなく、フラットに書けるので、こんな事もできます。</p>

<p>```csharp
button1.TouchUpInside += async (sender, e) =>
{</p>

<pre><code>while (await ShowDialog("こんぼう をすてますか？", "はい", "いいえ") == 1) 
{
    label1.Text = "それをすてるなんてとんでもない！";
}

label1.Text = "すてるのをやめました";
</code></pre>

<p>};
```</p>

<p>こんぼうを捨てるのをあきらめるまで、なんどでも聞いてきます。
コールバックスタイルのメソッドでループとか、ベタに書くと頭痛いです。</p>

<p>動かすとこんな感じです。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/uialertcontroller_with_async_await_01.gif" alt="" /></p>

<p><code>ShowDialog</code> は拡張メソッドとして作成しておくと、呼び出しに便利かもしれません。
コールバックスタイルの機能を、Task化するパターンはよく使いそうな気がします。<code>TaskCompletionSource</code>、覚えておきましょう。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveX と MVVM と DataBinding の関係について図にしてみた]]></title>
    <link href="http://blog.amay077.net/blog/2014/10/30/reactivex-mvvm-databindings-relations/"/>
    <updated>2014-10-30T01:17:39+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/10/30/reactivex-mvvm-databindings-relations</id>
    <content type="html"><![CDATA[<ul>
<li><a href="http://connpass.com/event/8680/">ReactiveCocoa Tokyo #rac_tokyo &ndash; connpass</a></li>
<li><a href="http://connpass.com/event/9061/">RxJava Night #rxjnight &ndash; connpass</a></li>
<li><a href="http://mozaic.fm/post/100741841543/10-node-js-sideshow">#10 node.js sideshow | mozaic.fm</a></li>
</ul>


<!--more-->


<p>などなどをいろいろ眺めておりまして（東京うらやましい）、Reactive Extensions とか MVVM とかいろいろ熱い！楽しい！と思っているわけですが、いろいろなライブラリがあって、それらのカバーする範囲がいまいち明確になってない気がしたので、自分なりに整理してみました。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/reactive_mvvm_databindings_relations_01.png" alt="" /></p>

<p>MVVM っていうと、Messenger とか DIコンテナ的なものとかもあるわけですが、主に DataBinding と Rx の違いにフィーチャーしたかったので除外しました。</p>

<p>　DataBinding は、<a href="http://www.atmarkit.co.jp/ait/articles/1008/03/news097_3.html">DependencyProperty</a> や <a href="http://blog.falafel.com/learning-xamarin-custom-renderers-in-xamarin-forms/">BindableProperty</a> みたいなものがあるかどうかという感じで考えていて、「XAMLとかのマークアップでバインディング指定できなければならない」という考えではないです。</p>

<p>　View, DataBinding, ViewModel, ReactiveX の各ブロックは基本的にはどの組み合わせでもよくて（特に ReactiveX は他とは別の世界のものなので）、しかし中には ReactiveProperty のように ReactiveX に依存しつつ ViewModel の機能を提供するものがあったり、ReactiveCocoa のように「全部入り」のものがあったりします。また、View と ViewModel を繋ぐためにはなんらかの DataBinding が必要です。</p>

<p>という理解なんですが、あってますかね？</p>

<p>　私は Xamarin 推しの人なので、 <strong>Xamarin.Forms + ReactiveProperty が、MVVM+Rx のパワーをフル活用できて、しかも iOS/Android で大部分のコードが共有できるという最強の組み合わせなんですよ！</strong> というのを言いたいわけです。</p>

<h2>Links</h2>

<ul>
<li>Xamarin.Forms &ndash; <a href="http://xamarin.com/forms">Build a Native Android UI &amp; iOS UI with Xamarin.Forms &ndash; Xamarin</a></li>
<li>Prism &ndash; <a href="http://compositewpf.codeplex.com/releases/view/117297">patterns &amp; practices: Prism &ndash; Download: Prism 5.0 for .NET 4.5</a></li>
<li>MVVM Light Toolkit &ndash; <a href="https://mvvmlight.codeplex.com/">MVVM Light Toolkit &ndash; Home</a></li>
<li>Reactive Extensions &ndash; <a href="https://rx.codeplex.com/">Rx (Reactive Extensions) &ndash; Home</a></li>
<li>ReactiveProperty &ndash; <a href="https://reactiveproperty.codeplex.com/">ReactiveProperty &ndash; MVVM Extensions for Rx &ndash; Home</a></li>
<li>ReactiveUI &ndash; <a href="https://github.com/reactiveui/reactiveui">reactiveui/ReactiveUI</a></li>
<li>MvvmCross &ndash; <a href="https://github.com/MvvmCross/MvvmCross">MvvmCross/MvvmCross</a></li>
<li>RxJava &ndash; <a href="https://github.com/ReactiveX/RxJava">ReactiveX/RxJava</a></li>
<li>RxAndroid &ndash; <a href="https://github.com/ReactiveX/RxAndroid">ReactiveX/RxAndroid</a></li>
<li>android-binding &ndash; <a href="https://github.com/gueei/AndroidBinding">gueei/AndroidBinding</a></li>
<li>ReactiveCocoa &ndash; <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa/ReactiveCocoa</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.Forms、Android での BACK キーの制御]]></title>
    <link href="http://blog.amay077.net/blog/2014/06/17/hooking-back-key-in-xamarin-forms/"/>
    <updated>2014-06-17T01:00:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/06/17/hooking-back-key-in-xamarin-forms</id>
    <content type="html"><![CDATA[<p><a href="http://qiita.com/amay077/items/12979585ac3e2dcacacb">Xamarin.Forms でどうにかしたい iOS と Android の違い</a> の「BACKキーの制御」の <strong>現時点(1.1.0.6201)</strong> での回答。</p>

<!--more-->


<p>Android の BACKキーの制御を、Xamarin.Forms ではどう扱えるかを調べた。</p>

<h2>シナリオ</h2>

<p>Xamarin.Forms による画面１(MainPage)、２(SecondPage)があり、MainPage では BACKキーで戻る(=アプリ終了)事ができるが、SecondPage ではBACKキーが効かない、ようにしたい。</p>

<h2>対策</h2>

<p>まず画面１と２はこんな感じ。ボタンを押したら画面２へ遷移するだけ。</p>

<p>```csharp Pages.cs
// 画面１
public class MainPage : ContentPage
{</p>

<pre><code>public MainPage() 
{
    var button = new Button
    {
        Text = "To Second",
        VerticalOptions = LayoutOptions.Center,
    };

    button.Clicked += (sender, e) =&gt; 
    {
        this.Navigation.PushAsync(new SecondPage());
    };

    Content = button;
}
</code></pre>

<p>}</p>

<p>// 画面２
public class SecondPage : ContentPage
{</p>

<pre><code>public SecondPage()
{
    Content = new Label
    {
        Text = "Second"
    };
}
</code></pre>

<p>}
```</p>

<p>ここからが本題。
まず Android側のエントリポイントである <code>MainActivity.cs</code> は以下のように、<code>ContentPage</code> プロパティを設ける。そして <code>OnBackPressed</code> メソッドを override して、MainPage だったら OnBackPressed を親へ伝搬する。</p>

<p>```csharp MainActivity.cs
[Activity(Label = &ldquo;ScrollTest.Android.Android&rdquo;, MainLauncher = true)]
public class MainActivity : AndroidActivity
{</p>

<pre><code>protected override void OnCreate(Bundle bundle)
{
    base.OnCreate(bundle);

    Xamarin.Forms.Forms.Init(this, bundle);

    SetPage(new NavigationPage(new MainPage()));
}

internal Page ContentPage
{
    get;
    set;
}

public override void OnBackPressed()
{
    if (this.ContentPage is MainPage)
    {
        base.OnBackPressed();
    }
}
</code></pre>

<p>}
```</p>

<p>次に、MainActivity.ContentPage への設定を行うコードは以下の通り。
PageRenderer を拡張して ExportRenderer することで、すべての Page にフックをかけ、Page の表示時に MainActivity.ContentPage に設定する。</p>

<p>```csharp MyPageRenderer.cs
using System;
using Xamarin.Forms.Platform.Android;
using Android.App;
using Xamarin.Forms;
using ScrollTest.Android;
using Android.Views;
using Android.Graphics;</p>

<p>[assembly:ExportRenderer(typeof(ContentPage), typeof(MyPageRenderer))]</p>

<p>namespace ScrollTest.Android
{</p>

<pre><code>public class MyPageRenderer : PageRenderer
{
    protected override void OnElementChanged(ElementChangedEventArgs&lt;Xamarin.Forms.Page&gt; e)
    {
        base.OnElementChanged(e);

        // なんとなく不安なので weak にしてみた
        var activity = new WeakReference&lt;MainActivity&gt;(this.Context as MainActivity);

        e.NewElement.Appearing += (_, __) =&gt;
        {
            MainActivity a;
            if (activity.TryGetTarget(out a)) {
                a.ContentPage = e.NewElement;    
            }
        };
    }
}
</code></pre>

<p>}
```</p>

<p>これで、画面１(MainPage)の時だけ BACKキーが効くようにできる。</p>

<h3><code>Appearing</code> イベントが必要なの？</h3>

<p>　Xamarin.Forms の Android実装では、画面遷移の度に <strong>「同じインスタンスの MainActivity」</strong> が使いまわされる、さらに <code>OnElementChanged</code> は、各Pageにつき１度しか発生しない。その為、画面１→２→１と遷移すると <code>MainActivity.ContentPage</code> は <code>SecondPage</code> のままになってしまう。ので <code>Appearing</code> イベントで表示の度に MainActivity.ContentPage を設定する必要がある。</p>

<h3><code>AndroidActivity</code> に static な <code>BackPressed</code> イベントがあるんだけど…</h3>

<p>イベントハンドラの定義は
<code>public delegate bool BackButtonPressedEventHandler(object sender, EventArgs e);</code>
となっていて、<code>true</code> を返すと BACK キーを無効にできるようなのだけど、<code>sender</code> は <code>MainActivity</code>だし、<code>EventArgs</code> は Page を取得できないしで使えないじゃん。。。</p>

<p>なんだかすごく発展途上な気がする、その内いろいろ整備されそうなので、それまで待った方が良い気がします。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.Forms の Label から iOS の UILabel を取り出す]]></title>
    <link href="http://blog.amay077.net/blog/2014/06/13/convert-xamarin-forms-label-to-native-uilabel/"/>
    <updated>2014-06-13T15:34:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/06/13/convert-xamarin-forms-label-to-native-uilabel</id>
    <content type="html"><![CDATA[<p><a href="http://qiita.com/amay077/items/12979585ac3e2dcacacb">Xamarin.Forms でどうにかしたい iOS と Android の違い</a> の「文字の自動縮小」の自己回答。</p>

<!--more-->


<p>Xamarin.Forms で定義した <code>Label</code> は、iOS では <code>UILabel</code> となるはずなので、その過程のどこかでフックできれば <code>UILabel.AdjustsFontSizeToFitWidth</code> が仕込める、と目論んで、ホントにできたのでメモ。</p>

<h2>要点</h2>

<p><del>Forms→ネイティブのフックは PageRenderer でできる。その中で得られる UIView（のサブクラス）は、Label と UILabel の両方の参照を持っているので、あとは使うだけ。</del></p>

<p><strong>ページでなく、UIパーツレベルでフックできたので、全面的に書き換えた。</strong></p>

<h2>やってみる</h2>

<p>参考にしたのは <a href="https://github.com/xamarin/xamarin-forms-samples/tree/master/Forms2Native">https://github.com/xamarin/xamarin-forms-samples/tree/master/Forms2Native</a> 。</p>

<p>このサンプルをちょっと改造して試した。</p>

<p>まずは Forms側の MySecondPage.cs を修正。</p>

<p>```csharp MySecondPage.cs
public class MySecondPage : ContentPage
{</p>

<pre><code>public Label MyLabel { get; private set; }

public MySecondPage ()
{
    this.MyLabel = new Label
    {
        Text = "Too loooooooooooooooooooooooong label",
        Font = Font.SystemFontOfSize(30d),
        LineBreakMode = LineBreakMode.NoWrap
    };

    Content = new StackLayout
    {
        Orientation = StackOrientation.Vertical,
        VerticalOptions = LayoutOptions.CenterAndExpand,
        Children = 
        {
            this.MyLabel
        }
    };
}
</code></pre>

<p>}
```</p>

<p>ラベルを配置。とても文字が長いので全部は表示しきれない。</p>

<p>次に iOS側に MyLabelRenderer.cs を作成。</p>

<p>```csharp MyLabelRenderer.cs
using System;
using Xamarin.Forms;
using Forms2Native;
using Xamarin.Forms.Platform.iOS;
using MonoTouch.UIKit;</p>

<p>[assembly:ExportRenderer(typeof(Label), typeof(MyLabelRenderer))]</p>

<p>namespace Forms2Native
{</p>

<pre><code>public class MyLabelRenderer : LabelRenderer
{
    protected override void OnElementChanged(ElementChangedEventArgs&lt;Label&gt; e)
    {
        base.OnElementChanged(e);
        this.Control.AdjustsFontSizeToFitWidth = true;
    }
}
</code></pre>

<p>}
```</p>

<p><code>ExportRenderer</code> で「Formsの<code>Label</code>は、<code>MyLabelRenderer</code>を使う」と定義している。
するとすべての <code>Label</code> の生成時を <code>OnElementChanged</code> でフックでき、<code>Control</code> で <code>UILabel</code> は取り出せるので、あとはご自由に、という感じ。</p>

<p>この実装だと、すべての Label に Ajusts が適用されてしまう。個別に行いたい場合は、Forms側に Labelから派生した <code>AjustableLabel</code> を作成して使い、<code>ExportRenderer(typeof(Label),…</code> のところを <code>ExportRenderer(typeof(AjustableLabel),…</code> にすればいけるはず。そしてこの方法はカスタムビューを作る手順に通じる（というかそのもの？）はず。</p>

<p>ちなみにこの <code>OnElementChanged</code> は、Nuget の Xamarin.Formsパッケージの Ver1.1.0.6201から利用できる。</p>

<h2>実行する</h2>

<p>こんな感じで、ちゃんと文字サイズが縮小されました。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/getting_uilabel_from_xamarin_forms.png" alt="" /></p>

<p>Android の方も同じ要領でいけるは…ず。</p>
]]></content>
  </entry>
  
</feed>
