<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c# | Experiments Never Fail]]></title>
  <link href="http://blog.amay077.net/blog/categories/c-number/atom.xml" rel="self"/>
  <link href="http://blog.amay077.net/"/>
  <updated>2016-10-03T11:49:15+09:00</updated>
  <id>http://blog.amay077.net/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Xamarin.iOS でインターネット通信が可能かを取得する]]></title>
    <link href="http://blog.amay077.net/blog/2016/08/26/ger_is_network_available_on_xamarin_ios/"/>
    <updated>2016-08-26T23:59:59+09:00</updated>
    <id>http://blog.amay077.net/blog/2016/08/26/ger_is_network_available_on_xamarin_ios</id>
    <content type="html"><![CDATA[<p>Xamarin.iOS で、「端末からインターネット通信が可能か？」を調べたい。</p>

<!--more-->


<p>Objective-C だと <a href="https://github.com/tonymillion/Reachability">Reachability</a>、swift だと <a href="https://github.com/ashleymills/Reachability.swift">Reachability.swift</a> を使うようだけど、 Xamarin.iOS ではどうするか？</p>

<ul>
<li><a href="http://d.hatena.ne.jp/scientre/20150527/get_network_status_in_swift">Swift でネットワーク状況を調べる &ndash; メモ用紙</a></li>
</ul>


<p>Bindingライブラリがあるのかな？と思ったら、サンプルで C# のソースコードが提供されていた。</p>

<ul>
<li><a href="https://developer.xamarin.com/recipes/ios/network/reachability/detect_if_network_is_available/">Detect if Network is Available &ndash; Xamarin</a></li>
</ul>


<p>の <a href="https://github.com/xamarin/monotouch-samples/blob/master/ReachabilitySample/reachability.cs"><code>reachability.cs</code></a> がそれ。
（名前から察して Reachability.swift を C# で書きなおしたもの？詳しくは見てないけど。）</p>

<p>で、このサンプルの <code>Reachability</code> を使うと、以下のような感じで、「インターネット通信が可能か？」を調べられる。</p>

<p>```csharp
public bool IsNetworkAvailable
{</p>

<pre><code>get
{
    return Reachability.InternetConnectionStatus() != NetworkStatus.NotReachable;
}
</code></pre>

<p>}
```</p>

<p>WiFi とかセルラーとか細かいステータスもあるので、あとはコードを見てください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NavigationPage + MasterDetailPage の時に iOS の NavigationBar の左ボタンをカスタマイズする]]></title>
    <link href="http://blog.amay077.net/blog/2016/07/22/customizing_left_button_on_%20NavigationBar_in_using_navigationpage_with_masterdetailpage/"/>
    <updated>2016-07-22T23:59:59+09:00</updated>
    <id>http://blog.amay077.net/blog/2016/07/22/customizing_left_button_on_ NavigationBar_in_using_navigationpage_with_masterdetailpage</id>
    <content type="html"><![CDATA[<p>Xamarin.Forms では、左からスライドして出てくるメニューを持つ画面を <code>MasterDetailPage</code> で作成します。</p>

<!--more-->


<ul>
<li><a href="https://developer.xamarin.com/guides/xamarin-forms/user-interface/navigation/master-detail-page/">Master-Detail Page &ndash; Xamarin</a></li>
</ul>


<p>一方、普通に画面遷移していく場合は ContentPage などを <code>NavigationPage</code> でラップしてあげます。</p>

<ul>
<li><a href="https://developer.xamarin.com/guides/xamarin-forms/user-interface/navigation/hierarchical/">Hierarchical Navigation &ndash; Xamarin</a></li>
</ul>


<h2>やりたいこと</h2>

<p>何がしたいかというと、両者を組み合わせたいんです。こういうことってよくありませんかね？</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/customizing_left_navvigationbar_button_in_masterdetail_with_navigation_pages_01.png" alt="" /></p>

<p>起動画面で「新規ユーザー登録」があって、「ユーザー登録画面」を経て、メインの画面に遷移する、メイン画面にはスライドメニューがある、というパターン。これを Xamarin.Forms でやりたいのです。</p>

<h2>問題</h2>

<p>ところが、 <code>NavigationPage</code> で遷移していく画面の中に <code>MasterDetailPage</code> があると、 <code>NavigationPage</code> の方が勝ってしまい、ナビゲーションバーには「BACK」ボタンが表示されてしまいます。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/customizing_left_navvigationbar_button_in_masterdetail_with_navigation_pages_02.png" alt="" /></p>

<p>これを消そうと、<code>MasterDetailPage</code> のコンストラクタで <code>NavigationPage.SetHasBackButton(this, false)</code> してみます。</p>

<p>その結果がこれ。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/customizing_left_navvigationbar_button_in_masterdetail_with_navigation_pages_03.png" alt="" /></p>

<p>Android の方は望む結果になったけど、iOSの方はうーん…、BACKボタンは消えたけど、メニューを表示させるボタンが出ません。</p>

<p>しょうがないので、iOS の場合だけ、ナビゲーションバーの左ボタンをどうにかして追加してみます。</p>

<h2>私が求めていたソリューション（CustomRenderer編）</h2>

<p>Xamarin.Forms のお供、CustomRenderer です。</p>

<ul>
<li><a href="https://developer.xamarin.com/guides/xamarin-forms/custom-renderer/">Customizing Controls on Each Platform &ndash; Xamarin</a></li>
<li><a href="http://ticktack.hatenablog.jp/entry/2016/06/11/124751">【Xamarin.Forms】ViewRendererと仲良くなるための簡易チュートリアル &ndash; ぴーさんログ</a></li>
</ul>


<p><code>MasterDetailPage</code> の iOS向けCustomRenderer を作って、ネイティブ側でナビゲーションバーをカスタマイズしてみます。</p>

<p>```csharp CustomMasterDetailRenderer.cs
using System;
using MasterDetail.iOS;
using MonoTouch.UIKit;
using Xamarin.Forms;
using Xamarin.Forms.Platform.iOS;</p>

<p>[assembly: ExportRenderer(typeof(MasterDetailPage), typeof(CustomMasterDetailRenderer))]
namespace MasterDetail.iOS
{</p>

<pre><code>public class CustomMasterDetailRenderer : PhoneMasterDetailRenderer
{
    public override void ViewWillAppear(bool animated)
    {
        base.ViewWillAppear(animated);

        var page = Element as MasterDetailPage;

        var navigationItem = this.NavigationController.TopViewController.NavigationItem;
        navigationItem.LeftBarButtonItems = new UIBarButtonItem[]
        {
            new UIBarButtonItem("MENU", UIBarButtonItemStyle.Plain, (_, __) =&gt; 
            { 
                page.IsPresented = !page.IsPresented; 
            })
        };
    }
}
</code></pre>

<p>}
```
「MENU」ってボタンを、ナビゲーションバーの左側に追加しています。
こんな CustomRenderer を iOS 側のプロジェクトに追加して実行してみます。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/customizing_left_navvigationbar_button_in_masterdetail_with_navigation_pages_04.png" alt="" /></p>

<p>オーケーオーケー、これが私が求めていたソリューションです。</p>

<h2>私が求めていたソリューション（Effects編）</h2>

<p>が、CustomRenderer にはいくつか考えなければならないことがあります。</p>

<ul>
<li>上で作った <code>CustomMasterDetailRenderer.cs</code> は <code>PhoneMasterDetailRenderer</code> というクラスを継承しています。が、実はこれは iPhone 用で、実はタブレット（iPad）用に <code>TabletMasterDetailRenderer</code> というクラスもあります。これの CustomRenderer も用意しなければなりませんか？</li>
<li>CustomRenderer はベースとなる ViewRenderer を「継承」して作ります。そして C# は多重継承を許していません、この意味が分かるな？別の機能を拡張したいと思ったら<code>CustomMasterDetailRenderer</code>から派生させるしかなくなります。</li>
</ul>


<p>で、 Xamarin.Forms には、v2.1 から既存機能の拡張に Effects という選択肢が加わりました。</p>

<ul>
<li><a href="https://developer.xamarin.com/guides/xamarin-forms/effects/">Customizing Controls with Effects &ndash; Xamarin</a></li>
<li><a href="http://ticktack.hatenablog.jp/entry/2016/01/26/020248">【Xamarin.Forms 2.1.0(プレビュー)】Effects &ndash; ぴーさんログ</a></li>
</ul>


<p>では、<code>CustomMasterDetailRenderer.cs</code> を Effects に変えてみましょう。</p>

<p>```csharp CustomMasterDetailEffect.cs
using System;
using MasterDetail.iOS;
using MonoTouch.UIKit;
using Xamarin.Forms;
using Xamarin.Forms.Platform.iOS;</p>

<p>[assembly: ResolutionGroupName(&ldquo;mycompany&rdquo;)]
[assembly: ExportEffect(typeof(CustomMasterDetailEffect), &ldquo;CustomMasterDetailEffect&rdquo;)]
namespace MasterDetail.iOS
{</p>

<pre><code>public class CustomMasterDetailEffect : PlatformEffect
{
    protected override void OnAttached()
    {
        var page = Element as MasterDetailPage;
        page.Appearing += Page_Appearing;
    }

    protected override void OnDetached()
    {
        var page = Element as MasterDetailPage;
        page.Appearing -= Page_Appearing;
    }

    void Page_Appearing(object sender, EventArgs e)
    {
        var vc = GetParentViewController();
        var page = Element as MasterDetailPage;

        var navigationItem = vc.NavigationController.TopViewController.NavigationItem;
        navigationItem.LeftBarButtonItems = new UIBarButtonItem[]
        {
            new UIBarButtonItem("MENU", UIBarButtonItemStyle.Plain, (_, __) =&gt; 
            { 
                page.IsPresented = !page.IsPresented; 
            })
        };
    }

    UIViewController GetParentViewController()
    {
        UIResponder responder = this.Container;
        while ((responder = responder.NextResponder) != null)
        {
            if (responder is UIViewController)
            {
                return (UIViewController)responder;
            }
        }
        return null;
    }
}
</code></pre>

<p>}
```</p>

<p>Effect は、 <code>ResolutionGroupName</code> と <code>ExportEffect</code> で定義した名称を使って、PCL側プロジェクトで Page に追加します。</p>

<p>```csharp RootPage.cs
public class RootPage : MasterDetailPage
{</p>

<pre><code>public RootPage ()
{
    NavigationPage.SetHasBackButton(this, false);
    // Effect を追加する
    Effects.Add(Effect.Resolve("mycompany.CustomMasterDetailEffect"));

    // 以下省略
</code></pre>

<p>```</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/customizing_left_navvigationbar_button_in_masterdetail_with_navigation_pages_05.png" alt="" /></p>

<p>こちらも、CustomRenderer と同じことができました。</p>

<p>が、ちょっと黒魔術っぽいの使ってます。</p>

<ul>
<li><code>Effects.Container</code> から取得できるのは <code>UIView</code> です。親の <code>UIViewController</code> を得るには、 <code>GetParentViewController()</code> でやってるような事をしなければなりません</li>
<li>CustomRenderer はそれ自体は <code>ViewController</code> だったので <code>ViewWillAppear()</code> など画面のライフサイクルコールバックを override することができました。が、Effects から ViewController のライフサイクルイベントをハンドリングできません。代わりに Xamarin.Forms 側の <code>Page</code> のライフサイクルから <code>Appearing</code> イベントで処理するようにしています。そのため、「MENU」ボタンが表示されるタイミングが若干遅れます。</li>
</ul>


<h2>CustomRenderer と Effects 、どちらを使えばいいの？</h2>

<ul>
<li>CustomRenderer はできる事は多いが、複数の CustomRenderer を適用することはできない</li>
<li>Effects はできる事は少ないが、複数の機能拡張を同時に適用できる</li>
</ul>


<p>以上を考えると、</p>

<ol>
<li>まずあなたの行いたいことが Effects で実現できないか、試してみる</li>
<li>Effects でできないレベルなら CustomRenderer を選択する</li>
</ol>


<p>となるでしょう。</p>

<p>本件のネタは、 Effects ではかなりムリをして実現しているので、CustomRenderer の方が相応しいと思われます。
が、CustomRenderer はここぞという時にとっておきたい気もします。
このさじ加減は、作るアプリの規模・深度、汎用性、再利用性などによって変わってくるでしょう。Effects の方が汎用性・再利用性は高いですが、ネイティブのUIパーツをごっそり入れ替えるような深い事は、CustomRenderer でなければできません。</p>

<p>今回のプログラムは Github に上げてあります。（<code>CustomMasterDetailRenderer.cs</code> はコメントアウトしてあって、Effects の方を活かしてます。）</p>

<ul>
<li><a href="https://github.com/amay077/XFNavigationWithMasterDetailSample/blob/master/README.md">XFNavigationWithMasterDetailSample/README.md at master · amay077/XFNavigationWithMasterDetailSample</a></li>
</ul>


<p>私は「Effects で頑張りたい派」かな。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[非同期処理の書き方を Java と Swift と Xamarin で比較する]]></title>
    <link href="http://blog.amay077.net/blog/2016/07/19/comparison_async_logic_with_java_swift_xamarin/"/>
    <updated>2016-07-19T23:59:59+09:00</updated>
    <id>http://blog.amay077.net/blog/2016/07/19/comparison_async_logic_with_java_swift_xamarin</id>
    <content type="html"><![CDATA[<p>「重たい処理を非同期で実行して、結果をメインスレッドで画面に表示」を、</p>

<!--more-->


<ul>
<li>Android-Java</li>
<li>iOS-Swift</li>
<li>Xamarin(Android も iOS も同じ)</li>
</ul>


<p>で比較。</p>

<hr />

<h2>Android</h2>

<p>```java
@Override
public void onClick(View view) {</p>

<pre><code>new AsyncTask&lt;Void, Void, Long&gt;() {
    @Override
    protected Long doInBackground(Void[] p) {
        // ワーカースレッド
        long ret = 0;
        for (long i = 0; i &lt; 1000000000; i++)
            ret += i;
        return ret;
    }

    @Override
    protected void onPostExecute(Long result) {
        // UIスレッド
        text1.setText(String.valueOf(result));
    }
}.execute((Void)null);
</code></pre>

<p>}
```</p>

<hr />

<h2>Swift</h2>

<p>```java
@IBAction func onTouchUpInside(sender: AnyObject) {</p>

<pre><code>weak var weakSelf = self
dispatch_async(dispatch_get_global_queue(
    DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), {
    // ワーカースレッド
    var ret:Int = 0
    for i in 0...1000000000 {
        ret += i
    }

    dispatch_async(dispatch_get_main_queue(), {
        // UIスレッド
        weakSelf?.label1.text = String(ret)
    });
});
</code></pre>

<p>}
```</p>

<hr />

<h2>Xamarin(Android も iOS も)</h2>

<p>```csharp
Task<long> FatProc() => Task.Run<long>(() => {</p>

<pre><code>long ret = 0;
for (long i = 0; i &lt; 1000000000; i++)
    ret += i;
return ret;
</code></pre>

<p>});</p>

<p>button1.TouchUpInside += async (_, e) => {</p>

<pre><code>var ret = await FatProc(); // ワーカースレッド
label1.Text = ret.ToString(); // UIスレッド
</code></pre>

<p>};
```</p>

<hr />

<h2>Xamarin はいいぞ！</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ボタンをタップした時に○○する、を Java と Swift と Xamarin で比較する]]></title>
    <link href="http://blog.amay077.net/blog/2016/07/15/comparison_on_click_with_java_swift_xamarin/"/>
    <updated>2016-07-15T23:59:59+09:00</updated>
    <id>http://blog.amay077.net/blog/2016/07/15/comparison_on_click_with_java_swift_xamarin</id>
    <content type="html"><![CDATA[<p>たぶん一番書くやつを</p>

<!--more-->


<ul>
<li>Android-Java</li>
<li>Android-Xamarin</li>
<li>iOS-Swift</li>
<li>iOS-Xamarin</li>
</ul>


<p>で比較。</p>

<hr />

<h2>Android-Java</h2>

<p>```java MainActivity.java
button1.setOnClickListener(new View.OnClickListener() {</p>

<pre><code>@Override
public void onClick(View view) {
    label1.setText("pushed!!");        
}
</code></pre>

<p>});</p>

<h2>```</h2>

<h2>Xamarin.Android(C#)</h2>

<p>```csharp MainActivity.cs
buttonOk.Click += (_, e)</p>

<pre><code>=&gt; label1.Text = "pushed!!";
</code></pre>

<h2>```</h2>

<h2>iOS-Swift</h2>

<p>```java ViewController.swift
buttonOK.addTarget(self, action:</p>

<pre><code>#selector(ViewController.onTouch(_:)), 
forControlEvents: .TouchUpInside)
</code></pre>

<p>・・・
func onTouch(sender: AnyObject) {</p>

<pre><code>label1.text = "pushed!!"
</code></pre>

<p>}</p>

<h2>```</h2>

<h2>Xamarin.iOS(C#)</h2>

<p>```csharp ViewColtroller.cs
buttonOk.TouchUpInside += (_, e)</p>

<pre><code>=&gt; label1.Text = "pushed!!";
</code></pre>

<h2>```</h2>

<h2>まとめ</h2>

<p><strong>Xamarin はいいぞ！</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.Android で音楽の音量を下げてから効果音を再生する]]></title>
    <link href="http://blog.amay077.net/blog/2016/07/09/gain_transient_in_xamarin_android/"/>
    <updated>2016-07-09T23:59:59+09:00</updated>
    <id>http://blog.amay077.net/blog/2016/07/09/gain_transient_in_xamarin_android</id>
    <content type="html"><![CDATA[<p>カーナビでよくある、音楽流しながらナビしてると、ガイダンス中は音楽のボリュームを一時的に下げて、案内の音声を再生するってやつ。</p>

<!--more-->


<ul>
<li><a href="http://ja.stackoverflow.com/questions/27452/%e3%82%b9%e3%83%9e%e3%83%9b%e3%82%a2%e3%83%97%e3%83%aa%e8%b5%b7%e5%8b%95%e6%99%82ios-android%e3%81%ab%e5%86%8d%e7%94%9f%e4%b8%ad%e3%81%ae%e9%9f%b3%e6%a5%bd%e3%82%92%e5%81%9c%e6%ad%a2%e3%81%95%e3%81%9b%e3%82%8b%e6%96%b9%e6%b3%95/27459#27459">スマホアプリ起動時(iOS/Android)に再生中の音楽を停止させる方法 &ndash; スタック・オーバーフロー</a></li>
</ul>


<p>に回答したので、その関連でやってみた。</p>

<p>```csharp MainActivity.cs
[Activity(Label = &ldquo;AudioFocusSample&rdquo;, MainLauncher = true, Icon = &ldquo;@mipmap/icon&rdquo;)]
public class MainActivity : Activity, AudioManager.IOnAudioFocusChangeListener
{</p>

<pre><code>protected override void OnCreate(Bundle savedInstanceState)
{
    base.OnCreate(savedInstanceState);
    SetContentView(Resource.Layout.Main);

    var audioManager = (AudioManager)GetSystemService(Context.AudioService);

    // 先に効果音を読み込んでおく
    var soundPool = new SoundPool(1, Stream.Music, 0);
    var soundId = soundPool.Load(ApplicationContext, Resource.Raw.cat, 0);
    // SoundPool は再生完了のコールバックがないので、事前に長さを得ておく
    var duration = GetSoundDuration(Resource.Raw.cat);

    FindViewById&lt;Button&gt;(Resource.Id.buttonRequestFocus).Click += async (sender, e) =&gt; 
    {
        // ダッキングを許可する AudioFocus を要求
        var result = audioManager.RequestAudioFocus(this, Stream.Music, AudioFocus.GainTransientMayDuck);
        if (result == AudioFocusRequest.Granted)
        {
            // 効果音を再生する
            soundPool.Play(soundId, 1.0f, 1.0f, 0, 0, 1.0f);
            // 再生完了まで待つ
            await Task.Delay((int)duration);
            // AudioFocus を開放
            audioManager.AbandonAudioFocus(this);
        }
    };
}

// 音声の再生長さを得る
private long GetSoundDuration(int rawId)
{
    using (var player = MediaPlayer.Create(ApplicationContext, rawId))
    {
        return player.Duration;
    }
}

// IOnAudioFocusChangeListener の実装（RequestAudioFocus のために必要）
public void OnAudioFocusChange([GeneratedEnum] AudioFocus focusChange)
{
   // 今回は使用しない
}
</code></pre>

<p>}
```</p>

<p>効果音 <code>Resource.Raw.cat</code> は、 <a href="http://on-jin.com/sound/index.php">On-Jin ～音人～</a> さんのを使わせてもらいました。</p>

<p>音量を小さくする＝絞る＝ダッキング、というのがなかなか連想しづらいので辿りつけない。
Android の音声再生は、他に <code>MediaPlayer</code> とか <code>AudioTrack</code> もあるし、リモコンなど外部からの操作のため？に BroadcastReceiver を使わないといけないし。</p>

<p>サンプルアプリはこちら。</p>

<ul>
<li><a href="https://github.com/amay077/AudioFocusSample">amay077/AudioFocusSample</a></li>
</ul>


<p>次は Xamarin.iOS でやってみる。</p>

<h2>参考</h2>

<ul>
<li><a href="https://developer.android.com/training/managing-audio/audio-focus.html">Managing Audio Focus | Android Developers</a></li>
<li><a href="http://dev.classmethod.jp/smartphone/android/android-tips-48-soundpool-mediaplayer/">Android Tips #48 BGM や効果音を再生する ｜ Developers.IO</a></li>
<li><a href="http://ameblo.jp/negiiiimo/entry-11488832997.html">Managing Audio Playback part2｜Android開発記録雑記</a></li>
<li><a href="http://qiita.com/KeithYokoma/items/3896f5934478fa560a50">音を制御する &ndash; AudioManager &ndash; Qiita</a></li>
<li><a href="https://developer.amazon.com/public/ja/solutions/devices/fire-tv/docs/managing-audio-focus">Fire TV でのオーディオフォーカスの管理 &ndash; アマゾン アプリ 開発者ポータル</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
