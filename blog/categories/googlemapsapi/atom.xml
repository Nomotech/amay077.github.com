<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: GoogleMapsAPI | Experiments Never Fail]]></title>
  <link href="http://amay077.github.io/blog/categories/googlemapsapi/atom.xml" rel="self"/>
  <link href="http://amay077.github.io/"/>
  <updated>2013-10-09T00:23:17+09:00</updated>
  <id>http://amay077.github.io/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[metersToEquatorPixels を Google Maps Android API v2 で]]></title>
    <link href="http://amay077.github.io/blog/2013/10/09/meterstoequatorpixels-in-gmap-v2/"/>
    <updated>2013-10-09T00:21:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/10/09/meterstoequatorpixels-in-gmap-v2</id>
    <content type="html"><![CDATA[<p>Google Map API v1 には、「地図上の距離(ｍ)を画面上の距離(ピクセル)に変換する」ためのメソッド <a href="https://developers.google.com/maps/documentation/android/v1/reference/com/google/android/maps/Projection#metersToEquatorPixels(float">Projection.metersToEquatorPixels</a>) がありましたが、v2 ではなくなってしまいました。</p>

<!--more-->


<p>ので、以下のような代替関数を作ってみました。</p>

<p>```java metersToEquatorPixels.java
public static int metersToEquatorPixels(GoogleMap map, LatLng base, float meters) {</p>

<pre><code>final double OFFSET_LON = 0.5d;

Location baseLoc = new Location("");
baseLoc.setLatitude(base.latitude);
baseLoc.setLongitude(base.longitude);

Location dest = new Location("");
dest.setLatitude(base.latitude);
dest.setLongitude(base.longitude + OFFSET_LON);

double degPerMeter = OFFSET_LON / baseLoc.distanceTo(dest); // 1m は何度？
double lonDistance = meters * degPerMeter; // m を度に変換

Projection proj = map.getProjection();
Point basePt = proj.toScreenLocation(base);
Point destPt = proj.toScreenLocation(new LatLng(base.latitude, base.longitude + lonDistance));

return Math.abs(destPt.x - basePt.x);
</code></pre>

<p>}
```</p>

<p>行っていることは単純で、基準となる緯度経度:<code>base</code> から、適当に(ここでは 0.5度)東へ移動した緯度経度を <code>Location.distanceTo</code> で求め、その結果から、「1ｍは何度か？」を求めます。あとは、この係数を使って 地図上の距離:<code>meters</code> を度に変換し、最後に、<code>base</code> と移動後の緯度経度それぞれを画面座標に変換して、画面上の距離を返す、というものです。</p>

<p>「1ｍは何度か？」は、赤道上の値を使っても良いのですが、緯度によって値が大きく変わるので、このような手法を取りました。</p>

<p>ただこれでも、求める距離の精度によっては、<code>OFFSET_LON</code> の値の調整が必要な気がします。また、経度:0 をまたぐような地域では正しく動かない気がします。(いずれも未検証)</p>

<p>また、緯度方向にもそれなりに正確な数値を出すには、上記と同じことを緯度に対しても行う必要があります。(これは v1 の API にもなかった)</p>

<p>v2 になって、描画系でピクセル座標を意識することはなくなったんであまり使うことも無いと思いますが、なにかで必要になったら思い出す程度で。</p>

<h3>追記</h3>

<p>あとで気づいたんですが、 v1 の <a href="https://developers.google.com/maps/documentation/android/v1/reference/com/google/android/maps/Projection#metersToEquatorPixels(float">Projection.metersToEquatorPixels</a>) は、赤道上の距離で算出してたんですね。それと比べるとちょっとオーバースペックでした。</p>

<p> それと、この記事を書く前に私のツイートを読まれた @honjo2 さんが、 v1 と同じ(赤道の距離を使う)仕様の関数を公開してくださいました。</p>

<blockquote class="twitter-tweet"><p>どうぞ <a href="https://t.co/quYnqvn1tw">https://t.co/quYnqvn1tw</a> RT <a href="https://twitter.com/amay077">@amay077</a>: Google Map Android v2 になって metersToEquatorPixels がなくなっちゃったのが地味に不便だ。</p>&mdash; 本城 博昭 (@honjo2) <a href="https://twitter.com/honjo2/statuses/387368608541589505">October 8, 2013</a></blockquote>


<script async src="http://amay077.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[moveCamera(CameraUpdateFactory.newLatLngBounds で落ちる]]></title>
    <link href="http://amay077.github.io/blog/2013/09/29/movecamera-with-cameraupdatefactory-newlatlngbounds-crashes/"/>
    <updated>2013-09-29T21:16:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/09/29/movecamera-with-cameraupdatefactory-newlatlngbounds-crashes</id>
    <content type="html"><![CDATA[<p>Google Map Android API v2 では、指定した範囲にいいかんじにズームしてくれるメソッドがあって（これを使うと下記事のようなことができる）、とても便利なのですが、普通に使ってたら落ちました（泣</p>

<!--more-->


<ul>
<li><a href="http://tryworks-design.com/?p=1530">Android GooglMapを使い、現在値と目的地を（２点間）を表示させる。 | App Camp</a></li>
</ul>


<p>その理由と、対策を記録しておきます。</p>

<h2>エラーになるコード</h2>

<p>GoogleMap v2 を使ったよくあるコード。</p>

<p>```java MainActivity.java
@Override
protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);

SupportMapFragment fragment = ((SupportMapFragment)getSupportFragmentManager()
        .findFragmentById(R.id.map));
GoogleMap gmap = fragment.getMap();

LatLngBounds bounds = LatLngBounds.builder()
    .include(new LatLng(35.4433011,139.646108)) // 横浜
    .include(new LatLng(35.6846001,139.696919)) // 東京
    .build();

gmap.moveCamera(CameraUpdateFactory.newLatLngBounds(bounds, 15));
</code></pre>

<p>}
```</p>

<p>起動時に、横浜-東京 が画面内に入るようにズームする、つもりのコード。</p>

<p>これは以下のエラーになる。</p>

<blockquote><p>09-29 20:22:58.508: E/AndroidRuntime(18904): FATAL EXCEPTION: main<br/>
09-29 20:22:58.508: E/AndroidRuntime(18904): java.lang.RuntimeException: Unable to start activity ComponentInfo{com.amay077.<br/>android/com.amay077.android.mapsample.view.MainActivity}: java.lang.IllegalStateException: Map size should not be 0. Most likely, layout has not yet occured for the map view.</p></blockquote>

<h2>エラーの原因</h2>

<p>StackOverflow さまに載ってた。</p>

<ul>
<li><a href="http://stackoverflow.com/questions/13692579/movecamera-with-cameraupdatefactory-newlatlngbounds-crashes">android - moveCamera with CameraUpdateFactory.newLatLngBounds crashes - Stack Overflow</a></li>
</ul>


<p>また、<a href="https://developers.google.com/maps/documentation/android/views#changing_camera_position">APIリファレンス</a> にも次のように記載がある。</p>

<blockquote><p>Note: Only use the simpler method newLatLngBounds(boundary, padding) to generate a CameraUpdate if it is going to be used to move the camera after the map has undergone layout. During layout, the API calculates the display boundaries of the map which are needed to correctly project the bounding box. In comparison, you can use the CameraUpdate returned by the more complex method newLatLngBounds(boundary, width, height, padding) at any time, even before the map has undergone layout, because the API calculates the display boundaries from the arguments that you pass.</p></blockquote>

<p>意訳すると <code>newLatLngBounds(boundary, padding)</code> は、レイアウトが完了した後で使ってね、そうでない場合は、<code>newLatLngBounds(boundary, width, height, padding)</code> を使ってね。ということらしい。</p>

<p>確かに <code>onCreate</code> ではまだレイアウトされていないので納得。</p>

<h2>対策</h2>

<p>上の StackOverflow でも解決策として、<code>ViewTreeObserver.addOnGlobalLayoutListener</code> を使って、レイアウトが完了したタイミングで moveCamera する方法が紹介されているが、もうちっとシンプルにできないかなと思っていたところ、ちょうど別件で「ビューのサイズが確定(して Width/Height が取得できる)タイミング」を調べていて、同じく StackOverflow で以下の情報を発見。</p>

<ul>
<li><a href="http://stackoverflow.com/questions/4393612/when-can-i-first-measure-a-view/15301092#15301092">android - When Can I First Measure a View? - Stack Overflow</a></li>
</ul>


<p>これによると <code>view.post(new Runnable() { … })</code> のタイミングでも OK らしいので、今回はこれを使ってみる。</p>

<p>```java MainActivity.java
@Override
protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);

SupportMapFragment fragment = ((SupportMapFragment)getSupportFragmentManager()
        .findFragmentById(R.id.map));
final GoogleMap gmap = fragment.getMap();

// NOTE MainActivity.this.runOnUiThread(new Runnable() { ではダメだった
fragment.getView().post(new Runnable() {
    @Override
    public void run() {
        LatLngBounds bounds = LatLngBounds.builder()
                .include(new LatLng(35.4433011,139.646108)) // 横浜
                .include(new LatLng(35.6846001,139.696919)) // 東京
                .build();

        gmap.moveCamera(CameraUpdateFactory.newLatLngBounds(bounds, 15));
    }
});
</code></pre>

<p>}
```</p>

<p>としたところ、正常に地図がズームされました。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/movecamera_with_cameraupdatefactory_newlatlngbounds_crashes_01.png" alt="img" /></p>

<p>ちなみに、処理をメインスレッド上で行う <code>Activity.runOnUiThread</code> や <code>Handler.post</code> では NG、冒頭と同じエラーでした。処理は UIスレッド上で行われるけど、Map はまだレイアウト未完了、という事だと思います。</p>

<p>起動時の処理は、全ての View で post 内に書いておいた方がいいのかも。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Longitude の略し方。lng 派と lon 派の終わらない争い]]></title>
    <link href="http://amay077.github.io/blog/2013/09/25/the-battle-of-abbreviation-lat-vs-lng/"/>
    <updated>2013-09-25T21:08:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/09/25/the-battle-of-abbreviation-lat-vs-lng</id>
    <content type="html"><![CDATA[<p>地図上での位置は「緯度経度」で表します。英語だと「latitude, longitude」ですね。
これらの単語、コーディングする際は短縮したいわけです。latitude は <code>lat</code> で全会一致です。問題は longitude 。</p>

<!--more-->


<p>業界？の中では、longitude の略し方についての議論が度々沸き起こります。</p>

<p>例えば、、、</p>

<p>初めは、タイトルの議論で推移していましたが、次第に略し方の議論に。。。</p>

<ul>
<li><a href="http://togetter.com/li/85864">latitudeとlongitude，どっちが緯度でどっちが経度？ - Togetter</a></li>
</ul>


<p><code>lon</code> 派の方の意見。</p>

<blockquote class="twitter-tweet"><p>そういえば緯度経度のうち経度（longitude）をlong, lon, lngなどと書く場合があるんだけど、longは長整数型のために予約語になってる場合があるのと、lngだと「イング」と読めてしまうからという理由でlonにしてる。</p>&mdash; Masaki Ohashi (@ohashimasaki) <a href="https://twitter.com/ohashimasaki/statuses/308895891308294144">March 5, 2013</a></blockquote>


<script async src="http://amay077.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p><code>lng</code> 支持？な方々</p>

<blockquote class="twitter-tweet"><p>longitudeの省略形を何にするか迷ってる。lon or lng 今のところlngが優勢。</p>&mdash; 本城 博昭 (@honjo2) <a href="https://twitter.com/honjo2/statuses/28848028079">October 27, 2010</a></blockquote>


<script async src="http://amay077.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>




<blockquote class="twitter-tweet"><p>最近Google Maps APIを触っていたので、CHINTAIの地図で経度(longitude)のパラメータがlngじゃなくてlonなのが新鮮に思えた</p>&mdash; Ryusuke SEKIYAMA (@rsky) <a href="https://twitter.com/rsky/statuses/25312333134">September 23, 2010</a></blockquote>


<script async src="http://amay077.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>振り回されてる方々</p>

<blockquote class="twitter-tweet"><p>lngとlonで５分ハマったー</p>&mdash; ばん↓どう↑さん↓ (@netartjp) <a href="https://twitter.com/netartjp/statuses/379923672632266752">September 17, 2013</a></blockquote>


<script async src="http://amay077.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>




<blockquote class="twitter-tweet"><p>lonとlngのミスで1時間無駄にした</p>&mdash; カメキチ (@kamekiti) <a href="https://twitter.com/kamekiti/statuses/186149216492589056">March 31, 2012</a></blockquote>


<script async src="http://amay077.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>




<blockquote class="twitter-tweet"><p>YahooのローカルサーチAPIのパラメーターの経度情報って、「lon」から始まる値なんですね。他の多くが「lng」な気がするので、始め何でエラーが出るのは分かりませんでした。ということで、ほぼ出来たピョン吉。</p>&mdash; 星野邦敏 (@khoshino) <a href="https://twitter.com/khoshino/statuses/149640555092131842">December 22, 2011</a></blockquote>


<script async src="http://amay077.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>おいマジか Yahoo!（笑</p>

<blockquote class="twitter-tweet"><p>「Y.LatLngオブジェクトのメソッドはlat、lngですが、ローカルサーチAPIのパラメータ名はlat、lonなので注意してください」YOLPで挑戦～「マクドナルドはどこだ」アプリをHTML5で作る！ <a href="http://t.co/QX8yiyvT">http://t.co/QX8yiyvT</a></p>&mdash; NI-Lab. (@nilab) <a href="https://twitter.com/nilab/statuses/189537270347472896">April 10, 2012</a></blockquote>


<script async src="http://amay077.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>とこのように、一つの企業内でも「揺れ」が生じてしまう程度にはバラバラな感じです。</p>

<h2>調べてみた</h2>

<p>で、デファクトスタンダードはどれなのよ？をいろんな地図に関する Web API の仕様から一覧化してみました。</p>

<h3>Lng 派</h3>

<p>Google は神！Google 先生について行きます！</p>

<ul>
<li>Google - https://developers.google.com/maps/documentation/javascript/reference?hl=ja#LatLng</li>
<li>Mapion - http://labs.mapion.co.jp/api/asdoc/index.html</li>
<li>ロケタッチ - http://tou.ch/developer/api_all?uri=spots%2Fsearch</li>
<li>Leaflet - http://leafletjs.com/reference.html#latlng</li>
<li>Yahoo(地図API) - http://developer.yahoo.co.jp/webapi/map/openlocalplatform/v1/js/#index6-2</li>
<li>mapquest - http://www.mapquestapi.com/staticmap/#getmap</li>
</ul>


<h3>Lon 派</h3>

<p>頭から３文字取ったら普通これだろjk</p>

<ul>
<li>Yahoo(ローカルサーチ) - http://developer.yahoo.co.jp/webapi/map/openlocalplatform/v1/localsearch.html</li>
<li>OpenStreetMap - http://wiki.openstreetmap.org/wiki/API_v0.6#Create_a_new_note:<em>Create:</em>POST_.2Fapi.2F0.6.2Fnotes</li>
<li>OpenLayers - http://dev.openlayers.org/docs/files/OpenLayers/BaseTypes/LonLat-js.html ※LonLat！</li>
<li>電子国土Web - http://portal.cyberjapan.jp/site/mapuse4/#zoom=5&amp;lat=35.99989&amp;lon=138.75&amp;layers=BTTT</li>
<li>Elasticsearch - http://www.elasticsearch.org/guide/reference/mapping/geo-point-type/</li>
<li>MongoDB - http://myadventuresincoding.wordpress.com/2011/10/02/mongodb-geospatial-queries/</li>
<li>ゼンリンデータコム(いつもNavi) - http://support.e-map.ne.jp/manuals/V20/index.html?%A5%AF%A5%E9%A5%B9%A5%EA%A5%D5%A5%A1%A5%EC%A5%F3%A5%B9%2FZDC.LatLon</li>
<li>簡易逆ジオコーディングサービス / Finds.jp - http://www.finds.jp/wsdocs/rgeocode/index.html.ja#PARAMS</li>
<li>ジオどす - http://geodosu.com/</li>
<li>モバイラーズオアシスAPI - http://oasis.mogya.com/blog/API</li>
<li>GeOAP(東京ガス) - http://dev.geoap.jp/GeOAP_Course/GeOAP_Trial.asmx?op=CourseLineOfLLToLL</li>
<li>はてなココ - http://c.hatena.ne.jp/s/nearby?lat=36.2648177777778&amp;lon=137.910003611111</li>
<li>Nokia - http://developer.here.com/rest-apis/documentation/enterprise-map-image</li>
</ul>


<h3>Long 派</h3>

<p>「〜itude」は同じなんだから、それより前の部分を省略形にすべきだろ（でっち上げの根拠ですｗ</p>

<ul>
<li>LatLongLab(Yahoo) - http://latlonglab.yahoo.co.jp/</li>
<li>はてなココ - http://developer.hatena.ne.jp/ja/documents/coco/apis/v1/spots#spots</li>
</ul>


<h3>Longitude(略さない)派</h3>

<p>こんなに迷うなら、いっそ省略形など要らぬ！</p>

<ul>
<li>Apple - https://developer.apple.com/library/ios/documentation/CoreLocation/Reference/CoreLocationDataTypesRef/Reference/reference.html</li>
<li>Bing Maps - http://msdn.microsoft.com/en-us/library/gg427612.aspx</li>
<li>Facebook -  https://developers.facebook.com/docs/reference/fql/location_post</li>
<li>Amazon - https://developer.amazon.com/sdk/maps/api-reference.html</li>
<li>Evernote - http://dev.evernote.com/doc/reference/Types.html#Struct_NoteAttributes</li>
<li>Path - https://path.com/developers#tags</li>
</ul>


<h3>緯度経度ペアに名前付けちゃう派</h3>

<p>だってペアじゃないと意味ないじゃん？</p>

<ul>
<li>Twitter(geocode) - https://dev.twitter.com/docs/api/1/get/search (緯度、経度)</li>
<li>Foursquare(ll) - https://developer.foursquare.com/docs/venues/search (緯度、経度)</li>
<li>カーリル図書館情報取得API(geocode) - http://calil.jp/doc/api_ref.html (経度、緯度)</li>
</ul>


<h3>X/Y と同じじゃん派</h3>

<p>所詮座標でしょ？(ﾎｼﾞﾎｼﾞ</p>

<ul>
<li>Solr(pt) - http://docs.lucidworks.com/display/solr/Spatial+Search</li>
<li>Oracle Spatial - http://otndnld.oracle.co.jp/document/products/oracle10g/102/doc_cd/appdev.102/B19243-02/sdo_cs_concepts.htm</li>
<li>PostGIS - http://postgis.net/docs/manual-2.1/using_postgis_dbmanagement.html#RefObject</li>
<li>PlaceEngine - http://www.placeengine.com/doc/tut</li>
</ul>


<h2>まとめ</h2>

<p>数では <code>lon</code> 派が優勢。しかし開発者の目に触れる機会では Google が居る <code>lng</code> の方が多いのかも。
MS、Facebook など、割と巨大企業が 略さない を選択してるのも面白いですね。</p>

<p>ペアに名前を付けるやり方は、座標の順番が 緯度→経度 なのか、経度→緯度 なのか揺れるのであまり好きじゃないですね。</p>

<p>XY と同じ概念で扱うのは、そもそも地図以外での利用を想定していたり、地図でも投影されたXY座標を想定しているものが多いですが、XY と LatLon って、これまた混乱するんですよね。Lat って Y なの？順番逆なの？って。</p>

<p>個人的には 略さない派 だったのですが、そうは言っても短く書きたいので、最近は <code>lon</code> 派です。理由は、</p>

<p><strong>「オレオレ緯度経度クラスを使いたいが、Google に <code>LatLng</code> を取られちゃってるから」</strong></p>

<p>クラス名が衝突すると、いろいろ面倒だし、クラス名に Prefix 付けるのもダサいし。。。</p>

<p>というわけで、終わらない争いと知りつつまとめてみました。
上記に載っていない情報があったら教えてもらえると嬉しいです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.Android での Google Map(というか Play Service) 利用が、本家より簡単になった件]]></title>
    <link href="http://amay077.github.io/blog/2013/08/03/gmapv2-from-xamarin-component/"/>
    <updated>2013-08-03T15:29:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/08/03/gmapv2-from-xamarin-component</id>
    <content type="html"><![CDATA[<p>Xamarin Components に「Google Play Services」が追加されまして。</p>

<!--more-->


<ul>
<li><a href="http://blog.xamarin.com/introducing-the-google-play-services-component-for-xamarin-android/">Introducing the Google Play Services Component for Xamarin.Android | Xamarin Blog</a></li>
</ul>


<p>これが何を意味するかと言うと、これまで Google Play Service を利用するには、ライブラリプロジェクトを作って、アプリから参照するという煩わしい手順が必要でした。</p>

<p>で、これは Android-Eclipse でも同じく面倒だったわけですが、Xamarin.Android  に新しく提供されるこのコンポーネントを使えば、その手間を省くことができます。この点で Eclipse での開発より簡単になりました。</p>

<p>実際に、Play Services の一つである Google Map Android API v2 を使うアプリを作る手順を書いてみます。</p>

<h2>手順</h2>

<h3>1. Google API Console から API key を取得する</h3>

<p>この手順は、これまでと変わらないので、以下のサイトなどを参考にしてください。
package名が必要になるので、先に決めておきましょう。
ここでは <code>com.amay077.sample.googlemapv2sample</code> とします。</p>

<ul>
<li><a href="http://www.adamrocker.com/blog/334/google-maps-android-api-v2.html">throw Life - Google Maps Android API v2を使ってみた</a></li>
</ul>


<p>取得して API key はメモっておきます。</p>

<h3>2. プロジェクト/ソリューションを作る</h3>

<p>Xamarin Studio を起動します。
ここでは Ice Cream Sandwich 用に作ります。(Android Application の方だと Support Library が要るので少し手順が増えるはず)</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/gmapv2_from_xamarin_component_01.png" alt="img" /></p>

<h3>3. プロジェクトに「Google Play Service」コンポーネントを追加する</h3>

<p>メニュー → プロジェクト → Get More Components から、、、</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/gmapv2_from_xamarin_component_03.png" alt="img" /></p>

<p>Google Play Services を検索して Add to App します。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/gmapv2_from_xamarin_component_04.png" alt="img" /></p>

<p>すると、プロジェクトに Google Play Services が追加されます。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/gmapv2_from_xamarin_component_05.png" alt="img" /></p>

<p>ここで一度、Xamarin Studio を再起動しておいた方が無難です。
このまま継続したら、追加されたアセンブリがうまく読み込まれてない場合がありました。</p>

<h3>4. 実装する</h3>

<p><code>MainActivity.cs</code> は、最初の内容をごっそり削除して以下のようにします。</p>

<p>```c# MainActivity.cs
using Android.App;
using Android.OS;</p>

<p>namespace GoogleMapV2Sample
{</p>

<pre><code>[Activity (Label = "GoogleMapV2Sample", MainLauncher = true)]
public class MainActivity : Activity
{
    protected override void OnCreate(Bundle bundle)
    {
        base.OnCreate(bundle);

        // Set our view from the "main" layout resource
        SetContentView(Resource.Layout.Main);
    }
}
</code></pre>

<p>}
```</p>

<p>画面定義である <code>Main.axml</code> も以下のように置き換えます。</p>

<p>```xml Resources/layout/Main.axml
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;fragment xmlns:android="http://schemas.android.com/apk/res/android"</p>

<pre><code>android:id="@+id/map"
android:layout_width="match_parent"
android:layout_height="match_parent"
class="com.google.android.gms.maps.MapFragment" /&gt;
</code></pre>

<p>```</p>

<h3>5. AndroidManifest.xml への設定いろいろ</h3>

<p>たぶん一番面倒なところです。</p>

<p>まず Xamarin.Android では、最初は AndroidManifest.xml が生成されていないので、メニュー → プロジェクト → xxx のオプション から、下図のように [Add Android manifest] します。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/gmapv2_from_xamarin_component_06.png" alt="img" /></p>

<p>次に作成された AndroidManifest.xml を開いて、以下のようにします。</p>

<p>※1 のところは、最初に決めた Package名に、※2 の時は、先に取得しておいた API key に置き換えてください。</p>

<p>```xml Properties/AndroidManifest.xml
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"</p>

<pre><code>android:versionCode="1" 
android:versionName="1.0" 
package="com.amay077.sample.googlemapv2sample"&gt;  &lt;--------※1


&lt;uses-feature android:glEsVersion="0x00020000" android:required="true" /&gt;
&lt;uses-permission android:name="android.permission.INTERNET" /&gt;
&lt;uses-permission android:name="com.google.android.providers.gsf.permission.READ_GSERVICES" /&gt;
&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;


&lt;uses-permission 
    android:name="com.amay077.sample.playservicesample.permission.MAPS_RECEIVE" /&gt;   &lt;--------※1
&lt;permission 
    android:name="com.amay077.sample.playservicesample.permission.MAPS_RECEIVE"   &lt;--------※1
    android:protectionLevel="signature" /&gt;

&lt;application android:label="GoogleMapV2Sample"&gt;
    &lt;meta-data 
        android:name="com.google.android.maps.v2.API_KEY" 
        android:value="AIzaByD1jiFER3le_HFrkOrEhaNIsemoNoDesuU" /&gt;  &lt;--------※2
&lt;/application&gt;
</code></pre>

<p></manifest>
```</p>

<h3>6. 動かす</h3>

<p>設定が正しくできていれば、地図が表示されるはずです。
アプリが落ちるなら Main.cs や Main.axml が、地図が表示されないなら AndroidManifest.xml や Google API Console での設定が間違っていると思います。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/gmapv2_from_xamarin_component_07.png" alt="img" /></p>

<h2>まとめなど</h2>

<p>Google Play Service コンポーネントを使うことでライブラリプロジェクトをなくす事ができました。慣れた人にはどうってこと無い話ですが、説明する人には面倒で、始めて行う人には混乱の元になってたと思います。</p>

<p>もう一つ特筆すべきは、このコンポーネントを Google 自身が開発、提供していることです。</p>

<p>これだけでなく、<a href="http://components.xamarin.com/view/googlemapsios/">Google Map SDK for iOS</a> や <a href="http://components.xamarin.com/view/googleadmob/">Admob 用のコンポーネント</a>も Google 自身が提供しています。</p>

<p>また Microsoft も <a href="http://components.xamarin.com/view/azure-mobile-services/">Azure Mobile Service</a> を自身が提供していますし、なんなんでしょうこのプラットフォーマーの Xamarin への参入ぶりは。</p>

<p>このように本家が開発していることにより、信頼性、機能網羅性、新機能への追従などがとても充実しており、安心して使うことができます。</p>

<p>最後に、</p>

<blockquote class="twitter-tweet"><p>おおおお、すげえ！これでめんどいビルド手順必要なくなった！Google++！でも、Gmaps iOSの1.4アップデートと、Retina対応のため128dpタイルへの対応もしてください…。 / “Google Play Servi…” <a href="http://t.co/mjnN7sE0t7">http://t.co/mjnN7sE0t7</a></p>&mdash; Кочизуфан (@kochizufan) <a href="https://twitter.com/kochizufan/statuses/363116371351052290">August 2, 2013</a></blockquote>


<script async src="http://amay077.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>とのことなのでよろしくおねがいします。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fused Location Provider を近くのショッピングセンターで評価してみた]]></title>
    <link href="http://amay077.github.io/blog/2013/05/30/testing-fused-location-provider/"/>
    <updated>2013-05-30T21:31:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/05/30/testing-fused-location-provider</id>
    <content type="html"><![CDATA[<p>Android に新しく搭載された Fused Location Provider、これは GPS/WiFi/センサーを統合的に使ってその時ベストな位置を取得できるというもので、<a href="http://www.youtube.com/watch?feature=player_detailpage&amp;v=URcVZybzMUI#t=733s">Google I/O のデモ</a> が衝撃的だったので、自分でも試してみました。</p>

<!--more-->


<h2>検証環境とか</h2>

<ul>
<li>場所 : イオン豊橋南店（ええ田舎ですが何か？</li>
<li>日時 : 2013/05/30 17:30頃</li>
<li>天候 : 小雨（曇天だったので GPS は捕まえにくかったかも）</li>
<li>端末 : au HTC J(!蝶) OS は 4.0.4</li>
<li>GPS も WiFi も ON</li>
<li>Android SDK Tools : rev.21.1</li>
<li>Google Play service : rev.7</li>
<li>FusedProvider の Priority : PRIORITY_HIGH_ACCURACY</li>
<li>位置取得間隔 : 5秒</li>
<li>姿勢 : スマホを常に左手で掲げて、見ながら歩きました。</li>
</ul>


<h2>その1:駐車場〜1F〜駐車場</h2>

<p>駐車場に車を停めて、歩いて店内に入場、店内をなるべくゆっくり直線的にぐるっと徘徊して、退店、駐車場を歩いて戻って来ました。</p>

<p>緑が実際の経路、青が Fused Provider の経路です。</p>

<iframe width="425" height="350" frameborder="0" scrolling="no" marginheight="0" marginwidth="0" src="https://maps.google.co.jp/maps/ms?msa=0&amp;msid=206106708723125678709.0004ddec1d5240e6ba1d3&amp;brcurrent=3,0x6004d3ebe16cdde1:0xfb92e7477942b89b,0&amp;ie=UTF8&amp;t=h&amp;ll=34.709597,137.387786&amp;spn=0.001372,0.001735&amp;output=embed"></iframe>


<br /><small><a href="https://maps.google.co.jp/maps/ms?msa=0&amp;msid=206106708723125678709.0004ddec1d5240e6ba1d3&amp;brcurrent=3,0x6004d3ebe16cdde1:0xfb92e7477942b89b,0&amp;ie=UTF8&amp;t=h&amp;ll=34.709597,137.387786&amp;spn=0.001372,0.001735&amp;source=embed" style="color:#0000FF;text-align:left">FusedProviderの評価(イオン豊橋南店1F)</a> を表示</small>


<h2>その2:駐車場〜1F〜2F〜ぐるっと〜1F〜駐車場</h2>

<p>もう一度。
今度は入店してすぐエスカレータで2Fへ。2Fフロアをぐるっと回ってからエスカレータで1Fへ降りて駐車場へ戻って来ました。</p>

<iframe width="425" height="350" frameborder="0" scrolling="no" marginheight="0" marginwidth="0" src="https://maps.google.co.jp/maps/ms?t=h&amp;brcurrent=3,0x6004d3ec8f3f5bf5:0x7b6f4e2f69453e37,1&amp;msa=0&amp;msid=206106708723125678709.0004ddec316197e38b987&amp;source=embed&amp;ie=UTF8&amp;ll=34.709546,137.388057&amp;spn=0.003479,0.004517&amp;output=embed"></iframe>


<br /><small>大きな地図で <a href="https://maps.google.co.jp/maps/ms?t=h&amp;brcurrent=3,0x6004d3ec8f3f5bf5:0x7b6f4e2f69453e37,1&amp;msa=0&amp;msid=206106708723125678709.0004ddec316197e38b987&amp;source=embed&amp;ie=UTF8&amp;ll=34.709546,137.388057&amp;spn=0.003479,0.004517" style="color:#0000FF;text-align:left">FusedProviderの評価(イオン豊橋南店2F)</a> を表示</small>


<h2>結果をみて</h2>

<p>うーん、かいかぶり過ぎたか Fused Provider。</p>

<p>確かに GPS と WiFi をシームレスに扱ってくれているようですが、期待していた屋内での測位結果はちょっと残念でした。</p>

<p>I/O のセッションの中では、WiFi+Sensor を使ってると言っていたので、WiFi-AP の電波強度と加速度センサーの振れ具合で自律測位してくれるのかなあと思ったのですが、あまり自律測位が機能してないように見えます。</p>

<h3>Accuracy は？</h3>

<p>屋外だとだいたい 10m前後、屋内でも 20〜40m くらいの精度でした。
上図の幅が約200mですが、実際の位置よりもっと離れている感じがします。</p>

<p>Fused Provider を使うと、妙に Accuracy が小さい(精度の良い)値が得られるのですが、実際の位置がその精度が示す円の中にも入らないこともあり、それなら高い確率で実際の位置を包括する（精度の悪い）WiFi or 基地局測位 の方が有用では？とも思えました。</p>

<p>また、施設内に WiFi-AP が何個あったとかの細かい調査はしていません（たぶん５〜６個）が、都会の繁華街とか地下街の方が圧倒的に多いと思うので、また違った結果が出るものと思います。</p>

<h3>GPS の動きは？</h3>

<p>今回は <code>PRIORITY_HIGH_ACCURACY</code> を使いました。これは GPS を使います。(<code>PRIORITY_BALANCED_POWER_ACCURACY</code> は GPS を使いません［が、 <code>ACCESS_FINE_LOCATION</code> を付けないと精度が数kmレベルになります。］)</p>

<p>記録中の GPS アイコンの動きは、点滅 → 数秒後消える → また点滅 → GPSを捕捉したらつきっぱなし という感じで、屋外に移動すると GPS を捕まえる、屋内では度々トライするが捕まえられないのですぐ消える。という動きをしてました。</p>

<h3>状態認識は貢献してるのか？</h3>

<p>自律測位に状態認識(Activity Recognition)がもし使われているなら、持ちながらよりも、ポケットに入れっぱで歩いた方に最適化されてたかも知れないなあと思ったり。</p>

<p><a href="http://amay077.github.io/blog/2013/05/18/getting-started-activity-recognition/">ActivityRecognitionClient を試した</a> 時も、持ちながらよりも尻ポケに入れたまま歩いた方が認識されやすい気がしました。気だけですが。</p>

<h2>まとめ</h2>

<ul>
<li>Fused Provider に期待しすぎないでください</li>
<li>実際の位置から（精度値を超えて）大きく外れることもあるのが困る</li>
<li>パワーマネジメントはなんかやってるぽい（計測してないけど）</li>
</ul>

]]></content>
  </entry>
  
</feed>
