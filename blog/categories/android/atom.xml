<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Experiments Never Fail]]></title>
  <link href="http://amay077.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://amay077.github.io/"/>
  <updated>2013-10-17T21:19:20+09:00</updated>
  <id>http://amay077.github.io/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[TextView で、テキストの一部だけクリック可能にする]]></title>
    <link href="http://amay077.github.io/blog/2013/10/17/make-clickable-from-part-of-text/"/>
    <updated>2013-10-17T21:16:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/10/17/make-clickable-from-part-of-text</id>
    <content type="html"><![CDATA[<p>Android の TextView で、「テキストの一部を押すとなんかのアクションが起こる」というのが <code>ClickableSpan</code> というのを使えばできそうだったので、やってみました。</p>

<!--more-->


<p>```java ClikcableSpanTestActivity.java
public class ClikcableSpanTestActivity extends Activity {</p>

<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    final List&lt;Pair&lt;String, String&gt;&gt; data = new ArrayList&lt;Pair&lt;String,String&gt;&gt;();
    data.add(new Pair&lt;String, String&gt;("りんご", "隠し味としてカレーに入れます"));
    data.add(new Pair&lt;String, String&gt;("みかん", "あぶりだしに使います"));
    data.add(new Pair&lt;String, String&gt;("すいか", "種を食べると盲腸になります（嘘）"));

    final SpannableStringBuilder sb = new SpannableStringBuilder();
    final String SEP = ", ";
    int spanStart = 0;

    for (final Pair&lt;String, String&gt; p : data) {
        sb.append(p.first);
        sb.append(SEP);

        // 追加した文字列を Span にする
        sb.setSpan(new ClickableSpan() {
            @Override
            public void onClick(View widget) {
                Toast.makeText(getApplicationContext(), 
                    p.second, Toast.LENGTH_SHORT).show();
            }
        }, spanStart, spanStart + p.first.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);

        spanStart += (p.first.length() + SEP.length());
    }

    TextView tv = (TextView)findViewById(R.id.text);
    tv.setText(sb);
    tv.setMovementMethod(LinkMovementMethod.getInstance()); // これ忘れるとクリックできなくて小一時間悩む
}
</code></pre>

<p>}
```</p>

<p>項目をカンマつなぎで表示して、項目のところだけリンクっぽくします。
リンクをクリックすると Toast を表示します。（下図のように）
また <code>URLSpan</code> というクラスもあり、クリックすると指定したURLに移動（ブラウザアプリが起動）します。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/using_clickablespan_01.png" alt="" /></p>

<h2>参考</h2>

<p>装飾したり位置やサイズ変えたり、TextView でもいろいろできるんですねー。
(VB6の)Label とは違うのだよ、Label とは！</p>

<ul>
<li><a href="http://y-anz-m.blogspot.com/2011/08/androidspannable.html">Y.A.M の 雑記帳: Android Spannable を使って文字列の一部を装飾する</a></li>
<li><a href="http://d.hatena.ne.jp/androidprogram/20100529/1275086958">Tips TextView を使いこなそう ～表示編～ その4 - - Google Android - 雑記帳</a></li>
<li><a href="http://developer.android.com/reference/android/text/style/package-summary.html">android.text.style | Android Developers</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[metersToEquatorPixels を Google Maps Android API v2 で]]></title>
    <link href="http://amay077.github.io/blog/2013/10/09/meterstoequatorpixels-in-gmap-v2/"/>
    <updated>2013-10-09T00:21:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/10/09/meterstoequatorpixels-in-gmap-v2</id>
    <content type="html"><![CDATA[<p>Google Map API v1 には、「地図上の距離(ｍ)を画面上の距離(ピクセル)に変換する」ためのメソッド <a href="https://developers.google.com/maps/documentation/android/v1/reference/com/google/android/maps/Projection#metersToEquatorPixels(float">Projection.metersToEquatorPixels</a>) がありましたが、v2 ではなくなってしまいました。</p>

<!--more-->


<p>ので、以下のような代替関数を作ってみました。</p>

<p>```java metersToEquatorPixels.java
public static int metersToEquatorPixels(GoogleMap map, LatLng base, float meters) {</p>

<pre><code>final double OFFSET_LON = 0.5d;

Location baseLoc = new Location("");
baseLoc.setLatitude(base.latitude);
baseLoc.setLongitude(base.longitude);

Location dest = new Location("");
dest.setLatitude(base.latitude);
dest.setLongitude(base.longitude + OFFSET_LON);

double degPerMeter = OFFSET_LON / baseLoc.distanceTo(dest); // 1m は何度？
double lonDistance = meters * degPerMeter; // m を度に変換

Projection proj = map.getProjection();
Point basePt = proj.toScreenLocation(base);
Point destPt = proj.toScreenLocation(new LatLng(base.latitude, base.longitude + lonDistance));

return Math.abs(destPt.x - basePt.x);
</code></pre>

<p>}
```</p>

<p>行っていることは単純で、基準となる緯度経度:<code>base</code> から、適当に(ここでは 0.5度)東へ移動した緯度経度を <code>Location.distanceTo</code> で求め、その結果から、「1ｍは何度か？」を求めます。あとは、この係数を使って 地図上の距離:<code>meters</code> を度に変換し、最後に、<code>base</code> と移動後の緯度経度それぞれを画面座標に変換して、画面上の距離を返す、というものです。</p>

<p>「1ｍは何度か？」は、赤道上の値を使っても良いのですが、緯度によって値が大きく変わるので、このような手法を取りました。</p>

<p>ただこれでも、求める距離の精度によっては、<code>OFFSET_LON</code> の値の調整が必要な気がします。また、経度:0 をまたぐような地域では正しく動かない気がします。(いずれも未検証)</p>

<p>また、緯度方向にもそれなりに正確な数値を出すには、上記と同じことを緯度に対しても行う必要があります。(これは v1 の API にもなかった)</p>

<p>v2 になって、描画系でピクセル座標を意識することはなくなったんであまり使うことも無いと思いますが、なにかで必要になったら思い出す程度で。</p>

<h3>追記</h3>

<p>あとで気づいたんですが、 v1 の <a href="https://developers.google.com/maps/documentation/android/v1/reference/com/google/android/maps/Projection#metersToEquatorPixels(float">Projection.metersToEquatorPixels</a>) は、赤道上の距離で算出してたんですね。それと比べるとちょっとオーバースペックでした。</p>

<p> それと、この記事を書く前に私のツイートを読まれた @honjo2 さんが、 v1 と同じ(赤道の距離を使う)仕様の関数を公開してくださいました。</p>

<blockquote class="twitter-tweet"><p>どうぞ <a href="https://t.co/quYnqvn1tw">https://t.co/quYnqvn1tw</a> RT <a href="https://twitter.com/amay077">@amay077</a>: Google Map Android v2 になって metersToEquatorPixels がなくなっちゃったのが地味に不便だ。</p>&mdash; 本城 博昭 (@honjo2) <a href="https://twitter.com/honjo2/statuses/387368608541589505">October 8, 2013</a></blockquote>


<script async src="http://amay077.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[moveCamera(CameraUpdateFactory.newLatLngBounds で落ちる]]></title>
    <link href="http://amay077.github.io/blog/2013/09/29/movecamera-with-cameraupdatefactory-newlatlngbounds-crashes/"/>
    <updated>2013-09-29T21:16:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/09/29/movecamera-with-cameraupdatefactory-newlatlngbounds-crashes</id>
    <content type="html"><![CDATA[<p>Google Map Android API v2 では、指定した範囲にいいかんじにズームしてくれるメソッドがあって（これを使うと下記事のようなことができる）、とても便利なのですが、普通に使ってたら落ちました（泣</p>

<!--more-->


<ul>
<li><a href="http://tryworks-design.com/?p=1530">Android GooglMapを使い、現在値と目的地を（２点間）を表示させる。 | App Camp</a></li>
</ul>


<p>その理由と、対策を記録しておきます。</p>

<h2>エラーになるコード</h2>

<p>GoogleMap v2 を使ったよくあるコード。</p>

<p>```java MainActivity.java
@Override
protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);

SupportMapFragment fragment = ((SupportMapFragment)getSupportFragmentManager()
        .findFragmentById(R.id.map));
GoogleMap gmap = fragment.getMap();

LatLngBounds bounds = LatLngBounds.builder()
    .include(new LatLng(35.4433011,139.646108)) // 横浜
    .include(new LatLng(35.6846001,139.696919)) // 東京
    .build();

gmap.moveCamera(CameraUpdateFactory.newLatLngBounds(bounds, 15));
</code></pre>

<p>}
```</p>

<p>起動時に、横浜-東京 が画面内に入るようにズームする、つもりのコード。</p>

<p>これは以下のエラーになる。</p>

<blockquote><p>09-29 20:22:58.508: E/AndroidRuntime(18904): FATAL EXCEPTION: main<br/>
09-29 20:22:58.508: E/AndroidRuntime(18904): java.lang.RuntimeException: Unable to start activity ComponentInfo{com.amay077.<br/>android/com.amay077.android.mapsample.view.MainActivity}: java.lang.IllegalStateException: Map size should not be 0. Most likely, layout has not yet occured for the map view.</p></blockquote>

<h2>エラーの原因</h2>

<p>StackOverflow さまに載ってた。</p>

<ul>
<li><a href="http://stackoverflow.com/questions/13692579/movecamera-with-cameraupdatefactory-newlatlngbounds-crashes">android - moveCamera with CameraUpdateFactory.newLatLngBounds crashes - Stack Overflow</a></li>
</ul>


<p>また、<a href="https://developers.google.com/maps/documentation/android/views#changing_camera_position">APIリファレンス</a> にも次のように記載がある。</p>

<blockquote><p>Note: Only use the simpler method newLatLngBounds(boundary, padding) to generate a CameraUpdate if it is going to be used to move the camera after the map has undergone layout. During layout, the API calculates the display boundaries of the map which are needed to correctly project the bounding box. In comparison, you can use the CameraUpdate returned by the more complex method newLatLngBounds(boundary, width, height, padding) at any time, even before the map has undergone layout, because the API calculates the display boundaries from the arguments that you pass.</p></blockquote>

<p>意訳すると <code>newLatLngBounds(boundary, padding)</code> は、レイアウトが完了した後で使ってね、そうでない場合は、<code>newLatLngBounds(boundary, width, height, padding)</code> を使ってね。ということらしい。</p>

<p>確かに <code>onCreate</code> ではまだレイアウトされていないので納得。</p>

<h2>対策</h2>

<p>上の StackOverflow でも解決策として、<code>ViewTreeObserver.addOnGlobalLayoutListener</code> を使って、レイアウトが完了したタイミングで moveCamera する方法が紹介されているが、もうちっとシンプルにできないかなと思っていたところ、ちょうど別件で「ビューのサイズが確定(して Width/Height が取得できる)タイミング」を調べていて、同じく StackOverflow で以下の情報を発見。</p>

<ul>
<li><a href="http://stackoverflow.com/questions/4393612/when-can-i-first-measure-a-view/15301092#15301092">android - When Can I First Measure a View? - Stack Overflow</a></li>
</ul>


<p>これによると <code>view.post(new Runnable() { … })</code> のタイミングでも OK らしいので、今回はこれを使ってみる。</p>

<p>```java MainActivity.java
@Override
protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);

SupportMapFragment fragment = ((SupportMapFragment)getSupportFragmentManager()
        .findFragmentById(R.id.map));
final GoogleMap gmap = fragment.getMap();

// NOTE MainActivity.this.runOnUiThread(new Runnable() { ではダメだった
fragment.getView().post(new Runnable() {
    @Override
    public void run() {
        LatLngBounds bounds = LatLngBounds.builder()
                .include(new LatLng(35.4433011,139.646108)) // 横浜
                .include(new LatLng(35.6846001,139.696919)) // 東京
                .build();

        gmap.moveCamera(CameraUpdateFactory.newLatLngBounds(bounds, 15));
    }
});
</code></pre>

<p>}
```</p>

<p>としたところ、正常に地図がズームされました。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/movecamera_with_cameraupdatefactory_newlatlngbounds_crashes_01.png" alt="img" /></p>

<p>ちなみに、処理をメインスレッド上で行う <code>Activity.runOnUiThread</code> や <code>Handler.post</code> では NG、冒頭と同じエラーでした。処理は UIスレッド上で行われるけど、Map はまだレイアウト未完了、という事だと思います。</p>

<p>起動時の処理は、全ての View で post 内に書いておいた方がいいのかも。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自作ビューで layout_width のマネをしたい時]]></title>
    <link href="http://amay077.github.io/blog/2013/09/26/layout-widh-like-property-in-custom-view/"/>
    <updated>2013-09-26T23:55:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/09/26/layout-widh-like-property-in-custom-view</id>
    <content type="html"><![CDATA[<p><code>android:layout_width</code> って、型は <code>dimension</code> であるのに、Layout XML には、 <code>"match_parent"</code> とか <code>"wrap_content"</code> とか指定できる。これと同じことを自作ビューの自作プロパティでやりたい。</p>

<!--more-->


<p>自作ビュー(カスタムビュー)の作りかたは下などを参照。</p>

<ul>
<li><a href="http://techbooster.org/android/application/7361/">Androidでxmlファイルを用いてカスタムViewを作る方法 | Tech Booster</a></li>
</ul>


<p>で、<code>android:layout_width</code> のマネをするには、 attrs.xml に以下のように書く。</p>

<p>```xml attrs.xml
&lt;?xml version="1.0" encoding="utf-8"?>
<resources>
  <declare-styleable name="MyCustomView"></p>

<pre><code>&lt;attr name="my_width" format="dimension"&gt;
  &lt;enum name="fill_parent" value="-1" /&gt;
  &lt;enum name="match_parent" value="-1" /&gt;
  &lt;enum name="wrap_content" value="-2" /&gt;
&lt;/attr&gt;
</code></pre>

<p>  </declare-styleable>
</resources>
```</p>

<p>Android Framework のソースコードにこう書いてあったので、真似しただけ。</p>

<ul>
<li><a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.3_r2.1/frameworks/base/core/res/res/values/attrs.xml">GrepCode: frameworks / base / core / res / res / values / attrs.xml - Source Code View</a></li>
</ul>


<p>自作ビューの実装クラスで、この値を読み込む時は、<code>TypedArray.getLayoutDimension</code> を使う。</p>

<p>```java MyCustomView.java
public MyCustomView(Context context, AttributeSet attrs) {</p>

<pre><code>super(context, attrs);

TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.MyCustomView, 0, 0);

_myWidth = a.getLayoutDimension(R.styleable.MyCustomView_my_width, 
        LayoutParams.WRAP_CONTENT);

a.recycle();
</code></pre>

<p>}
```</p>

<p>Android Framework 側で仕様が増えた時は、追従しないといかんのかー。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[スレッドの優先度について調べた]]></title>
    <link href="http://amay077.github.io/blog/2013/09/04/understanding-android-thread-priority/"/>
    <updated>2013-09-04T22:22:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/09/04/understanding-android-thread-priority</id>
    <content type="html"><![CDATA[<p>Android にも(Java ですから)スレッドの優先度ってありますけど、それちゃんと動きますよね？というのを ExecurorService を使って調べた。</p>

<!--more-->


<h2>ThreadFactory の拡張</h2>

<p><code>ExecutorService</code> が作るスレッドは、何もしないと 優先度:中 になる模様。
これを変更するには、生成時(<code>newSingleThreadExecutor</code>) に渡す <code>ThreadFactory</code> を自前で実装して、<code>Thread.setPriority</code> してやる。</p>

<p><code>ThreadFactory</code> を Implements したクラス作ってもいいけど、そこまでやる必要も無いでしょ。</p>

<p>```java
// 指定した Priority の ThreadFactory を生成して返す
private ThreadFactory makeThreadFactory(final int priority) {</p>

<pre><code>return new ThreadFactory() {

    @Override
    public Thread newThread(Runnable r) {
        Thread thread = new Thread(r);
        thread.setPriority(priority);
        return thread;
    }
};
</code></pre>

<p>}</p>

<p>// 使ってみる
private void testExecutor() {</p>

<pre><code>final ExecutorService executor = 
    Executors.newSingleThreadExecutor(makeThreadFactory(Thread.MIN_PRIORITY));

executor.submit(new Runnable() {
    @Override
    public void run() {
        // なにかの処理
    }
});
</code></pre>

<p>}
```</p>

<h2>優先度が考慮されるかの検証</h2>

<p>設定した Priority が正しく機能するのか試してみた。</p>

<h3>検証方法</h3>

<ul>
<li>MIN, NORMAL, MAX の優先度を設定をした、SingleThread な Executor を1つずつ、計３つ生成。</li>
<li>３つの Executor に、タスクをじゃんじゃん投入(submit)する。</li>
<li>タスクの処理が開始された所をログ出力して、その順番を調べる。</li>
</ul>


<h3>検証コード</h3>

<p>上を実装したのがこれ。<code>CountDownLatch</code> で待ち合わせするのがなんだかなぁって感じだがまあいいや。</p>

<p>```java
private ThreadFactory makeThreadFactory(final int priority) {</p>

<pre><code>// 上と同じなので省略
</code></pre>

<p>}</p>

<p>// タスクを生成する
private Runnable makeTask(final String tag, final StringBuffer buffer,</p>

<pre><code>    final CountDownLatch latch) {
return new Runnable() {
    @Override
    public void run() {
        // タスクが開始された時に、A or B or C を追加してく
        buffer.append(tag); // StringBuffer は Thread-safe なハズだ

        // Wait
        for (int j = 0; j &lt; 1000000; j++) { } 

        latch.countDown();
    }
};
</code></pre>

<p>}</p>

<p>// 検証実行
public void testThreadPriority() throws InterruptedException {</p>

<pre><code>// MIN, NORMAL, MAX な Priority の Executor を生成
final ExecutorService minExecutor = 
        Executors.newSingleThreadExecutor(makeThreadFactory(Thread.MIN_PRIORITY));
final ExecutorService norExecutor = 
        Executors.newSingleThreadExecutor(makeThreadFactory(Thread.NORM_PRIORITY));
final ExecutorService maxExecutor = 
        Executors.newSingleThreadExecutor(makeThreadFactory(Thread.MAX_PRIORITY));

final CountDownLatch latch = new CountDownLatch(100 * 3);
final StringBuffer builder = new StringBuffer();

// それぞれの Executor にじゃんじゃんタスクを投入
for (int i = 0; i &lt; 100; i++) {
    minExecutor.submit(makeTask("C", builder, latch)); // MIN-&gt;"C"
    norExecutor.submit(makeTask("B", builder, latch)); // NORMAL-&gt;"B"
    maxExecutor.submit(makeTask("A", builder, latch)); // MAX-&gt;"A"
}

// 全部のタスクが終わるのを待つ
latch.await();
Log.d(TAG, builder.toString()); // タスクが処理された順番を出力
</code></pre>

<p>}
```</p>

<h3>検証結果(HTC J)</h3>

<h4>1回目</h4>

<blockquote><p>BAACAAABABABABABABABABABABABABABABABABACACACACBAABABABABABAB
ABABABABABABACBAABABABABABABABAABBABABABABABAABABABABABABABA
BABABABAABABABABABABABABABABABAABABABABABABABABABABABABABABA
BABABABABABABABCBBBBCBBCBCBBCBCBCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</p></blockquote>

<h4>2回目</h4>

<blockquote><p>CBACABAABABABABABABAABABABABABABABABABACBABABABAABABBABABABA
ABABABABABABABABABABABABABABABABABABABABABABABABABABAABABABA
BABABABABBABAABABABABABABABABABABABABABABABABABCABABABABABAB
ABABABABABABAABABABBCBCBBCBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</p></blockquote>

<h4>3回目</h4>

<blockquote><p>BAACAABABABAABABABABABABABABABABABABABABABABABABABABABABABAB
ABABABABABABABABABABABABABABABABABABABABABABABABABABABABABAB
ABABABABABABABABABABABABABACBABABABABABABABABABABABABABABABA
BABABABAABABABABABCBBCBCBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</p></blockquote>

<p>"C"(優先度:MIN) のタスクが後ろの方に追いやられているのが分かる。
"A"(MAX) と "B"(NORMAL) の差ははっきりとはわからないが、それでも "A" の方が先に全部終わっているので優先されているのがなんとか分かる。</p>

<h2>まとめ</h2>

<p>優先度の変更、ちゃんと効果あるんですね。</p>

<p>よく調べると Android には <code>android.os.Process.setThreadPriority()</code> というのもあるそうで。</p>

<ul>
<li><a href="http://mikanbako.blog.shinobi.jp/android/android.os.process.setthreadpriority--%E3%81%A8java.lang.thread.setpriority--%E3%81%AE%E5%8A%B9%E6%9E%9C%E3%81%AF%E5%90%8C%E3%81%98">android.os.Process.setThreadPriority()とjava.lang.Thread.setPriority()の効果は同じ - みかん箱</a></li>
</ul>


<blockquote><p>結果、両者の効果は同じです。ただし、android.os.Processではスレッドの優先度が用途ごとに定数として定義されているため、まずandroid.os.Process.setThreadPriority()の使用を検討すべきでしょう。</p></blockquote>

<p>とのこと。確かに <code>THREAD_PRIORITY_FOREGROUND</code>, <code>THREAD_PRIORITY_AUDIO</code>, <code>THREAD_PRIORITY_LOWEST</code> などが定義されているので、こちらを使った方が良さげですね。
個人的には、Java の API でできる事はその範囲で閉じてしまいたいのですがね。</p>
]]></content>
  </entry>
  
</feed>
