<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | Experiments Never Fail]]></title>
  <link href="http://blog.amay077.net/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://blog.amay077.net/"/>
  <updated>2014-11-10T01:33:47+09:00</updated>
  <id>http://blog.amay077.net/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[「チェックAがONならば、項目Bは入力必須とする」という Validation を RxJava + RxAndroid でやる]]></title>
    <link href="http://blog.amay077.net/blog/2014/11/10/complex-validation-with-rxjava-and-rxandroid/"/>
    <updated>2014-11-10T01:32:20+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/11/10/complex-validation-with-rxjava-and-rxandroid</id>
    <content type="html"><![CDATA[<p>　例えばショッピングサイトとかの発送先指定のフォーム『登録されている住所とは違う住所に送りたい時、「別の住所に送る」をチェックする、すると「住所2」が必須入力となり、入力するまで次へ進めない』的なちょっと込み入ったValidationをReactive ExtensionsのJava版、<a href="https://github.com/ReactiveX/RxJava">RxJava</a>と<a href="https://github.com/ReactiveX/RxAndroid">RxAndroid</a>でやってみました。</p>

<!--more-->


<h1>動作イメージ</h1>

<p>　まずいきなり動作結果から。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/complex_validation_with_rxjava_and_rxandroid.gif" alt="" /></p>

<ul>
<li>住所1は入力必須。</li>
<li>住所2は「住所2へ配送する」がチェックされている場合のみ、入力必須。</li>
<li>必須項目が入力されていない場合はボタンを押せない</li>
</ul>


<p>こんな仕様です。</p>

<h1>実装</h1>

<p>```java
@Override
protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
setContentView(R.layout.activity_my);

// 「注文を確定する」ボタン
final Button buttonSubmit = (Button)findViewById(R.id.buttonSubmit);

// チェックボックスのON/OFFをObservable化
final Observable&lt;Boolean&gt; useSecondaryAddress =
        ViewObservable.input((CheckBox) findViewById(R.id.checkUseSecondary), true)
        .map(new Func1&lt;OnCheckedChangeEvent, Boolean&gt;() {
            @Override
            public Boolean call(OnCheckedChangeEvent onCheckedChangeEvent) {
                return onCheckedChangeEvent.value;
            }
        });

// 住所1をObservable化
final Observable&lt;OnTextChangeEvent&gt; primaryAddress =
        ViewObservable.text((EditText) findViewById(R.id.editPrimaryAddress), true);
// 住所2をObservable化
final Observable&lt;OnTextChangeEvent&gt; secondaryAddress =
        ViewObservable.text((EditText) findViewById(R.id.editSecondaryAddress), true);

// チェックボックスと住所2の必須条件をObservable化
final Observable&lt;Boolean&gt; secondaryIsValid = 
    Observable.combineLatest(useSecondaryAddress, secondaryAddress,
        new Func2&lt;Boolean, OnTextChangeEvent, Boolean&gt;() {
            @Override
            public Boolean call(Boolean useSecondary, OnTextChangeEvent secondaryAddress) {
                if (!useSecondary) {
                    return true;
                }

                return !TextUtils.isEmpty(secondaryAddress.text);
            }
        });


// 全部まとめると、
//  住所1は入力必須、
//  住所2はチェックボックスがONの時だけ入力必須
//  必須条件を満たしていたらtrueを流す
final Observable&lt;Boolean&gt; isValidAll = Observable.combineLatest(primaryAddress, secondaryIsValid,
        new Func2&lt;OnTextChangeEvent, Boolean, Boolean&gt;() {
            @Override
            public Boolean call(OnTextChangeEvent primaryAddress, Boolean isValidSecondary) {
                if (!isValidSecondary) {
                    return false;
                }

                return !TextUtils.isEmpty(primaryAddress.text);
            }
        });


// 購読、監視
isValidAll.subscribe(new Observer&lt;Boolean&gt;() {
    @Override
    public void onNext(final Boolean isValid) {
        // 必須条件を満たしていたら「注文を確定する」を有効にする
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                buttonSubmit.setEnabled(isValid);
            }
        });
    }

    @Override
    public void onCompleted() {
    }

    @Override
    public void onError(Throwable e) {
    }
});
</code></pre>

<p>}
```</p>

<p>　<code>ViewObservable.xxx</code> で、UI要素をObservable化します。これはRxAndroidの機能。これでテキストの変更とか、チェックボックスの変更のたびに、<code>OnNext</code>が発生するようになります。</p>

<p>　Validationでは、RxJavaの機能である <code>Observable.combineLatest</code>がキモで、こいつに2つのObservableを渡してやると、その片方が値が変化した時に、<code>T3 call(T1 a, T2 b)</code> が呼ばれます。T1、T2 は渡すObservableの型、T3は後続へ流す型で、Validationなので<code>Boolean</code>です。
上記 <code>secondaryIsValid</code> の実装では、「住所2に配送する」のチェックボックスと「住所2」のテキストボックスの2つのObservableを渡していて、</p>

<ul>
<li>「住所2に配送する」がOFFなら <code>true</code> を返す</li>
<li>「住所2に配送する」がONで、且つ「住所2」が空でなければ <code>true</code> を返す</li>
</ul>


<p>としています。</p>

<p>　次に、<code>isValidAll</code> の実装では、「住所1」と <code>secondaryIsValid</code> を渡していて、</p>

<ul>
<li><code>secondaryIsValid</code> が <code>false</code> なら <code>false</code> を返す</li>
<li><code>secondaryIsValid</code> が <code>true</code> で、且つ「住所1」が空でなければ <code>true</code> を返す</li>
</ul>


<p>という実装です。</p>

<p>　んで、こいつ(<code>isValidAll</code>)を購読(<code>subscribe</code>)すると、<code>onNext</code> にValidationの結果が通知されるので、ボタンの<code>Enabled</code>を切り替えます。</p>

<h1>まとめ</h1>

<p>　このレベルだと、すべてのUI要素に変更通知を仕込んで共通な関数を呼ぶ、的な実装で問題ないですが、要素や条件が増えてくると大変です。</p>

<p>　Observable と combineLatest を使うと、制約の一部を(Observableに)部分化できて、それらを組み合わせるのも自由自在(Observableだから)。</p>

<p>Javaなのでかなり長ったらしくて読みづらいコードになってしまいました。</p>

<p><strong><a href="http://xamarin.com/">Xamarin.Android</a> + <a href="https://rx.codeplex.com/">本家Reactive Extensions</a> + <a href="https://reactiveproperty.codeplex.com/">ReactiveProporty</a> なら、相当スッキリするんだけどなあー</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveX と MVVM と DataBinding の関係について図にしてみた]]></title>
    <link href="http://blog.amay077.net/blog/2014/10/30/reactivex-mvvm-databindings-relations/"/>
    <updated>2014-10-30T01:17:39+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/10/30/reactivex-mvvm-databindings-relations</id>
    <content type="html"><![CDATA[<ul>
<li><a href="http://connpass.com/event/8680/">ReactiveCocoa Tokyo #rac_tokyo &ndash; connpass</a></li>
<li><a href="http://connpass.com/event/9061/">RxJava Night #rxjnight &ndash; connpass</a></li>
<li><a href="http://mozaic.fm/post/100741841543/10-node-js-sideshow">#10 node.js sideshow | mozaic.fm</a></li>
</ul>


<!--more-->


<p>などなどをいろいろ眺めておりまして（東京うらやましい）、Reactive Extensions とか MVVM とかいろいろ熱い！楽しい！と思っているわけですが、いろいろなライブラリがあって、それらのカバーする範囲がいまいち明確になってない気がしたので、自分なりに整理してみました。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/reactive_mvvm_databindings_relations_01.png" alt="" /></p>

<p>MVVM っていうと、Messenger とか DIコンテナ的なものとかもあるわけですが、主に DataBinding と Rx の違いにフィーチャーしたかったので除外しました。</p>

<p>　DataBinding は、<a href="http://www.atmarkit.co.jp/ait/articles/1008/03/news097_3.html">DependencyProperty</a> や <a href="http://blog.falafel.com/learning-xamarin-custom-renderers-in-xamarin-forms/">BindableProperty</a> みたいなものがあるかどうかという感じで考えていて、「XAMLとかのマークアップでバインディング指定できなければならない」という考えではないです。</p>

<p>　View, DataBinding, ViewModel, ReactiveX の各ブロックは基本的にはどの組み合わせでもよくて（特に ReactiveX は他とは別の世界のものなので）、しかし中には ReactiveProperty のように ReactiveX に依存しつつ ViewModel の機能を提供するものがあったり、ReactiveCocoa のように「全部入り」のものがあったりします。また、View と ViewModel を繋ぐためにはなんらかの DataBinding が必要です。</p>

<p>という理解なんですが、あってますかね？</p>

<p>　私は Xamarin 推しの人なので、 <strong>Xamarin.Forms + ReactiveProperty が、MVVM+Rx のパワーをフル活用できて、しかも iOS/Android で大部分のコードが共有できるという最強の組み合わせなんですよ！</strong> というのを言いたいわけです。</p>

<h2>Links</h2>

<ul>
<li>Xamarin.Forms &ndash; <a href="http://xamarin.com/forms">Build a Native Android UI &amp; iOS UI with Xamarin.Forms &ndash; Xamarin</a></li>
<li>Prism &ndash; <a href="http://compositewpf.codeplex.com/releases/view/117297">patterns &amp; practices: Prism &ndash; Download: Prism 5.0 for .NET 4.5</a></li>
<li>MVVM Light Toolkit &ndash; <a href="https://mvvmlight.codeplex.com/">MVVM Light Toolkit &ndash; Home</a></li>
<li>Reactive Extensions &ndash; <a href="https://rx.codeplex.com/">Rx (Reactive Extensions) &ndash; Home</a></li>
<li>ReactiveProperty &ndash; <a href="https://reactiveproperty.codeplex.com/">ReactiveProperty &ndash; MVVM Extensions for Rx &ndash; Home</a></li>
<li>ReactiveUI &ndash; <a href="https://github.com/reactiveui/reactiveui">reactiveui/ReactiveUI</a></li>
<li>MvvmCross &ndash; <a href="https://github.com/MvvmCross/MvvmCross">MvvmCross/MvvmCross</a></li>
<li>RxJava &ndash; <a href="https://github.com/ReactiveX/RxJava">ReactiveX/RxJava</a></li>
<li>RxAndroid &ndash; <a href="https://github.com/ReactiveX/RxAndroid">ReactiveX/RxAndroid</a></li>
<li>android-binding &ndash; <a href="https://github.com/gueei/AndroidBinding">gueei/AndroidBinding</a></li>
<li>ReactiveCocoa &ndash; <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa/ReactiveCocoa</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ボタンを重ねた時の ZOrder に関する Tips]]></title>
    <link href="http://blog.amay077.net/blog/2014/09/23/views-zorder/"/>
    <updated>2014-09-23T00:20:38+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/09/23/views-zorder</id>
    <content type="html"><![CDATA[<p>Android 開発でボタンを意図的に重ねたい時ってあんまりないんですけど、業務アプリなんか作ってますとたまにありまして。</p>

<!--more-->


<p>具体的には、</p>

<ul>
<li><a href="http://coliss.com/articles/build-websites/operation/css/10-css-breadcrumbs.html">デザインの勉強にもなる、CSSで実装するパンくずのまとめ | コリス</a></li>
</ul>


<p>みたいなパンくずリストを作りたい時。変な形のボタンを作るのは骨が折れるので、ボタンを重ねて、左側の方が手前に表示されるようにしたいわけです。(なぜそうしたいかはたぶん伝わらないので割愛)</p>

<p>つまりはボタンを重ねた時の ZOrder（Z-index）を制御したいわけです。</p>

<p>でいろいろトライ。</p>

<h2>LinearLayout の場合</h2>

<p>LinearLayout で横並びにする場合。</p>

<p>```xml main.xml
&lt;LinearLayout</p>

<pre><code>android:layout_width="match_parent"
android:layout_height="30dp"
android:orientation="horizontal"&gt;

&lt;Button
    android:background="#FF0000"
    android:text="AAA"
    android:layout_width="50dp"
    android:layout_height="match_parent" /&gt;
&lt;Button
    android:background="#00FF00"
    android:text="BBB"
    android:layout_marginLeft="-10dp"
    android:layout_width="50dp"
    android:layout_height="match_parent" /&gt;
&lt;Button
    android:background="#0000FF"
    android:text="CCC"
    android:layout_marginLeft="-10dp"
    android:layout_width="50dp"
    android:layout_height="match_parent" /&gt;
</code></pre>

<p></LinearLayout>
```</p>

<h3>結果</h3>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/zorder_test_01.png" alt="" /></p>

<p>だめだー。
LinearLayout の Zorder は、並び順と連動してしまうので、右（若しくは下）ほど手前になってしまいます。</p>

<p>ちなみに、「<code>view.bringToFront()</code> を叩けばいいんじゃね？」と思い、<code>buttonA.bringToFront()</code> を実行すると、</p>

<p>じゃん↓</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/zorder_test_02.png" alt="" /></p>

<p>見事に AAA が右端にいったｗ</p>

<h2>RelativeLayout の場合（その１）</h2>

<p>普通に RelativeLayout で、「BはAの右、CはBの右」と制約をつけてみます。</p>

<p>```xml main.xml
&lt;RelativeLayout</p>

<pre><code>android:layout_width="match_parent"
android:layout_height="30dp"&gt;

&lt;Button
    android:id="@+id/buttonA"
    android:background="#FF0000"
    android:text="AAA"
    android:layout_width="50dp"
    android:layout_height="match_parent" /&gt;
&lt;Button
    android:id="@+id/buttonB"
    android:layout_toRightOf="@+id/buttonA"
    android:background="#00FF00"
    android:text="BBB"
    android:layout_marginLeft="-10dp"
    android:layout_width="50dp"
    android:layout_height="match_parent" /&gt;
&lt;Button
    android:id="@+id/buttonC"
    android:layout_toRightOf="@+id/buttonB"
    android:background="#0000FF"
    android:text="CCC"
    android:layout_marginLeft="-10dp"
    android:layout_width="50dp"
    android:layout_height="match_parent" /&gt;
</code></pre>

<p></RelativeLayout>
```</p>

<h3>結果</h3>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/zorder_test_03.png" alt="" /></p>

<p>んんー、まだダメかー。</p>

<h2>RelativeLayout の場合（その２）</h2>

<p>その１の制約はそのままに、XML上での並び順を C、B、A に変えてみましょう。</p>

<p>```xml main.xml
&lt;RelativeLayout</p>

<pre><code>android:layout_width="match_parent"
android:layout_height="30dp"&gt;

&lt;Button
    android:id="@+id/buttonC"
    android:layout_toRightOf="@+id/buttonB"
    android:background="#0000FF"
    android:text="CCC"
    android:layout_marginLeft="-10dp"
    android:layout_width="50dp"
    android:layout_height="match_parent" /&gt;
&lt;Button
    android:id="@+id/buttonB"
    android:layout_toRightOf="@+id/buttonA"
    android:background="#00FF00"
    android:text="BBB"
    android:layout_marginLeft="-10dp"
    android:layout_width="50dp"
    android:layout_height="match_parent" /&gt;
&lt;Button
    android:id="@+id/buttonA"
    android:background="#FF0000"
    android:text="AAA"
    android:layout_width="50dp"
    android:layout_height="match_parent" /&gt;
</code></pre>

<p></RelativeLayout>
```</p>

<h3>結果</h3>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/zorder_test_04.png" alt="" /></p>

<p>よしっ！期待した表示になりました。</p>

<h2>まとめ</h2>

<p>　総合しますと、ZOrder は、LinearLayout でも RelativeLayout でも、XMLでは後で記述したものが手前になります。</p>

<p>　LinearLayout は、上から下、または左から右に並べるしかできないので、それに逆らうような ZOrder は付けられません。</p>

<p> RelativeLayout は、制約に基づき描画されるので、XMLの記述順を工夫することで ZOrder をある程度コントロールできます。</p>

<p>以上、誰得Tips でした。</p>

<p>冒頭のようなパンくずリストをAndroidで作る方法教えてください。。。(FragmentBreadCrumbs もパンくずっぽくないじゃないですかぁ)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[秋の Xamarin 勉強会いろいろ]]></title>
    <link href="http://blog.amay077.net/blog/2014/09/16/xamarin-user-meetup-in-autum-2014/"/>
    <updated>2014-09-16T00:13:28+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/09/16/xamarin-user-meetup-in-autum-2014</id>
    <content type="html"><![CDATA[<p>　なんか今年(2014年)の秋は Xamarin についての勉強会がめじろ押しで、嬉しいというか羨ましい限りです。</p>

<p>　ざっとまとめて見ました。あ、ほぼ関東圏です。</p>

<!--more-->


<h2>【9/20・品川】<a href="https://atnd.org/events/55564">Xamarin.iOS でデバイスを超えるプログラミング : ATND</a></h2>

<p>　Xamarin.iOS の、特に Objective-C で作成されたライブラリを Xamarin.iOS で使う「Binding」についてのお話が聞けるのは大変希少です。</p>

<h2>【9/20・品川】<a href="http://kokucheese.com/event/index/215384/">9月20日 .NETラボ 勉強会 2014年9月(東京都)</a></h2>

<p>セッションの一つに</p>

<ul>
<li>「Xamarin.FormsのMVVM」のお話（Microsoft MVP for Visual C# 増田 智明）</li>
</ul>


<p>があります。Xamarin.Forms は iOS/Android/WinPhone でUIを共通化する新しいフレームワークで、且つ、MVVMフレームワークでもあります。これも大変価値のあるセッションです。</p>

<h2>【9/30・渋谷】<a href="http://connpass.com/event/8706/">「Xamarin」って何？ Wエバンジェリストによる特濃「Xamarin」勉強会 &ndash; connpass</a></h2>

<p>「Xamarinって何？」というタイトルの通り、Xamarin を知らない／興味のある方向けのセッションと思います。エクセルソフト田淵さんとMS渡辺さんは Xamarin について各所でプレゼンしまくってるので、これからXamarinを始めてみようという方にはピッタリだと思います。</p>

<h2>【10/18・渋谷】<a href="http://www.wankuma.com/seminar/20141018tokyo92/">Xamarin Day &ndash; わんくま同盟</a></h2>

<p>　わんくま同盟で、一日Xamarinぶち抜きしてくれるとは嬉しい限りですね。
勝手なイメージですが、わんくまはマイクロソフト系開発者が多いと思うので、Windows や Visual Studio での Xamarin 開発についてのセッションが多いのではないでしょうか。</p>

<h2>【10/6-10・アメリカ】<a href="https://evolve.xamarin.com/">Xamarin Evolve 2014</a></h2>

<p>　Xamarin 社主催の年に一度の大イベント「Evolve 2014」です。Apple でいうところの WWDC、Google で言えば I/O のような大きなイベントです。
Microsoft, IBM, Amazon, Salesforce とかなんだこの豪華なスポンサーは！
昨年は KeyNote がライブ配信されたので、今年もあるんじゃないかと思います。新しい Feature の発表もあるかもしれないので、必見です。日本のXamarin開発の第一人者 @iseebi さんも現地で参加されるとのことで、Live で盛り上がりましょう！</p>

<h2>【時期未定】第2回 Japan Xamarin User Group Conference</h2>

<p>日本唯一の Xamarin ユーザーコミュニティ JXUG の第2回コンファレンス、秋くらいに開催されるんじゃないかなーと、期待も込めて書かせて頂きました。</p>

<p>最新情報は <a href="https://www.facebook.com/groups/778386365523431/">Japan Xamarin User Group (JXUG)</a> に参加してチェックしましょう。</p>

<p>　すごい！１年前からは想像もできないくらいに Xamarin が盛り上がってきていて、ひたすら Qiita にネタを投稿してきた身としてはとても嬉しいです。地方在住者にはなかなか参加が厳しいですが、関東から次第に全国にコミュニティが広がっていってくれたらいいなと思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.Forms で複数ボタンの均等割り付けをする]]></title>
    <link href="http://blog.amay077.net/blog/2014/09/10/xamarin-forms-view-equal-width-and-fill-layouting/"/>
    <updated>2014-09-10T22:57:08+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/09/10/xamarin-forms-view-equal-width-and-fill-layouting</id>
    <content type="html"><![CDATA[<p>　Android では、例えば画面の幅に対して、複数のボタンを同じ幅でいい感じに Fill させることができます。(これを均等割り付けというのが正しいのかはよくわかりませんが)</p>

<!--more-->


<ul>
<li><a href="http://inujirushi123.blog.fc2.com/blog-entry-106.html">LinearLayout を使って均等割り付け : layout_weight &ndash; 戌印-INUJIRUSHI- （Androidあれこれ） &ndash;</a></li>
<li><a href="http://blog.imho.jp/2011/08/android-linearlayout.html">Androidレイアウトの要点だけ: LinearLayoutでパーツを均等に配置したい | スマートフォン要点だけブログ</a></li>
</ul>


<p>これで画面の解像度が違っても、横向きになっても、同じ幅のボタンで埋まる、という事ができます。</p>

<p><a href="http://xamarin.com/forms">Xamarin.Forms</a> でこれを実現するにはどうしたら良いか、試してみました。</p>

<h2>StackLayout を利用した試み</h2>

<p>Xamarin.Forms では、LinearLayout に相当するレイアウトとして <a href="http://iosapi.xamarin.com/?link=T%3aXamarin.Forms.StackLayout">StackLayout</a> があります。</p>

<p>まずはこれを利用してみます。</p>

<p><code>StackLayout</code> を <code>Orientation = Horizontal</code> とし、<code>Children</code> にボタンを3つ配置しています。ボタンの幅は全て <code>HorizontalOptions = FillAndExpand</code> とします。</p>

<p>```csharp App.cs
public class App
{</p>

<pre><code>public static Page GetMainPage()
{   
    return new ContentPage
    { 
        Content = new StackLayout
        {
            HorizontalOptions = LayoutOptions.FillAndExpand,
            VerticalOptions = LayoutOptions.Center,
            Orientation = StackOrientation.Horizontal,
            Children = 
            {
                new Button
                {
                    VerticalOptions = LayoutOptions.Center,
                    HorizontalOptions = LayoutOptions.FillAndExpand,
                    Text = "one",
                    TextColor = Color.Black,
                    BackgroundColor = Color.Aqua,
                },
                new Button
                {
                    VerticalOptions = LayoutOptions.Center,
                    HorizontalOptions = LayoutOptions.FillAndExpand,
                    Text = "two two",
                    TextColor = Color.Black,
                    BackgroundColor = Color.Fuschia,
                },   
                new Button
                {
                    VerticalOptions = LayoutOptions.Center,
                    HorizontalOptions = LayoutOptions.FillAndExpand,
                    Text = "three three three",
                    TextColor = Color.Black,
                    BackgroundColor = Color.Lime,
                },
            },
        },
    };
}
</code></pre>

<p>}
```</p>

<p>　これを iOS/Android 双方で実行すると、こうなりました。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/xamarin_forms_view_equal_width_and_fill_layouting_01.png" alt="" /></p>

<p>うーん、そうじゃない（汗
どうやらボタンのテキストが全て表示されるように頑張ってくれちゃうようです。
まあ、これはこれで使える感じもします。</p>

<h2>Grid を利用した試み</h2>

<p>他のレイアウトで考えてみます。Android の TableLayout に相当する <a href="http://iosapi.xamarin.com/?link=T%3aXamarin.Forms.Grid">Grid</a> を使ってみます。</p>

<p>さっきの <code>App.cs</code> の実装を次のように変えます。</p>

<p><code>Grid</code> に1行3列の表を定義します。
列の定義 <code>ColumnDefinition</code> で幅を <code>new GridLength(1, GridUnitType.Star)</code> としているのは、「3列とも同じ比率の幅とする」ことを意味しています。(ということは比率を2:1:1にしたければ、最初の列だけ<code>2</code>にすればOKです)</p>

<p>```csharp App.cs
public class App
{</p>

<pre><code>public static Page GetMainPage()
{   
    var grid = new Grid
    {
        HorizontalOptions = LayoutOptions.FillAndExpand,
        VerticalOptions = LayoutOptions.Center,
        RowDefinitions =
        {
            new RowDefinition() { Height = GridLength.Auto }
        },
        ColumnDefinitions = 
        {
            new ColumnDefinition() { Width = new GridLength(1, GridUnitType.Star) },
            new ColumnDefinition() { Width = new GridLength(1, GridUnitType.Star) },
            new ColumnDefinition() { Width = new GridLength(1, GridUnitType.Star) },
        }
    };

    grid.Children.Add(new Button
    {
        VerticalOptions = LayoutOptions.Center,
        HorizontalOptions = LayoutOptions.FillAndExpand,
        Text = "one",
        TextColor = Color.Black,
        BackgroundColor = Color.Aqua,
    }, 0, 0);

    grid.Children.Add(new Button
    {
        VerticalOptions = LayoutOptions.Center,
        HorizontalOptions = LayoutOptions.FillAndExpand,
        Text = "two two",
        TextColor = Color.Black,
        BackgroundColor = Color.Fuschia,
    }, 1, 0);

    grid.Children.Add(new Button
    {
        VerticalOptions = LayoutOptions.Center,
        HorizontalOptions = LayoutOptions.FillAndExpand,
        Text = "three three three",
        TextColor = Color.Black,
        BackgroundColor = Color.Lime,
    }, 2, 0);

    return new ContentPage
    { 
        Content = grid,
    };
}
</code></pre>

<p>}
```</p>

<p>　これを iOS/Android 双方で実行すると、こうなりました。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/xamarin_forms_view_equal_width_and_fill_layouting_02.png" alt="" /></p>

<p>　おーけー、意図したレイアウトになりました。ボタンに入りきらないテキストはiOSだと省略され、Androidだと折り返されるという違いはありますが、レイアウトの一貫性は保つことができました。</p>

<p>　ちなみに横向きにしても大丈夫です。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/xamarin_forms_view_equal_width_and_fill_layouting_03.png" alt="" /></p>

<h2>まとめ</h2>

<p>　Xamarin.Forms でも、Android+LinearLayoutのような均等配置ができました。
　クロスプラットフォームなので、iOSでも同じように動作します。
iPhone6 が発表されてiOS開発でも多解像度対応が必須になるので、これは有用な感じがします。
（というか Storyboard の AutoLayout では、これと同じことができる気がしないのですが。。。）</p>
]]></content>
  </entry>
  
</feed>
