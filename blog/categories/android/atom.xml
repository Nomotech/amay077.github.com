<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | Experiments Never Fail]]></title>
  <link href="http://blog.amay077.net/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://blog.amay077.net/"/>
  <updated>2014-11-14T19:35:44+09:00</updated>
  <id>http://blog.amay077.net/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Xamarin.Forms をガチで使うときのプロジェクト構成案]]></title>
    <link href="http://blog.amay077.net/blog/2014/11/14/project-design-using-xamarin-forms/"/>
    <updated>2014-11-14T19:34:02+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/11/14/project-design-using-xamarin-forms</id>
    <content type="html"><![CDATA[<p>　<a href="http://xamarin.com/forms">Xamarin.Forms</a>（以下 XF とします）を本格的に開発に導入してみようと思ってるんだけど、その時のプロジェクト(アセンブリ)構成はこんな感じかな、というのを考えてみた。</p>

<!--more-->


<h2>コンセプト</h2>

<ul>
<li>XF を使う理由は、Viewのワンソース化よりも <em>DataBinding機構が使えること</em></li>
<li>いざという時逃げられるように XF への依存を最小限にする</li>
<li>iOS/Android 対応アプリ開発のこと、他は知らん</li>
<li>MVVM で PCL で、PCL のところを最大化する</li>
</ul>


<h2>プロジェクト構成図</h2>

<p>　角丸四角形がプロジェクトを、矢印は依存を示す。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/project_design_using_xamarin_forms_01.png" alt="" /></p>

<p>左から説明。</p>

<h3>XF.Android, XF.iOS, XF.Core</h3>

<p>　Xamarin.Forms ソリューションを作成するとテンプレで作られるプロジェクト群。
　XF.Core でプラットフォームに依存しないView（ボタンとか）を、XF.Android/XF.iOS でプラットフォーム固有のView（スライドメニューとかNotificationなど）を提供する。
　これらは BindableProperty を介して ViewModel とデータバインディングする。
　XF は他に、ServiceLocator や MessageCenter を提供するが、それらは使用しない（ロックインを防ぐため）
　結局この案では、「XF=View層のみ」となる。</p>

<h3>App.Core</h3>

<p>　アプリのView以外の共通部分のプロジェクト。ViewModel と Model を含む。
　ViewModel から View へシグナルを送るために &ldquo;XFではない&rdquo; Messengerを使う。（MvvmLight とか Prism とかから引っこ抜いてくればいいかな？）
　Model にはビジネスロジックのみを記述し、通信処理やデータI/Oなどのプラットフォーム共通なAPIはModelから直接使い、プラットフォーム固有の機能は、ServiceInterface を使う。
　ServiceInteface は、ServiceLocator によって App.Android/iOS から実体が Inject される。ServiceLocator は &ldquo;XFではない"…以下略
　Rx を使うので、たぶん Model のメソッドの返り値は全部 IObservable<T> になります。</p>

<h3>App.Android, App.iOS</h3>

<p>　プラットフォーム固有のAPI層。例えば GPS とか、アプリ連携とか、アイテム課金とか。ServiceInterface に定義されている Interface を実装するところ。</p>

<h2>懸案</h2>

<ul>
<li>PUSH通知受信とか、本来は Platform Specific APIs で担当したいが、プラットフォームの都合で、View で受信しなければならない機能の落としどころ。</li>
<li>App.core をもっと分割した方がよい「ViewModelからAPI呼ばないよね？」とか「App.AndroidからModelにアクセスできるのがイヤ」とかを厳格に制限しようと思ったら分割した方が良さそう。</li>
<li>Model から左側を全部 IObservable<T> 化しようと思っているが、Callback→Observable変換をModelでやるか、API層でやるか。"ビジネス"ロジックではないので、右側かな。</li>
<li>XF.Core にどれだけ詰め込むか。画面レイアウトもXFでできるだけ頑張る、画面遷移フレームワークもXFで用意する、か？Sketches がどこまで活用できるか？</li>
</ul>


<p>さて、どんなもんでしょ？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[「チェックAがONならば、項目Bは入力必須とする」という Validation を RxJava + RxAndroid でやる]]></title>
    <link href="http://blog.amay077.net/blog/2014/11/10/complex-validation-with-rxjava-and-rxandroid/"/>
    <updated>2014-11-10T01:32:20+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/11/10/complex-validation-with-rxjava-and-rxandroid</id>
    <content type="html"><![CDATA[<p>　例えばショッピングサイトとかの発送先指定のフォーム『登録されている住所とは違う住所に送りたい時、「別の住所に送る」をチェックする、すると「住所2」が必須入力となり、入力するまで次へ進めない』的なちょっと込み入ったValidationをReactive ExtensionsのJava版、<a href="https://github.com/ReactiveX/RxJava">RxJava</a>と<a href="https://github.com/ReactiveX/RxAndroid">RxAndroid</a>でやってみました。</p>

<!--more-->


<h1>動作イメージ</h1>

<p>　まずいきなり動作結果から。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/complex_validation_with_rxjava_and_rxandroid.gif" alt="" /></p>

<ul>
<li>住所1は入力必須。</li>
<li>住所2は「住所2へ配送する」がチェックされている場合のみ、入力必須。</li>
<li>必須項目が入力されていない場合はボタンを押せない</li>
</ul>


<p>こんな仕様です。</p>

<h1>実装</h1>

<p>```java
@Override
protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
setContentView(R.layout.activity_my);

// 「注文を確定する」ボタン
final Button buttonSubmit = (Button)findViewById(R.id.buttonSubmit);

// チェックボックスのON/OFFをObservable化
final Observable&lt;Boolean&gt; useSecondaryAddress =
        ViewObservable.input((CheckBox) findViewById(R.id.checkUseSecondary), true)
        .map(new Func1&lt;OnCheckedChangeEvent, Boolean&gt;() {
            @Override
            public Boolean call(OnCheckedChangeEvent onCheckedChangeEvent) {
                return onCheckedChangeEvent.value;
            }
        });

// 住所1をObservable化
final Observable&lt;OnTextChangeEvent&gt; primaryAddress =
        ViewObservable.text((EditText) findViewById(R.id.editPrimaryAddress), true);
// 住所2をObservable化
final Observable&lt;OnTextChangeEvent&gt; secondaryAddress =
        ViewObservable.text((EditText) findViewById(R.id.editSecondaryAddress), true);

// チェックボックスと住所2の必須条件をObservable化
final Observable&lt;Boolean&gt; secondaryIsValid = 
    Observable.combineLatest(useSecondaryAddress, secondaryAddress,
        new Func2&lt;Boolean, OnTextChangeEvent, Boolean&gt;() {
            @Override
            public Boolean call(Boolean useSecondary, OnTextChangeEvent secondaryAddress) {
                if (!useSecondary) {
                    return true;
                }

                return !TextUtils.isEmpty(secondaryAddress.text);
            }
        });


// 全部まとめると、
//  住所1は入力必須、
//  住所2はチェックボックスがONの時だけ入力必須
//  必須条件を満たしていたらtrueを流す
final Observable&lt;Boolean&gt; isValidAll = Observable.combineLatest(primaryAddress, secondaryIsValid,
        new Func2&lt;OnTextChangeEvent, Boolean, Boolean&gt;() {
            @Override
            public Boolean call(OnTextChangeEvent primaryAddress, Boolean isValidSecondary) {
                if (!isValidSecondary) {
                    return false;
                }

                return !TextUtils.isEmpty(primaryAddress.text);
            }
        });


// 購読、監視
isValidAll.subscribe(new Observer&lt;Boolean&gt;() {
    @Override
    public void onNext(final Boolean isValid) {
        // 必須条件を満たしていたら「注文を確定する」を有効にする
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                buttonSubmit.setEnabled(isValid);
            }
        });
    }

    @Override
    public void onCompleted() {
    }

    @Override
    public void onError(Throwable e) {
    }
});
</code></pre>

<p>}
```</p>

<p>　<code>ViewObservable.xxx</code> で、UI要素をObservable化します。これはRxAndroidの機能。これでテキストの変更とか、チェックボックスの変更のたびに、<code>OnNext</code>が発生するようになります。</p>

<p>　Validationでは、RxJavaの機能である <code>Observable.combineLatest</code>がキモで、こいつに2つのObservableを渡してやると、その片方が値が変化した時に、<code>T3 call(T1 a, T2 b)</code> が呼ばれます。T1、T2 は渡すObservableの型、T3は後続へ流す型で、Validationなので<code>Boolean</code>です。
上記 <code>secondaryIsValid</code> の実装では、「住所2に配送する」のチェックボックスと「住所2」のテキストボックスの2つのObservableを渡していて、</p>

<ul>
<li>「住所2に配送する」がOFFなら <code>true</code> を返す</li>
<li>「住所2に配送する」がONで、且つ「住所2」が空でなければ <code>true</code> を返す</li>
</ul>


<p>としています。</p>

<p>　次に、<code>isValidAll</code> の実装では、「住所1」と <code>secondaryIsValid</code> を渡していて、</p>

<ul>
<li><code>secondaryIsValid</code> が <code>false</code> なら <code>false</code> を返す</li>
<li><code>secondaryIsValid</code> が <code>true</code> で、且つ「住所1」が空でなければ <code>true</code> を返す</li>
</ul>


<p>という実装です。</p>

<p>　んで、こいつ(<code>isValidAll</code>)を購読(<code>subscribe</code>)すると、<code>onNext</code> にValidationの結果が通知されるので、ボタンの<code>Enabled</code>を切り替えます。</p>

<p>　conbimeLatest は、本家Rxなら obsA.CombineLatest(obsB, (tA, tB) => tX).CombineLatest(obsC, (tX, tC) => tY)&hellip; とチェインして書けるのですが、RxJava の combineLatest はなぜか static メソッドしかなくてチェインできません、残念。</p>

<h1>まとめ</h1>

<p>　このレベルだと、すべてのUI要素に変更通知を仕込んで共通な関数を呼ぶ、的な実装で問題ないですが、要素や条件が増えてくると大変です。</p>

<p>　Observable と combineLatest を使うと、制約の一部を(Observableに)部分化できて、それらを組み合わせるのも自由自在(Observableだから)。</p>

<p>Javaなのでかなり長ったらしくて読みづらいコードになってしまいました。</p>

<p><strong><a href="http://xamarin.com/">Xamarin.Android</a> + <a href="https://rx.codeplex.com/">本家Reactive Extensions</a> + <a href="https://reactiveproperty.codeplex.com/">ReactiveProporty</a> なら、相当スッキリするんだけどなあー</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveX と MVVM と DataBinding の関係について図にしてみた]]></title>
    <link href="http://blog.amay077.net/blog/2014/10/30/reactivex-mvvm-databindings-relations/"/>
    <updated>2014-10-30T01:17:39+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/10/30/reactivex-mvvm-databindings-relations</id>
    <content type="html"><![CDATA[<ul>
<li><a href="http://connpass.com/event/8680/">ReactiveCocoa Tokyo #rac_tokyo &ndash; connpass</a></li>
<li><a href="http://connpass.com/event/9061/">RxJava Night #rxjnight &ndash; connpass</a></li>
<li><a href="http://mozaic.fm/post/100741841543/10-node-js-sideshow">#10 node.js sideshow | mozaic.fm</a></li>
</ul>


<!--more-->


<p>などなどをいろいろ眺めておりまして（東京うらやましい）、Reactive Extensions とか MVVM とかいろいろ熱い！楽しい！と思っているわけですが、いろいろなライブラリがあって、それらのカバーする範囲がいまいち明確になってない気がしたので、自分なりに整理してみました。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/reactive_mvvm_databindings_relations_01.png" alt="" /></p>

<p>MVVM っていうと、Messenger とか DIコンテナ的なものとかもあるわけですが、主に DataBinding と Rx の違いにフィーチャーしたかったので除外しました。</p>

<p>　DataBinding は、<a href="http://www.atmarkit.co.jp/ait/articles/1008/03/news097_3.html">DependencyProperty</a> や <a href="http://blog.falafel.com/learning-xamarin-custom-renderers-in-xamarin-forms/">BindableProperty</a> みたいなものがあるかどうかという感じで考えていて、「XAMLとかのマークアップでバインディング指定できなければならない」という考えではないです。</p>

<p>　View, DataBinding, ViewModel, ReactiveX の各ブロックは基本的にはどの組み合わせでもよくて（特に ReactiveX は他とは別の世界のものなので）、しかし中には ReactiveProperty のように ReactiveX に依存しつつ ViewModel の機能を提供するものがあったり、ReactiveCocoa のように「全部入り」のものがあったりします。また、View と ViewModel を繋ぐためにはなんらかの DataBinding が必要です。</p>

<p>という理解なんですが、あってますかね？</p>

<p>　私は Xamarin 推しの人なので、 <strong>Xamarin.Forms + ReactiveProperty が、MVVM+Rx のパワーをフル活用できて、しかも iOS/Android で大部分のコードが共有できるという最強の組み合わせなんですよ！</strong> というのを言いたいわけです。</p>

<h2>Links</h2>

<ul>
<li>Xamarin.Forms &ndash; <a href="http://xamarin.com/forms">Build a Native Android UI &amp; iOS UI with Xamarin.Forms &ndash; Xamarin</a></li>
<li>Prism &ndash; <a href="http://compositewpf.codeplex.com/releases/view/117297">patterns &amp; practices: Prism &ndash; Download: Prism 5.0 for .NET 4.5</a></li>
<li>MVVM Light Toolkit &ndash; <a href="https://mvvmlight.codeplex.com/">MVVM Light Toolkit &ndash; Home</a></li>
<li>Reactive Extensions &ndash; <a href="https://rx.codeplex.com/">Rx (Reactive Extensions) &ndash; Home</a></li>
<li>ReactiveProperty &ndash; <a href="https://reactiveproperty.codeplex.com/">ReactiveProperty &ndash; MVVM Extensions for Rx &ndash; Home</a></li>
<li>ReactiveUI &ndash; <a href="https://github.com/reactiveui/reactiveui">reactiveui/ReactiveUI</a></li>
<li>MvvmCross &ndash; <a href="https://github.com/MvvmCross/MvvmCross">MvvmCross/MvvmCross</a></li>
<li>RxJava &ndash; <a href="https://github.com/ReactiveX/RxJava">ReactiveX/RxJava</a></li>
<li>RxAndroid &ndash; <a href="https://github.com/ReactiveX/RxAndroid">ReactiveX/RxAndroid</a></li>
<li>android-binding &ndash; <a href="https://github.com/gueei/AndroidBinding">gueei/AndroidBinding</a></li>
<li>ReactiveCocoa &ndash; <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa/ReactiveCocoa</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ボタンを重ねた時の ZOrder に関する Tips]]></title>
    <link href="http://blog.amay077.net/blog/2014/09/23/views-zorder/"/>
    <updated>2014-09-23T00:20:38+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/09/23/views-zorder</id>
    <content type="html"><![CDATA[<p>Android 開発でボタンを意図的に重ねたい時ってあんまりないんですけど、業務アプリなんか作ってますとたまにありまして。</p>

<!--more-->


<p>具体的には、</p>

<ul>
<li><a href="http://coliss.com/articles/build-websites/operation/css/10-css-breadcrumbs.html">デザインの勉強にもなる、CSSで実装するパンくずのまとめ | コリス</a></li>
</ul>


<p>みたいなパンくずリストを作りたい時。変な形のボタンを作るのは骨が折れるので、ボタンを重ねて、左側の方が手前に表示されるようにしたいわけです。(なぜそうしたいかはたぶん伝わらないので割愛)</p>

<p>つまりはボタンを重ねた時の ZOrder（Z-index）を制御したいわけです。</p>

<p>でいろいろトライ。</p>

<h2>LinearLayout の場合</h2>

<p>LinearLayout で横並びにする場合。</p>

<p>```xml main.xml
&lt;LinearLayout</p>

<pre><code>android:layout_width="match_parent"
android:layout_height="30dp"
android:orientation="horizontal"&gt;

&lt;Button
    android:background="#FF0000"
    android:text="AAA"
    android:layout_width="50dp"
    android:layout_height="match_parent" /&gt;
&lt;Button
    android:background="#00FF00"
    android:text="BBB"
    android:layout_marginLeft="-10dp"
    android:layout_width="50dp"
    android:layout_height="match_parent" /&gt;
&lt;Button
    android:background="#0000FF"
    android:text="CCC"
    android:layout_marginLeft="-10dp"
    android:layout_width="50dp"
    android:layout_height="match_parent" /&gt;
</code></pre>

<p></LinearLayout>
```</p>

<h3>結果</h3>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/zorder_test_01.png" alt="" /></p>

<p>だめだー。
LinearLayout の Zorder は、並び順と連動してしまうので、右（若しくは下）ほど手前になってしまいます。</p>

<p>ちなみに、「<code>view.bringToFront()</code> を叩けばいいんじゃね？」と思い、<code>buttonA.bringToFront()</code> を実行すると、</p>

<p>じゃん↓</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/zorder_test_02.png" alt="" /></p>

<p>見事に AAA が右端にいったｗ</p>

<h2>RelativeLayout の場合（その１）</h2>

<p>普通に RelativeLayout で、「BはAの右、CはBの右」と制約をつけてみます。</p>

<p>```xml main.xml
&lt;RelativeLayout</p>

<pre><code>android:layout_width="match_parent"
android:layout_height="30dp"&gt;

&lt;Button
    android:id="@+id/buttonA"
    android:background="#FF0000"
    android:text="AAA"
    android:layout_width="50dp"
    android:layout_height="match_parent" /&gt;
&lt;Button
    android:id="@+id/buttonB"
    android:layout_toRightOf="@+id/buttonA"
    android:background="#00FF00"
    android:text="BBB"
    android:layout_marginLeft="-10dp"
    android:layout_width="50dp"
    android:layout_height="match_parent" /&gt;
&lt;Button
    android:id="@+id/buttonC"
    android:layout_toRightOf="@+id/buttonB"
    android:background="#0000FF"
    android:text="CCC"
    android:layout_marginLeft="-10dp"
    android:layout_width="50dp"
    android:layout_height="match_parent" /&gt;
</code></pre>

<p></RelativeLayout>
```</p>

<h3>結果</h3>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/zorder_test_03.png" alt="" /></p>

<p>んんー、まだダメかー。</p>

<h2>RelativeLayout の場合（その２）</h2>

<p>その１の制約はそのままに、XML上での並び順を C、B、A に変えてみましょう。</p>

<p>```xml main.xml
&lt;RelativeLayout</p>

<pre><code>android:layout_width="match_parent"
android:layout_height="30dp"&gt;

&lt;Button
    android:id="@+id/buttonC"
    android:layout_toRightOf="@+id/buttonB"
    android:background="#0000FF"
    android:text="CCC"
    android:layout_marginLeft="-10dp"
    android:layout_width="50dp"
    android:layout_height="match_parent" /&gt;
&lt;Button
    android:id="@+id/buttonB"
    android:layout_toRightOf="@+id/buttonA"
    android:background="#00FF00"
    android:text="BBB"
    android:layout_marginLeft="-10dp"
    android:layout_width="50dp"
    android:layout_height="match_parent" /&gt;
&lt;Button
    android:id="@+id/buttonA"
    android:background="#FF0000"
    android:text="AAA"
    android:layout_width="50dp"
    android:layout_height="match_parent" /&gt;
</code></pre>

<p></RelativeLayout>
```</p>

<h3>結果</h3>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/zorder_test_04.png" alt="" /></p>

<p>よしっ！期待した表示になりました。</p>

<h2>まとめ</h2>

<p>　総合しますと、ZOrder は、LinearLayout でも RelativeLayout でも、XMLでは後で記述したものが手前になります。</p>

<p>　LinearLayout は、上から下、または左から右に並べるしかできないので、それに逆らうような ZOrder は付けられません。</p>

<p> RelativeLayout は、制約に基づき描画されるので、XMLの記述順を工夫することで ZOrder をある程度コントロールできます。</p>

<p>以上、誰得Tips でした。</p>

<p>冒頭のようなパンくずリストをAndroidで作る方法教えてください。。。(FragmentBreadCrumbs もパンくずっぽくないじゃないですかぁ)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[秋の Xamarin 勉強会いろいろ]]></title>
    <link href="http://blog.amay077.net/blog/2014/09/16/xamarin-user-meetup-in-autum-2014/"/>
    <updated>2014-09-16T00:13:28+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/09/16/xamarin-user-meetup-in-autum-2014</id>
    <content type="html"><![CDATA[<p>　なんか今年(2014年)の秋は Xamarin についての勉強会がめじろ押しで、嬉しいというか羨ましい限りです。</p>

<p>　ざっとまとめて見ました。あ、ほぼ関東圏です。</p>

<!--more-->


<h2>【9/20・品川】<a href="https://atnd.org/events/55564">Xamarin.iOS でデバイスを超えるプログラミング : ATND</a></h2>

<p>　Xamarin.iOS の、特に Objective-C で作成されたライブラリを Xamarin.iOS で使う「Binding」についてのお話が聞けるのは大変希少です。</p>

<h2>【9/20・品川】<a href="http://kokucheese.com/event/index/215384/">9月20日 .NETラボ 勉強会 2014年9月(東京都)</a></h2>

<p>セッションの一つに</p>

<ul>
<li>「Xamarin.FormsのMVVM」のお話（Microsoft MVP for Visual C# 増田 智明）</li>
</ul>


<p>があります。Xamarin.Forms は iOS/Android/WinPhone でUIを共通化する新しいフレームワークで、且つ、MVVMフレームワークでもあります。これも大変価値のあるセッションです。</p>

<h2>【9/30・渋谷】<a href="http://connpass.com/event/8706/">「Xamarin」って何？ Wエバンジェリストによる特濃「Xamarin」勉強会 &ndash; connpass</a></h2>

<p>「Xamarinって何？」というタイトルの通り、Xamarin を知らない／興味のある方向けのセッションと思います。エクセルソフト田淵さんとMS渡辺さんは Xamarin について各所でプレゼンしまくってるので、これからXamarinを始めてみようという方にはピッタリだと思います。</p>

<h2>【10/18・渋谷】<a href="http://www.wankuma.com/seminar/20141018tokyo92/">Xamarin Day &ndash; わんくま同盟</a></h2>

<p>　わんくま同盟で、一日Xamarinぶち抜きしてくれるとは嬉しい限りですね。
勝手なイメージですが、わんくまはマイクロソフト系開発者が多いと思うので、Windows や Visual Studio での Xamarin 開発についてのセッションが多いのではないでしょうか。</p>

<h2>【10/6-10・アメリカ】<a href="https://evolve.xamarin.com/">Xamarin Evolve 2014</a></h2>

<p>　Xamarin 社主催の年に一度の大イベント「Evolve 2014」です。Apple でいうところの WWDC、Google で言えば I/O のような大きなイベントです。
Microsoft, IBM, Amazon, Salesforce とかなんだこの豪華なスポンサーは！
昨年は KeyNote がライブ配信されたので、今年もあるんじゃないかと思います。新しい Feature の発表もあるかもしれないので、必見です。日本のXamarin開発の第一人者 @iseebi さんも現地で参加されるとのことで、Live で盛り上がりましょう！</p>

<h2>【時期未定】第2回 Japan Xamarin User Group Conference</h2>

<p>日本唯一の Xamarin ユーザーコミュニティ JXUG の第2回コンファレンス、秋くらいに開催されるんじゃないかなーと、期待も込めて書かせて頂きました。</p>

<p>最新情報は <a href="https://www.facebook.com/groups/778386365523431/">Japan Xamarin User Group (JXUG)</a> に参加してチェックしましょう。</p>

<p>　すごい！１年前からは想像もできないくらいに Xamarin が盛り上がってきていて、ひたすら Qiita にネタを投稿してきた身としてはとても嬉しいです。地方在住者にはなかなか参加が厳しいですが、関東から次第に全国にコミュニティが広がっていってくれたらいいなと思います。</p>
]]></content>
  </entry>
  
</feed>
