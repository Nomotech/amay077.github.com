<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Experiments Never Fail]]></title>
  <link href="http://amay077.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://amay077.github.io/"/>
  <updated>2013-08-06T21:18:38+09:00</updated>
  <id>http://amay077.github.io/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Xamarin.Android での Google Map(というか Play Service) 利用が、本家より簡単になった件]]></title>
    <link href="http://amay077.github.io/blog/2013/08/03/gmapv2-from-xamarin-component/"/>
    <updated>2013-08-03T15:29:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/08/03/gmapv2-from-xamarin-component</id>
    <content type="html"><![CDATA[<p>Xamarin Components に「Google Play Services」が追加されまして。</p>

<!--more-->


<ul>
<li><a href="http://blog.xamarin.com/introducing-the-google-play-services-component-for-xamarin-android/">Introducing the Google Play Services Component for Xamarin.Android | Xamarin Blog</a></li>
</ul>


<p>これが何を意味するかと言うと、これまで Google Play Service を利用するには、ライブラリプロジェクトを作って、アプリから参照するという煩わしい手順が必要でした。</p>

<p>で、これは Android-Eclipse でも同じく面倒だったわけですが、Xamarin.Android  に新しく提供されるこのコンポーネントを使えば、その手間を省くことができます。この点で Eclipse での開発より簡単になりました。</p>

<p>実際に、Play Services の一つである Google Map Android API v2 を使うアプリを作る手順を書いてみます。</p>

<h2>手順</h2>

<h3>1. Google API Console から API key を取得する</h3>

<p>この手順は、これまでと変わらないので、以下のサイトなどを参考にしてください。
package名が必要になるので、先に決めておきましょう。
ここでは <code>com.amay077.sample.googlemapv2sample</code> とします。</p>

<ul>
<li><a href="http://www.adamrocker.com/blog/334/google-maps-android-api-v2.html">throw Life - Google Maps Android API v2を使ってみた</a></li>
</ul>


<p>取得して API key はメモっておきます。</p>

<h3>2. プロジェクト/ソリューションを作る</h3>

<p>Xamarin Studio を起動します。
ここでは Ice Cream Sandwich 用に作ります。(Android Application の方だと Support Library が要るので少し手順が増えるはず)</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/gmapv2_from_xamarin_component_01.png" alt="img" /></p>

<h3>3. プロジェクトに「Google Play Service」コンポーネントを追加する</h3>

<p>メニュー → プロジェクト → Get More Components から、、、</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/gmapv2_from_xamarin_component_03.png" alt="img" /></p>

<p>Google Play Services を検索して Add to App します。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/gmapv2_from_xamarin_component_04.png" alt="img" /></p>

<p>すると、プロジェクトに Google Play Services が追加されます。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/gmapv2_from_xamarin_component_05.png" alt="img" /></p>

<p>ここで一度、Xamarin Studio を再起動しておいた方が無難です。
このまま継続したら、追加されたアセンブリがうまく読み込まれてない場合がありました。</p>

<h3>4. 実装する</h3>

<p><code>MainActivity.cs</code> は、最初の内容をごっそり削除して以下のようにします。</p>

<p>```c# MainActivity.cs
using Android.App;
using Android.OS;</p>

<p>namespace GoogleMapV2Sample
{</p>

<pre><code>[Activity (Label = "GoogleMapV2Sample", MainLauncher = true)]
public class MainActivity : Activity
{
    protected override void OnCreate(Bundle bundle)
    {
        base.OnCreate(bundle);

        // Set our view from the "main" layout resource
        SetContentView(Resource.Layout.Main);
    }
}
</code></pre>

<p>}
```</p>

<p>画面定義である <code>Main.axml</code> も以下のように置き換えます。</p>

<p>```xml Resources/layout/Main.axml
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;fragment xmlns:android="http://schemas.android.com/apk/res/android"</p>

<pre><code>android:id="@+id/map"
android:layout_width="match_parent"
android:layout_height="match_parent"
class="com.google.android.gms.maps.MapFragment" /&gt;
</code></pre>

<p>```</p>

<h3>5. AndroidManifest.xml への設定いろいろ</h3>

<p>たぶん一番面倒なところです。</p>

<p>まず Xamarin.Android では、最初は AndroidManifest.xml が生成されていないので、メニュー → プロジェクト → xxx のオプション から、下図のように [Add Android manifest] します。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/gmapv2_from_xamarin_component_06.png" alt="img" /></p>

<p>次に作成された AndroidManifest.xml を開いて、以下のようにします。</p>

<p>※1 のところは、最初に決めた Package名に、※2 の時は、先に取得しておいた API key に置き換えてください。</p>

<p>```xml Properties/AndroidManifest.xml
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"</p>

<pre><code>android:versionCode="1" 
android:versionName="1.0" 
package="com.amay077.sample.googlemapv2sample"&gt;  &lt;--------※1


&lt;uses-feature android:glEsVersion="0x00020000" android:required="true" /&gt;
&lt;uses-permission android:name="android.permission.INTERNET" /&gt;
&lt;uses-permission android:name="com.google.android.providers.gsf.permission.READ_GSERVICES" /&gt;
&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;


&lt;uses-permission 
    android:name="com.amay077.sample.playservicesample.permission.MAPS_RECEIVE" /&gt;   &lt;--------※1
&lt;permission 
    android:name="com.amay077.sample.playservicesample.permission.MAPS_RECEIVE"   &lt;--------※1
    android:protectionLevel="signature" /&gt;

&lt;application android:label="GoogleMapV2Sample"&gt;
    &lt;meta-data 
        android:name="com.google.android.maps.v2.API_KEY" 
        android:value="AIzaByD1jiFER3le_HFrkOrEhaNIsemoNoDesuU" /&gt;  &lt;--------※2
&lt;/application&gt;
</code></pre>

<p></manifest>
```</p>

<h3>6. 動かす</h3>

<p>設定が正しくできていれば、地図が表示されるはずです。
アプリが落ちるなら Main.cs や Main.axml が、地図が表示されないなら AndroidManifest.xml や Google API Console での設定が間違っていると思います。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/gmapv2_from_xamarin_component_07.png" alt="img" /></p>

<h2>まとめなど</h2>

<p>Google Play Service コンポーネントを使うことでライブラリプロジェクトをなくす事ができました。慣れた人にはどうってこと無い話ですが、説明する人には面倒で、始めて行う人には混乱の元になってたと思います。</p>

<p>もう一つ特筆すべきは、このコンポーネントを Google 自身が開発、提供していることです。</p>

<p>これだけでなく、<a href="http://components.xamarin.com/view/googlemapsios/">Google Map SDK for iOS</a> や <a href="http://components.xamarin.com/view/googleadmob/">Admob 用のコンポーネント</a>も Google 自身が提供しています。</p>

<p>また Microsoft も <a href="http://components.xamarin.com/view/azure-mobile-services/">Azure Mobile Service</a> を自身が提供していますし、なんなんでしょうこのプラットフォーマーの Xamarin への参入ぶりは。</p>

<p>このように本家が開発していることにより、信頼性、機能網羅性、新機能への追従などがとても充実しており、安心して使うことができます。</p>

<p>最後に、</p>

<blockquote class="twitter-tweet"><p>おおおお、すげえ！これでめんどいビルド手順必要なくなった！Google++！でも、Gmaps iOSの1.4アップデートと、Retina対応のため128dpタイルへの対応もしてください…。 / “Google Play Servi…” <a href="http://t.co/mjnN7sE0t7">http://t.co/mjnN7sE0t7</a></p>&mdash; Кочизуфан (@kochizufan) <a href="https://twitter.com/kochizufan/statuses/363116371351052290">August 2, 2013</a></blockquote>


<script async src="http://amay077.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>とのことなのでよろしくおねがいします。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Service が Foreground で動いているか確認する]]></title>
    <link href="http://amay077.github.io/blog/2013/06/14/viewing-is-service-foreground/"/>
    <updated>2013-06-14T18:11:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/06/14/viewing-is-service-foreground</id>
    <content type="html"><![CDATA[<p>Android で「死ににくいサービス」を作るには <a href="http://developer.android.com/reference/android/app/Service.html#startForeground(int,%20android.app.Notification">Service.startForegound</a> を呼び出す必要がありますが、動いてるサービスがちゃんと「Foregound になってるか？」は以下のようにして確認できます。(Notification 表示が強制されるから通知バー見ればいいじゃん、と言われればそうなんですけど、ちゃんとしたエビデンスっぽいのが欲しくて)</p>

<!--more-->


<h2>手順</h2>

<p><code>sh
adb shell dumpsys activity s &lt;サービス名&gt;
</code></p>

<p>&lt;サービス名> はサービスの完全名称を入れます。AndroidManifest.xml の <code>&lt;service android:name=</code> で定義したやつ。</p>

<p>実行すると以下のように出力されます。</p>

<blockquote><p>ACTIVITY MANAGER SERVICES (dumpsys activity services)
  User 0 active services:
  * ServiceRecord{41b2dd18 u0 com.amay077.android.gpsfaker/.service.GpsSignalService}</p>

<pre><code>intent={cmp=com.amay077.android.gpsfaker/.service.GpsSignalService}
packageName=com.amay077.android.gpsfaker
processName=com.amay077.android.gpsfaker
baseDir=/data/app/com.amay077.android.gpsfaker-1.apk
dataDir=/data/data/com.amay077.android.gpsfaker
app=ProcessRecord{416e19e8 3209:com.amay077.android.gpsfaker/u0a10072}
isForeground=true foregroundId=2130968576 foregroundNoti=Notification(pri=0 contentView=com.amay077.android.
</code></pre>

<p>(以下省略)</p></blockquote>

<p><code>isForegound=true</code> と表示されているので、確かに「このサービスはフォアグラウンドだ」と分かります。サービス側で <code>startForeground</code> を呼び出さなかった場合は、この項目は表れません。</p>

<p><code>dumpsys</code> 今までコマンドめんどいと思ってあまり使ってませんでしたすいませんでした(汗</p>

<h2>参考</h2>

<p>大変参考になりました。</p>

<ul>
<li><a href="http://yuki312.blogspot.com/2013/02/androidservicedump.html">Yukiの枝折: Android:Service.dumpでサービスの状態をダンプする</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WakeLock の状態を確認する]]></title>
    <link href="http://amay077.github.io/blog/2013/06/13/view-wakelock-status/"/>
    <updated>2013-06-13T20:58:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/06/13/view-wakelock-status</id>
    <content type="html"><![CDATA[<p>どのアプリが WakeLock を取得しているかを見る方法。</p>

<!--more-->


<p><code>sh
adb shell dumpsys power
</code></p>

<p>を実行して、ずらっと出力される中から "Wake Locks:" を探す。
出力されるのはこんな感じの情報。</p>

<blockquote><p>POWER MANAGER (dumpsys power)</p>

<p>Power Manager State:
 mDirty=0x0
 (中略)</p>

<p>Settings and Configuration:
 mDreamsSupportedConfig=true
 (中略)</p>

<p>Screen off timeout: 30000 ms
Screen dim duration: 6000 ms</p>

<p>Wake Locks: size=1
 SCREEN_BRIGHT_WAKE_LOCK        'WindowManager' ON_AFTER_RELEASE (uid=1000, pid=389, ws={WorkSource: uids=[10070]})</p>

<p>(以下省略)</p></blockquote>

<p>"Wake Locks: size=1" となっており、
'WindowManager' という TAG で <code>SCREEN_BRIGHT_WAKE_LOCK</code> が取得されているのが分かる。</p>

<h2>参考</h2>

<ul>
<li><a href="http://kazumeat.hatenablog.com/entry/20110814/1313295257">adb各種コマンド - 肉になるメモ</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fused Location Provider を近くのショッピングセンターで評価してみた]]></title>
    <link href="http://amay077.github.io/blog/2013/05/30/testing-fused-location-provider/"/>
    <updated>2013-05-30T21:31:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/05/30/testing-fused-location-provider</id>
    <content type="html"><![CDATA[<p>Android に新しく搭載された Fused Location Provider、これは GPS/WiFi/センサーを統合的に使ってその時ベストな位置を取得できるというもので、<a href="http://www.youtube.com/watch?feature=player_detailpage&amp;v=URcVZybzMUI#t=733s">Google I/O のデモ</a> が衝撃的だったので、自分でも試してみました。</p>

<!--more-->


<h2>検証環境とか</h2>

<ul>
<li>場所 : イオン豊橋南店（ええ田舎ですが何か？</li>
<li>日時 : 2013/05/30 17:30頃</li>
<li>天候 : 小雨（曇天だったので GPS は捕まえにくかったかも）</li>
<li>端末 : au HTC J(!蝶) OS は 4.0.4</li>
<li>GPS も WiFi も ON</li>
<li>Android SDK Tools : rev.21.1</li>
<li>Google Play service : rev.7</li>
<li>FusedProvider の Priority : PRIORITY_HIGH_ACCURACY</li>
<li>位置取得間隔 : 5秒</li>
<li>姿勢 : スマホを常に左手で掲げて、見ながら歩きました。</li>
</ul>


<h2>その1:駐車場〜1F〜駐車場</h2>

<p>駐車場に車を停めて、歩いて店内に入場、店内をなるべくゆっくり直線的にぐるっと徘徊して、退店、駐車場を歩いて戻って来ました。</p>

<p>緑が実際の経路、青が Fused Provider の経路です。</p>

<iframe width="425" height="350" frameborder="0" scrolling="no" marginheight="0" marginwidth="0" src="https://maps.google.co.jp/maps/ms?msa=0&amp;msid=206106708723125678709.0004ddec1d5240e6ba1d3&amp;brcurrent=3,0x6004d3ebe16cdde1:0xfb92e7477942b89b,0&amp;ie=UTF8&amp;t=h&amp;ll=34.709597,137.387786&amp;spn=0.001372,0.001735&amp;output=embed"></iframe>


<br /><small><a href="https://maps.google.co.jp/maps/ms?msa=0&amp;msid=206106708723125678709.0004ddec1d5240e6ba1d3&amp;brcurrent=3,0x6004d3ebe16cdde1:0xfb92e7477942b89b,0&amp;ie=UTF8&amp;t=h&amp;ll=34.709597,137.387786&amp;spn=0.001372,0.001735&amp;source=embed" style="color:#0000FF;text-align:left">FusedProviderの評価(イオン豊橋南店1F)</a> を表示</small>


<h2>その2:駐車場〜1F〜2F〜ぐるっと〜1F〜駐車場</h2>

<p>もう一度。
今度は入店してすぐエスカレータで2Fへ。2Fフロアをぐるっと回ってからエスカレータで1Fへ降りて駐車場へ戻って来ました。</p>

<iframe width="425" height="350" frameborder="0" scrolling="no" marginheight="0" marginwidth="0" src="https://maps.google.co.jp/maps/ms?t=h&amp;brcurrent=3,0x6004d3ec8f3f5bf5:0x7b6f4e2f69453e37,1&amp;msa=0&amp;msid=206106708723125678709.0004ddec316197e38b987&amp;source=embed&amp;ie=UTF8&amp;ll=34.709546,137.388057&amp;spn=0.003479,0.004517&amp;output=embed"></iframe>


<br /><small>大きな地図で <a href="https://maps.google.co.jp/maps/ms?t=h&amp;brcurrent=3,0x6004d3ec8f3f5bf5:0x7b6f4e2f69453e37,1&amp;msa=0&amp;msid=206106708723125678709.0004ddec316197e38b987&amp;source=embed&amp;ie=UTF8&amp;ll=34.709546,137.388057&amp;spn=0.003479,0.004517" style="color:#0000FF;text-align:left">FusedProviderの評価(イオン豊橋南店2F)</a> を表示</small>


<h2>結果をみて</h2>

<p>うーん、かいかぶり過ぎたか Fused Provider。</p>

<p>確かに GPS と WiFi をシームレスに扱ってくれているようですが、期待していた屋内での測位結果はちょっと残念でした。</p>

<p>I/O のセッションの中では、WiFi+Sensor を使ってると言っていたので、WiFi-AP の電波強度と加速度センサーの振れ具合で自律測位してくれるのかなあと思ったのですが、あまり自律測位が機能してないように見えます。</p>

<h3>Accuracy は？</h3>

<p>屋外だとだいたい 10m前後、屋内でも 20〜40m くらいの精度でした。
上図の幅が約200mですが、実際の位置よりもっと離れている感じがします。</p>

<p>Fused Provider を使うと、妙に Accuracy が小さい(精度の良い)値が得られるのですが、実際の位置がその精度が示す円の中にも入らないこともあり、それなら高い確率で実際の位置を包括する（精度の悪い）WiFi or 基地局測位 の方が有用では？とも思えました。</p>

<p>また、施設内に WiFi-AP が何個あったとかの細かい調査はしていません（たぶん５〜６個）が、都会の繁華街とか地下街の方が圧倒的に多いと思うので、また違った結果が出るものと思います。</p>

<h3>GPS の動きは？</h3>

<p>今回は <code>PRIORITY_HIGH_ACCURACY</code> を使いました。これは GPS を使います。(<code>PRIORITY_BALANCED_POWER_ACCURACY</code> は GPS を使いません［が、 <code>ACCESS_FINE_LOCATION</code> を付けないと精度が数kmレベルになります。］)</p>

<p>記録中の GPS アイコンの動きは、点滅 → 数秒後消える → また点滅 → GPSを捕捉したらつきっぱなし という感じで、屋外に移動すると GPS を捕まえる、屋内では度々トライするが捕まえられないのですぐ消える。という動きをしてました。</p>

<h3>状態認識は貢献してるのか？</h3>

<p>自律測位に状態認識(Activity Recognition)がもし使われているなら、持ちながらよりも、ポケットに入れっぱで歩いた方に最適化されてたかも知れないなあと思ったり。</p>

<p><a href="http://amay077.github.io/blog/2013/05/18/getting-started-activity-recognition/">ActivityRecognitionClient を試した</a> 時も、持ちながらよりも尻ポケに入れたまま歩いた方が認識されやすい気がしました。気だけですが。</p>

<h2>まとめ</h2>

<ul>
<li>Fused Provider に期待しすぎないでください</li>
<li>実際の位置から（精度値を超えて）大きく外れることもあるのが困る</li>
<li>パワーマネジメントはなんかやってるぽい（計測してないけど）</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[アプリ内でブロードキャストする場合は LocalBroadcastManager を使うと良いらしい]]></title>
    <link href="http://amay077.github.io/blog/2013/05/28/using-localbroadcastmanager/"/>
    <updated>2013-05-28T19:25:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/05/28/using-localbroadcastmanager</id>
    <content type="html"><![CDATA[<p>サポートパッケージに<code>LocalBroadcastManager</code> というクラスがあるのを今頃知りまして。</p>

<!--more-->


<ul>
<li><a href="http://developer.android.com/reference/android/support/v4/content/LocalBroadcastManager.html">LocalBroadcastManager | Android Developers</a></li>
</ul>


<p>ブロードキャストは使い方を誤るとデータを(アプリの)外部に流出させる可能性があるわけですが(<a href="http://www.jssec.org/report/securecoding.html">Android アプリのセキュア設計・セキュアコーディングガイド</a> 参照)、このクラスを使うと「他のアプリにデータを漏らさない」「意図しないブロードキャストを受信しない」「効率がよい」だそうです。</p>

<h2>いつ使うんですか？</h2>

<p>たとえば GPS を使うアプリで、GPS の受信は <code>IntentService</code> にやらせて、受信した位置を地図に表示するために、IntentService からブロードキャスト投げて、<code>Activity</code> に仕掛けたレシーバで受信する、なんてケースでしょうか。(いやそれは IntentService じゃなくて普通のサービスで aidl 使ってやれよ、とかいろいろあるわけですが。ん？PendingIntent でサービスを起動する方法だと、クライアントから bind するタイミングが無いからダメかな？)</p>

<h2>使い方</h2>

<p>stackoverflow に良い使い方が載ってました</p>

<ul>
<li><a href="http://stackoverflow.com/a/8875292">android - how to use LocalBroadcastManager? - Stack Overflow</a></li>
</ul>


<h2>使ってみた</h2>

<p>状態認識の結果も秘匿情報でしょう、ということで<a href="http://amay077.github.io/blog/2013/05/18/getting-started-activity-recognition/">以前</a>作った <code>ActivityRecognitionClient</code> のサンプルを修正してみました。</p>

<ul>
<li><a href="https://github.com/amay077/androidactivityrecognizingsample/commit/a041b300d3e9fdfe6227c05c3f21fb1e3876bbad">amay077/androidactivityrecognizingsample · GitHub</a></li>
</ul>


<h2>まとめ</h2>

<ul>
<li>ブロードキャストする時は、まず LocalBroadcastManager を使ってみよう。</li>
<li>stackoverflow の回答へのダイレクトリンクとか、github の changeset へのダイレクトリンク便利すぎる！</li>
</ul>

]]></content>
  </entry>
  
</feed>
