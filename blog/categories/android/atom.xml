<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | Experiments Never Fail]]></title>
  <link href="http://blog.amay077.net/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://blog.amay077.net/"/>
  <updated>2014-08-31T00:50:08+09:00</updated>
  <id>http://blog.amay077.net/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Xamarin.Android が使用する debug.keystore の在処]]></title>
    <link href="http://blog.amay077.net/blog/2014/08/28/place-of-debug-keystore-that-xamarin-to-use/"/>
    <updated>2014-08-28T17:42:04+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/08/28/place-of-debug-keystore-that-xamarin-to-use</id>
    <content type="html"><![CDATA[<p>Google Maps などを使用する時、開発中ならば <code>debug.keystore</code> のフィンガープリント(SHA1)を取得する必要がありますが、 debug.keystore がどこにあるのか分からなくてハマった。</p>

<!--more-->


<h2>結論</h2>

<p>から書いておくと</p>

<ul>
<li><a href="http://developer.xamarin.com/guides/android/platform_features/maps_and_location/maps/obtaining_a_google_maps_api_key/">Obtaining a Google Maps API Key | Xamarin</a></li>
</ul>


<p>に書いてある通りで、</p>

<ul>
<li>Windows &ndash; <code>C:¥Users¥[USERNAME]¥AppData¥Local¥Xamarin¥Mono for Android¥debug.keystore</code></li>
<li>OSX &ndash; <code>/Users/[USERNAME]/.local/share/Xamarin/Mono for Android/debug.keystore</code></li>
</ul>


<p>がそれぞれ使われる。</p>

<h2>なぜハマったか？</h2>

<h3>Eclipse と同じだと思ってた</h3>

<p>Java での Android 開発時に設定したディレクトリを使ってくれると思い込んでた。けどよく考えればあれは Android SDK ではなく Eclipse 固有の設定だったのよね。</p>

<h3>ドキュメントが古いと思ってた</h3>

<p>上記で紹介した「Obtaining a Google Maps…」の記事が古いと思ってた。なぜならディレクトリ名に <code>Mono for Android</code> が含まれていて、これは Xamarin.Android の旧製品名だったから。</p>

<h3>Spotlight検索でヒットしなかった</h3>

<p>Mac を使っているのだけど、Spotlight検索（所謂PC内検索）で <code>debug.keystore</code> がヒットしたのがいつもJava-Android開発で使ってる１つだけだったので、.local の中にあるとは気付けず。。。隠しディレクトリだからヒットしないよね。</p>

<p>こんなことでハマるのは自分くらいだろうけど、メモしときます。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Cardboard を作ってきました]]></title>
    <link href="http://blog.amay077.net/blog/2014/08/16/make-google-cardboard/"/>
    <updated>2014-08-16T23:42:38+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/08/16/make-google-cardboard</id>
    <content type="html"><![CDATA[<ul>
<li><a href="http://connpass.com/event/7735/">日本Androidの会浜松支部 第40回ミーティング #jaghama &ndash; connpass</a></li>
</ul>


<p>で Google Cardboard のクローンを作りました。</p>

<!--more-->


<p>段ボールやレンズ、磁石などの材料は主催の方が用意してくださった( <a href="https://twitter.com/macha1972">@macha1972</a> さんありがとうございます )ので、カッターとガムテープと筆記具くらいを持参するだけですみました。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/make-google-cardboard-01.jpg" alt="" /></p>

<p><a href="https://developers.google.com/cardboard/">公式サイト</a> からダウンロードできる型紙を印刷して、段ボールに貼り付け、段ボールを切っていきます。</p>

<p>段ボールが意外と厚くて切るのに苦労しました。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/make-google-cardboard-02.jpg" alt="" /></p>

<p>ここまでくるのに約3時間…（-_&ndash;;）
早い人は2時間くらいで終わってたかな・・・。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/make-google-cardboard-03.jpg" alt="" /></p>

<p>切っちゃえば組み立ては簡単(先駆者さんに聞きながらできたからw)
「バター風味」がいい感じに露出しているのは偶然だw</p>

<p>使用した端末は公式に対応しているとされる Galaxy Nexus だったので稼働に特に問題はありません(磁石のスイッチが反応しづらいかなという程度)でしたが、端末の磁場センサーの位置によっては、スイッチの位置を反対側に移動させる必要があるみたいです。(Xperia の人はそうしてました)</p>

<p>さっそく <a href="https://play.google.com/store/apps/details?id=com.google.samples.apps.cardboarddemo&amp;hl=ja">Cardboardアプリ</a> で体験…これはスゴイ！
以前に Ocufes豊橋 で Oculas Lift は体験済みだったのですが、それに匹敵する没入感です。</p>

<ul>
<li><a href="https://play.google.com/store/apps/details?id=com.divegames.divecitycoaster&amp;hl=ja">Dive City Rollercoaster</a> というアプリが面白いですね。</li>
</ul>


<p>帰宅後、さっそく子供らも体験、しばらくの間ハマってました。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/make-google-cardboard-04.jpg" alt="" /></p>

<p>子供の夏休みの自由工作にでもできるかなーと思いますが、大人で3時間かかるのは結構つらいかも。</p>

<p>カッターで段ボールを切るのに力入れすぎて指にマメできたし…。</p>

<p>ワークショップ中のその他の写真は</p>

<ul>
<li><a href="https://www.facebook.com/media/set/?set=o.282944361773276&amp;type=3">日本Androidの会 浜松支部の写真・動画 &ndash; Facebookグループ</a></li>
</ul>


<p>からどうぞ。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ドラッグ＆ドロップで並び替えできる ListView]]></title>
    <link href="http://blog.amay077.net/blog/2014/07/01/listview-supports-swapitem-by-dragdrop/"/>
    <updated>2014-07-01T00:00:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/07/01/listview-supports-swapitem-by-dragdrop</id>
    <content type="html"><![CDATA[<p>最近こういうUI見たことないなあ、と思いながらも、実装の必要があったので、いろいろ先駆者さま達の足跡を辿り、最終的に、</p>

<!--more-->


<ul>
<li><a href="http://shogogg.hatenablog.jp/entry/20110118/1295326773">ドラッグ＆ドロップで並び替えできる ListView &ndash; パンダのメモ帳</a></li>
</ul>


<p>が自分のやりたい事に最も近く、割と新し（といっても３年前…）かったので参考にしました。</p>

<p>ただ、こちらの実装だと、ListView の上にマージンがあるとドラッグ中のアイテムの描画がすこしバグってたので、修正して使いました。</p>

<p>こんな感じ↓です。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/drag_and_drop_listview_01.gif" alt="" /> capture by <a href="http://www.cockos.com/licecap/">LICEcap</a></p>

<p>修正後のソースです。</p>

<p>修正箇所は２つ</p>

<ol>
<li><code>mActionDownEvent</code> を参照の保持でなく、 <code>obtain</code> してクローンを保持するように（＋ <code>recycle</code> で破棄）。<code>onTouchEvent</code> の 引数 <code>event</code> は、内部で使いまわされるようで、参照のコピーでは、値が勝手に変わっていました。</li>
<li><code>updateLayoutParams</code> はスクリーン座標を前提に。元は <code>listView.getTop() + event.getY()</code> でしたが、これではステータスバーとActionBarの高さが考慮されないようだったので、<code>event.getRawY()</code> を使うようにしました。</li>
</ol>


<p>```java SortableListView.java
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.PixelFormat;
import android.util.AttributeSet;
import android.view.Gravity;
import android.view.MotionEvent;
import android.view.View;
import android.view.WindowManager;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemLongClickListener;
import android.widget.ImageView;
import android.widget.ListView;</p>

<p>public class SortableListView extends ListView implements</p>

<pre><code>    OnItemLongClickListener {
private static final int SCROLL_SPEED_FAST = 25;
private static final int SCROLL_SPEED_SLOW = 8;
private static final Bitmap.Config DRAG_BITMAP_CONFIG = Bitmap.Config.ARGB_8888;

private boolean mSortable = false;
private boolean mDragging = false;
private DragListener mDragListener = new SimpleDragListener();
private int mBitmapBackgroundColor = Color.argb(128, 0xFF, 0xFF, 0xFF);
private Bitmap mDragBitmap = null;
private ImageView mDragImageView = null;
private WindowManager.LayoutParams mLayoutParams = null;
private MotionEvent mActionDownEvent;
private int mPositionFrom = -1;

/** コンストラクタ */
public SortableListView(Context context) {
    super(context);
    setOnItemLongClickListener(this);
}

/** コンストラクタ */
public SortableListView(Context context, AttributeSet attrs) {
    super(context, attrs);
    setOnItemLongClickListener(this);
}

/** コンストラクタ */
public SortableListView(Context context, AttributeSet attrs, int defStyle) {
    super(context, attrs, defStyle);
    setOnItemLongClickListener(this);
}

/** ドラッグイベントリスナの設定 */
public void setDragListener(DragListener listener) {
    mDragListener = listener;
}

/** ソートモードの切替 */
public void setSortable(boolean sortable) {
    this.mSortable = sortable;
}

/** ソート中アイテムの背景色を設定 */
@Override
public void setBackgroundColor(int color) {
    mBitmapBackgroundColor = color;
}

/** ソートモードの設定 */
public boolean getSortable() {
    return mSortable;
}

/** MotionEvent から position を取得する */
private int eventToPosition(MotionEvent event) {
    return pointToPosition((int) event.getX(), (int) event.getY());
}

/** タッチイベント処理 */
@Override
public boolean onTouchEvent(MotionEvent event) {
    if (!mSortable) {
        return super.onTouchEvent(event);
    }
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN: {
            storeMotionEvent(event);
            break;
        }
        case MotionEvent.ACTION_MOVE: {
            if (duringDrag(event)) {
                return true;
            }
            break;
        }
        case MotionEvent.ACTION_UP: {
            if (stopDrag(event, true)) {
                return true;
            }
            break;
        }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_OUTSIDE: {
            if (stopDrag(event, false)) {
                return true;
            }
            break;
        }
    }
    return super.onTouchEvent(event);
}

/** リスト要素長押しイベント処理 */
@Override
public boolean onItemLongClick(AdapterView&lt;?&gt; parent, View view,
        int position, long id) {
    return startDrag();
}

/** ACTION_DOWN 時の MotionEvent をプロパティに格納 */
private void storeMotionEvent(MotionEvent event) {
    mActionDownEvent = MotionEvent.obtain(event); // 複製しないと値が勝手に変わる
}

/** ドラッグ開始 */
private boolean startDrag() {
    // イベントから position を取得
    mPositionFrom = eventToPosition(mActionDownEvent);

    // 取得した position が 0未満＝範囲外の場合はドラッグを開始しない
    if (mPositionFrom &lt; 0) {
        return false;
    }
    mDragging = true;

    // View, Canvas, WindowManager の取得・生成
    final View view = getChildByIndex(mPositionFrom);
    final Canvas canvas = new Canvas();
    final WindowManager wm = getWindowManager();

    // ドラッグ対象要素の View を Canvas に描画
    mDragBitmap = Bitmap.createBitmap(view.getWidth(), view.getHeight(),
            DRAG_BITMAP_CONFIG);
    canvas.setBitmap(mDragBitmap);
    view.draw(canvas);

    // 前回使用した ImageView が残っている場合は除去（念のため？）
    if (mDragImageView != null) {
        wm.removeView(mDragImageView);
    }

    // ImageView 用の LayoutParams が未設定の場合は設定する
    if (mLayoutParams == null) {
        initLayoutParams();
    }

    // ImageView を生成し WindowManager に addChild する
    mDragImageView = new ImageView(getContext());
    mDragImageView.setBackgroundColor(mBitmapBackgroundColor);
    mDragImageView.setImageBitmap(mDragBitmap);
    wm.addView(mDragImageView, mLayoutParams);

    // ドラッグ開始
    if (mDragListener != null) {
        mPositionFrom = mDragListener.onStartDrag(mPositionFrom);
    }
    return duringDrag(mActionDownEvent);
}

/** ドラッグ処理 */
private boolean duringDrag(MotionEvent event) {
    if (!mDragging || mDragImageView == null) {
        return false;
    }
    final int x = (int) event.getX();
    final int y = (int) event.getY();
    final int height = getHeight();
    final int middle = height / 2;

    // スクロール速度の決定
    final int speed;
    final int fastBound = height / 9;
    final int slowBound = height / 4;
    if (event.getEventTime() - event.getDownTime() &lt; 500) {
        // ドラッグの開始から500ミリ秒の間はスクロールしない
        speed = 0;
    } else if (y &lt; slowBound) {
        speed = y &lt; fastBound ? -SCROLL_SPEED_FAST : -SCROLL_SPEED_SLOW;
    } else if (y &gt; height - slowBound) {
        speed = y &gt; height - fastBound ? SCROLL_SPEED_FAST
                : SCROLL_SPEED_SLOW;
    } else {
        speed = 0;
    }

    // スクロール処理
    if (speed != 0) {
        // 横方向はとりあえず考えない
        int middlePosition = pointToPosition(0, middle);
        if (middlePosition == AdapterView.INVALID_POSITION) {
            middlePosition = pointToPosition(0, middle + getDividerHeight()
                    + 64);
        }
        final View middleView = getChildByIndex(middlePosition);
        if (middleView != null) {
            setSelectionFromTop(middlePosition, middleView.getTop() - speed);
        }
    }

    // ImageView の表示や位置を更新
    if (mDragImageView.getHeight() &lt; 0) {
        mDragImageView.setVisibility(View.INVISIBLE);
    } else {
        mDragImageView.setVisibility(View.VISIBLE);
    }
    updateLayoutParams((int)event.getRawY()); // ここだけスクリーン座標を使う
    getWindowManager().updateViewLayout(mDragImageView, mLayoutParams);
    if (mDragListener != null) {
        mPositionFrom = mDragListener.onDuringDrag(mPositionFrom,
                pointToPosition(x, y));
    }
    return true;
}

/** ドラッグ終了 */
private boolean stopDrag(MotionEvent event, boolean isDrop) {
    if (!mDragging) {
        return false;
    }
    if (isDrop &amp;&amp; mDragListener != null) {
        mDragListener.onStopDrag(mPositionFrom, eventToPosition(event));
    }
    mDragging = false;
    if (mDragImageView != null) {
        getWindowManager().removeView(mDragImageView);
        mDragImageView = null;
        // リサイクルするとたまに死ぬけどタイミング分からない by vvakame
        // mDragBitmap.recycle();
        mDragBitmap = null;

        mActionDownEvent.recycle();
        mActionDownEvent = null;
        return true;
    }
    return false;
}

/** 指定インデックスのView要素を取得する */
private View getChildByIndex(int index) {
    return getChildAt(index - getFirstVisiblePosition());
}

/** WindowManager の取得 */
protected WindowManager getWindowManager() {
    return (WindowManager) getContext().getSystemService(
            Context.WINDOW_SERVICE);
}

/** ImageView 用 LayoutParams の初期化 */
protected void initLayoutParams() {
    mLayoutParams = new WindowManager.LayoutParams();
    mLayoutParams.gravity = Gravity.TOP | Gravity.LEFT;
    mLayoutParams.height = WindowManager.LayoutParams.WRAP_CONTENT;
    mLayoutParams.width = WindowManager.LayoutParams.WRAP_CONTENT;
    mLayoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
            | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE
            | WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON
            | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS;
    mLayoutParams.format = PixelFormat.TRANSLUCENT;
    mLayoutParams.windowAnimations = 0;
    mLayoutParams.x = getLeft();
    mLayoutParams.y = getTop();
}

/** ImageView 用 LayoutParams の座標情報を更新 */
protected void updateLayoutParams(int rawY) {
    mLayoutParams.y =  rawY - 32;
}

/** ドラッグイベントリスナーインターフェース */
public interface DragListener {
    /** ドラッグ開始時の処理 */
    public int onStartDrag(int position);

    /** ドラッグ中の処理 */
    public int onDuringDrag(int positionFrom, int positionTo);

    /** ドラッグ終了＝ドロップ時の処理 */
    public boolean onStopDrag(int positionFrom, int positionTo);
}

/** ドラッグイベントリスナー実装 */
public static class SimpleDragListener implements DragListener {
    /** ドラッグ開始時の処理 */
    @Override
    public int onStartDrag(int position) {
        return position;
    }

    /** ドラッグ中の処理 */
    @Override
    public int onDuringDrag(int positionFrom, int positionTo) {
        return positionFrom;
    }

    /** ドラッグ終了＝ドロップ時の処理 */
    @Override
    public boolean onStopDrag(int positionFrom, int positionTo) {
        return positionFrom != positionTo &amp;&amp; positionFrom &gt;= 0
                || positionTo &gt;= 0;
    }
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.Forms、Android での BACK キーの制御]]></title>
    <link href="http://blog.amay077.net/blog/2014/06/17/hooking-back-key-in-xamarin-forms/"/>
    <updated>2014-06-17T01:00:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/06/17/hooking-back-key-in-xamarin-forms</id>
    <content type="html"><![CDATA[<p><a href="http://qiita.com/amay077/items/12979585ac3e2dcacacb">Xamarin.Forms でどうにかしたい iOS と Android の違い</a> の「BACKキーの制御」の <strong>現時点(1.1.0.6201)</strong> での回答。</p>

<!--more-->


<p>Android の BACKキーの制御を、Xamarin.Forms ではどう扱えるかを調べた。</p>

<h2>シナリオ</h2>

<p>Xamarin.Forms による画面１(MainPage)、２(SecondPage)があり、MainPage では BACKキーで戻る(=アプリ終了)事ができるが、SecondPage ではBACKキーが効かない、ようにしたい。</p>

<h2>対策</h2>

<p>まず画面１と２はこんな感じ。ボタンを押したら画面２へ遷移するだけ。</p>

<p>```csharp Pages.cs
// 画面１
public class MainPage : ContentPage
{</p>

<pre><code>public MainPage() 
{
    var button = new Button
    {
        Text = "To Second",
        VerticalOptions = LayoutOptions.Center,
    };

    button.Clicked += (sender, e) =&gt; 
    {
        this.Navigation.PushAsync(new SecondPage());
    };

    Content = button;
}
</code></pre>

<p>}</p>

<p>// 画面２
public class SecondPage : ContentPage
{</p>

<pre><code>public SecondPage()
{
    Content = new Label
    {
        Text = "Second"
    };
}
</code></pre>

<p>}
```</p>

<p>ここからが本題。
まず Android側のエントリポイントである <code>MainActivity.cs</code> は以下のように、<code>ContentPage</code> プロパティを設ける。そして <code>OnBackPressed</code> メソッドを override して、MainPage だったら OnBackPressed を親へ伝搬する。</p>

<p>```csharp MainActivity.cs
[Activity(Label = &ldquo;ScrollTest.Android.Android&rdquo;, MainLauncher = true)]
public class MainActivity : AndroidActivity
{</p>

<pre><code>protected override void OnCreate(Bundle bundle)
{
    base.OnCreate(bundle);

    Xamarin.Forms.Forms.Init(this, bundle);

    SetPage(new NavigationPage(new MainPage()));
}

internal Page ContentPage
{
    get;
    set;
}

public override void OnBackPressed()
{
    if (this.ContentPage is MainPage)
    {
        base.OnBackPressed();
    }
}
</code></pre>

<p>}
```</p>

<p>次に、MainActivity.ContentPage への設定を行うコードは以下の通り。
PageRenderer を拡張して ExportRenderer することで、すべての Page にフックをかけ、Page の表示時に MainActivity.ContentPage に設定する。</p>

<p>```csharp MyPageRenderer.cs
using System;
using Xamarin.Forms.Platform.Android;
using Android.App;
using Xamarin.Forms;
using ScrollTest.Android;
using Android.Views;
using Android.Graphics;</p>

<p>[assembly:ExportRenderer(typeof(ContentPage), typeof(MyPageRenderer))]</p>

<p>namespace ScrollTest.Android
{</p>

<pre><code>public class MyPageRenderer : PageRenderer
{
    protected override void OnElementChanged(ElementChangedEventArgs&lt;Xamarin.Forms.Page&gt; e)
    {
        base.OnElementChanged(e);

        // なんとなく不安なので weak にしてみた
        var activity = new WeakReference&lt;MainActivity&gt;(this.Context as MainActivity);

        e.NewElement.Appearing += (_, __) =&gt;
        {
            MainActivity a;
            if (activity.TryGetTarget(out a)) {
                a.ContentPage = e.NewElement;    
            }
        };
    }
}
</code></pre>

<p>}
```</p>

<p>これで、画面１(MainPage)の時だけ BACKキーが効くようにできる。</p>

<h3><code>Appearing</code> イベントが必要なの？</h3>

<p>　Xamarin.Forms の Android実装では、画面遷移の度に <strong>「同じインスタンスの MainActivity」</strong> が使いまわされる、さらに <code>OnElementChanged</code> は、各Pageにつき１度しか発生しない。その為、画面１→２→１と遷移すると <code>MainActivity.ContentPage</code> は <code>SecondPage</code> のままになってしまう。ので <code>Appearing</code> イベントで表示の度に MainActivity.ContentPage を設定する必要がある。</p>

<h3><code>AndroidActivity</code> に static な <code>BackPressed</code> イベントがあるんだけど…</h3>

<p>イベントハンドラの定義は
<code>public delegate bool BackButtonPressedEventHandler(object sender, EventArgs e);</code>
となっていて、<code>true</code> を返すと BACK キーを無効にできるようなのだけど、<code>sender</code> は <code>MainActivity</code>だし、<code>EventArgs</code> は Page を取得できないしで使えないじゃん。。。</p>

<p>なんだかすごく発展途上な気がする、その内いろいろ整備されそうなので、それまで待った方が良い気がします。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.Forms でどうにかしたい iOS と Android の違い]]></title>
    <link href="http://blog.amay077.net/blog/2014/06/10/difference-ios-and-android-in-xamarin-forms/"/>
    <updated>2014-06-10T15:30:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/06/10/difference-ios-and-android-in-xamarin-forms</id>
    <content type="html"><![CDATA[<p>Xamarin.Forms で簡単な iOS/Android 両対応アプリを作ってみてて、悩ましい点がいくつか見つかってるので、挙げてみる。</p>

<!--more-->


<h2><del>不可視の扱い</del></h2>

<p><del>Forms 側のパーツには <code>IsVisible = true | false</code> がある。
iOS は <code>true | false</code> なのでいいけど、Android の Visibility は、 <code>Visible | Invisible | Gone</code> の3つある。</del></p>

<p><del>Forms 側での <code>IsVisible = false</code> は、Android では <code>Invisible</code> に相当するみたい。つまり StackLayout とかで「不可視なパーツが <strong>詰められない</strong>」。 iOS の <code>Visible = false</code> は <strong>詰められる</strong> 模様。</del></p>

<p><code>IsVisible = false</code> は Android ではちゃんと <code>Gone</code> になってました、すいませんでした。</p>

<h2>空文字の扱い</h2>

<p>IsVisible と勘違いしてたのはこっちだった。</p>

<p>StackLayout に、Label を2つ積んで、上の Label を空文字にすると、iOSでは詰められるけど、Androidでは空白が空くみたい。こっちはちゃんと裏をとった(汗)</p>

<p><a href="https://gist.github.com/amay077/cf0f4ca1aa14d54bac9a">https://gist.github.com/amay077/cf0f4ca1aa14d54bac9a</a></p>

<h2>画面回転時の再構築</h2>

<p>Android だと、画面を回転させると <code>onCreate</code> からやり直しなのは常識。
Forms アプリを Android で動かして回転させると、なんと <strong>RootPage まで戻って</strong> しまう。なんじゃこりゃ。</p>

<h2>回避方法</h2>

<blockquote class="twitter-tweet" lang="ja"><p><a href="https://twitter.com/amay077">@amay077</a> あとAndroidの回転問題（バグです）はとりあえず ConfigurationChanges = ConfigChanges.ScreenSize | ConfigChanges.Orientation で回避するといいそうです（そりゃそうだ…）</p>&mdash; Atsushi Eno (@atsushieno) <a href="https://twitter.com/atsushieno/statuses/476645011602165760">2014, 6月 11</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>こんな感じっすね。</p>

<p>```csharp MainActivity.cs
[Activity(MainLauncher = true,</p>

<pre><code>ConfigurationChanges = ConfigChanges.ScreenSize | ConfigChanges.Orientation )]
</code></pre>

<p>public class MainActivity : AndroidActivity
{
```</p>

<h2>BACKキーの扱い</h2>

<p>iOS なら <code>NavigationPage.SetHasNavigationBar(page, false)</code> としてしまえば、ナビゲーションバーが表示されなくなるので、前の画面に戻ることはできなくなるが、Android の BACKキーを無効にするにはどうしたら。。。</p>

<h3>自己解決</h3>

<p><code>AndroidActivity</code> のサブクラスで、<code>OnBackPressed</code> を override して実装を潰してしまえばよい。けど画面毎に「戻る／戻れない／Confirm出す」とか細かい制御ができるのかは不明。</p>

<h2>デフォルトスタイル</h2>

<p>iOS は白基調、Androidは黒基調なので、Forms側で <code>TextColor = Color.Black</code> などとすると、当たり前だが Android で見えない。
iOS はスタイル変えるのしんどいので、Android側の Theme を <code>Theme.Holo.Light</code> にしとく。</p>

<p>```csharp MainActivity.cs
[Activity(Label = &ldquo;MyApp&rdquo;,<br/>
 MainLauncher = true,
 Theme = &ldquo;@android:style/Theme.Holo.Light&rdquo;)]
public class MainActivity : AndroidActivity
{</p>

<pre><code>protected override void OnCreate(Bundle bundle)
{
    /* 以下省略 */
</code></pre>

<p>```</p>

<h2>起動時</h2>

<p>Android 側の起動時に ActionBar の付いた空白画面が表示される時間が割とながくて気になる(Galaxy Nexus だけど)。Forms の画面をロードするのに時間がかかるのだろうか？
ActionBar だけでも消したくて Theme を <code>Theme.Holo.Light.NoActionBar</code> にしてみたら Page が表示されなくなった。。。</p>

<p>NoActionBar な Theme を使うと Activity.ActionBar が null になるんだけど、Xamarin.Forms がそれに対応してない気がした（スタックトレース見ると UpdateActionBar で NullReferenceException だし）ので、<a href="https://bugzilla.xamarin.com/buglist.cgi?product=Forms&amp;component=Forms&amp;resolution=---&amp;list_id=92025">Bugzilla</a> に登録してみた、初めて。どうなるやら。</p>

<h2>文字の自動縮小</h2>

<p>iOS の <code>UITextField</code> は <code>adjustsFontSizeToFitWidth</code> を設定するとパーツのサイズに合わせて文字サイズを自動拡縮してくれる機能があったけど、Forms の <code>Label</code> にはそんなものはありません。<code>PageRenderer</code> を使って iOS 独自処理しないとダメ。</p>

<h3>自己解決</h3>

<p>やはり PageRenderer 使うとできた → <a href="http://qiita.com/amay077/items/8eaa595cc2fc88797b2f">Xamarin.Forms の Label から iOS の UILabel を取り出す</a></p>

<h2>iPhone と iPad</h2>

<p>StackLayout や RelativeLayout でUIを書けば、相対的な位置関係は iPhone と同じものが iPad でも再現されるが、サイズをリテラルで指定するところは、特にインテグレーションしてくれるわけでないので、プラットフォーム毎に調整が必要。例えば文字サイズは、iPad では iPhone より大きな値にしないと残念な感じに。</p>

<p>他にも見つけたら書きます。</p>
]]></content>
  </entry>
  
</feed>
