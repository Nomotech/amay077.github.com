<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | Experiments Never Fail]]></title>
  <link href="http://blog.amay077.net/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://blog.amay077.net/"/>
  <updated>2014-10-30T01:38:35+09:00</updated>
  <id>http://blog.amay077.net/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ReactiveX と MVVM と DataBinding の関係について図にしてみた]]></title>
    <link href="http://blog.amay077.net/blog/2014/10/30/reactivex-mvvm-databindings-relations/"/>
    <updated>2014-10-30T01:17:39+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/10/30/reactivex-mvvm-databindings-relations</id>
    <content type="html"><![CDATA[<ul>
<li><a href="http://connpass.com/event/8680/">ReactiveCocoa Tokyo #rac_tokyo &ndash; connpass</a></li>
<li><a href="http://connpass.com/event/9061/">RxJava Night #rxjnight &ndash; connpass</a></li>
<li><a href="http://mozaic.fm/post/100741841543/10-node-js-sideshow">#10 node.js sideshow | mozaic.fm</a></li>
</ul>


<!--more-->


<p>などなどをいろいろ眺めておりまして（東京うらやましい）、Reactive Extensions とか MVVM とかいろいろ熱い！楽しい！と思っているわけですが、いろいろなライブラリがあって、それらのカバーする範囲がいまいち明確になってない気がしたので、自分なりに整理してみました。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/reactive_mvvm_databindings_relations_01.png" alt="" /></p>

<p>MVVM っていうと、Messenger とか DIコンテナ的なものとかもあるわけですが、主に DataBinding と Rx の違いにフィーチャーしたかったので除外しました。</p>

<p>　DataBinding は、<a href="http://www.atmarkit.co.jp/ait/articles/1008/03/news097_3.html">DependencyProperty</a> や <a href="http://blog.falafel.com/learning-xamarin-custom-renderers-in-xamarin-forms/">BindableProperty</a> みたいなものがあるかどうかという感じで考えていて、「XAMLとかのマークアップでバインディング指定できなければならない」という考えではないです。</p>

<p>　View, DataBinding, ViewModel, ReactiveX の各ブロックは基本的にはどの組み合わせでもよくて（特に ReactiveX は他とは別の世界のものなので）、しかし中には ReactiveProperty のように ReactiveX に依存しつつ ViewModel の機能を提供するものがあったり、ReactiveCocoa のように「全部入り」のものがあったりします。また、View と ViewModel を繋ぐためにはなんらかの DataBinding が必要です。</p>

<p>という理解なんですが、あってますかね？</p>

<p>　私は Xamarin 推しの人なので、 <strong>Xamarin.Forms + ReactiveProperty が、MVVM+Rx のパワーをフル活用できて、しかも iOS/Android で大部分のコードが共有できるという最強の組み合わせなんですよ！</strong> というのを言いたいわけです。</p>

<h2>Links</h2>

<ul>
<li>Xamarin.Forms &ndash; <a href="http://xamarin.com/forms">Build a Native Android UI &amp; iOS UI with Xamarin.Forms &ndash; Xamarin</a></li>
<li>Prism &ndash; <a href="http://compositewpf.codeplex.com/releases/view/117297">patterns &amp; practices: Prism &ndash; Download: Prism 5.0 for .NET 4.5</a></li>
<li>MVVM Light Toolkit &ndash; <a href="https://mvvmlight.codeplex.com/">MVVM Light Toolkit &ndash; Home</a></li>
<li>Reactive Extensions &ndash; <a href="https://rx.codeplex.com/">Rx (Reactive Extensions) &ndash; Home</a></li>
<li>ReactiveProperty &ndash; <a href="https://reactiveproperty.codeplex.com/">ReactiveProperty &ndash; MVVM Extensions for Rx &ndash; Home</a></li>
<li>ReactiveUI &ndash; <a href="https://github.com/reactiveui/reactiveui">reactiveui/ReactiveUI</a></li>
<li>MvvmCross &ndash; <a href="https://github.com/MvvmCross/MvvmCross">MvvmCross/MvvmCross</a></li>
<li>RxJava &ndash; <a href="https://github.com/ReactiveX/RxJava">ReactiveX/RxJava</a></li>
<li>RxAndroid &ndash; <a href="https://github.com/ReactiveX/RxAndroid">ReactiveX/RxAndroid</a></li>
<li>android-binding &ndash; <a href="https://github.com/gueei/AndroidBinding">gueei/AndroidBinding</a></li>
<li>ReactiveCocoa &ndash; <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa/ReactiveCocoa</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ボタンを重ねた時の ZOrder に関する Tips]]></title>
    <link href="http://blog.amay077.net/blog/2014/09/23/views-zorder/"/>
    <updated>2014-09-23T00:20:38+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/09/23/views-zorder</id>
    <content type="html"><![CDATA[<p>Android 開発でボタンを意図的に重ねたい時ってあんまりないんですけど、業務アプリなんか作ってますとたまにありまして。</p>

<!--more-->


<p>具体的には、</p>

<ul>
<li><a href="http://coliss.com/articles/build-websites/operation/css/10-css-breadcrumbs.html">デザインの勉強にもなる、CSSで実装するパンくずのまとめ | コリス</a></li>
</ul>


<p>みたいなパンくずリストを作りたい時。変な形のボタンを作るのは骨が折れるので、ボタンを重ねて、左側の方が手前に表示されるようにしたいわけです。(なぜそうしたいかはたぶん伝わらないので割愛)</p>

<p>つまりはボタンを重ねた時の ZOrder（Z-index）を制御したいわけです。</p>

<p>でいろいろトライ。</p>

<h2>LinearLayout の場合</h2>

<p>LinearLayout で横並びにする場合。</p>

<p>```xml main.xml
&lt;LinearLayout</p>

<pre><code>android:layout_width="match_parent"
android:layout_height="30dp"
android:orientation="horizontal"&gt;

&lt;Button
    android:background="#FF0000"
    android:text="AAA"
    android:layout_width="50dp"
    android:layout_height="match_parent" /&gt;
&lt;Button
    android:background="#00FF00"
    android:text="BBB"
    android:layout_marginLeft="-10dp"
    android:layout_width="50dp"
    android:layout_height="match_parent" /&gt;
&lt;Button
    android:background="#0000FF"
    android:text="CCC"
    android:layout_marginLeft="-10dp"
    android:layout_width="50dp"
    android:layout_height="match_parent" /&gt;
</code></pre>

<p></LinearLayout>
```</p>

<h3>結果</h3>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/zorder_test_01.png" alt="" /></p>

<p>だめだー。
LinearLayout の Zorder は、並び順と連動してしまうので、右（若しくは下）ほど手前になってしまいます。</p>

<p>ちなみに、「<code>view.bringToFront()</code> を叩けばいいんじゃね？」と思い、<code>buttonA.bringToFront()</code> を実行すると、</p>

<p>じゃん↓</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/zorder_test_02.png" alt="" /></p>

<p>見事に AAA が右端にいったｗ</p>

<h2>RelativeLayout の場合（その１）</h2>

<p>普通に RelativeLayout で、「BはAの右、CはBの右」と制約をつけてみます。</p>

<p>```xml main.xml
&lt;RelativeLayout</p>

<pre><code>android:layout_width="match_parent"
android:layout_height="30dp"&gt;

&lt;Button
    android:id="@+id/buttonA"
    android:background="#FF0000"
    android:text="AAA"
    android:layout_width="50dp"
    android:layout_height="match_parent" /&gt;
&lt;Button
    android:id="@+id/buttonB"
    android:layout_toRightOf="@+id/buttonA"
    android:background="#00FF00"
    android:text="BBB"
    android:layout_marginLeft="-10dp"
    android:layout_width="50dp"
    android:layout_height="match_parent" /&gt;
&lt;Button
    android:id="@+id/buttonC"
    android:layout_toRightOf="@+id/buttonB"
    android:background="#0000FF"
    android:text="CCC"
    android:layout_marginLeft="-10dp"
    android:layout_width="50dp"
    android:layout_height="match_parent" /&gt;
</code></pre>

<p></RelativeLayout>
```</p>

<h3>結果</h3>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/zorder_test_03.png" alt="" /></p>

<p>んんー、まだダメかー。</p>

<h2>RelativeLayout の場合（その２）</h2>

<p>その１の制約はそのままに、XML上での並び順を C、B、A に変えてみましょう。</p>

<p>```xml main.xml
&lt;RelativeLayout</p>

<pre><code>android:layout_width="match_parent"
android:layout_height="30dp"&gt;

&lt;Button
    android:id="@+id/buttonC"
    android:layout_toRightOf="@+id/buttonB"
    android:background="#0000FF"
    android:text="CCC"
    android:layout_marginLeft="-10dp"
    android:layout_width="50dp"
    android:layout_height="match_parent" /&gt;
&lt;Button
    android:id="@+id/buttonB"
    android:layout_toRightOf="@+id/buttonA"
    android:background="#00FF00"
    android:text="BBB"
    android:layout_marginLeft="-10dp"
    android:layout_width="50dp"
    android:layout_height="match_parent" /&gt;
&lt;Button
    android:id="@+id/buttonA"
    android:background="#FF0000"
    android:text="AAA"
    android:layout_width="50dp"
    android:layout_height="match_parent" /&gt;
</code></pre>

<p></RelativeLayout>
```</p>

<h3>結果</h3>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/zorder_test_04.png" alt="" /></p>

<p>よしっ！期待した表示になりました。</p>

<h2>まとめ</h2>

<p>　総合しますと、ZOrder は、LinearLayout でも RelativeLayout でも、XMLでは後で記述したものが手前になります。</p>

<p>　LinearLayout は、上から下、または左から右に並べるしかできないので、それに逆らうような ZOrder は付けられません。</p>

<p> RelativeLayout は、制約に基づき描画されるので、XMLの記述順を工夫することで ZOrder をある程度コントロールできます。</p>

<p>以上、誰得Tips でした。</p>

<p>冒頭のようなパンくずリストをAndroidで作る方法教えてください。。。(FragmentBreadCrumbs もパンくずっぽくないじゃないですかぁ)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[秋の Xamarin 勉強会いろいろ]]></title>
    <link href="http://blog.amay077.net/blog/2014/09/16/xamarin-user-meetup-in-autum-2014/"/>
    <updated>2014-09-16T00:13:28+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/09/16/xamarin-user-meetup-in-autum-2014</id>
    <content type="html"><![CDATA[<p>　なんか今年(2014年)の秋は Xamarin についての勉強会がめじろ押しで、嬉しいというか羨ましい限りです。</p>

<p>　ざっとまとめて見ました。あ、ほぼ関東圏です。</p>

<!--more-->


<h2>【9/20・品川】<a href="https://atnd.org/events/55564">Xamarin.iOS でデバイスを超えるプログラミング : ATND</a></h2>

<p>　Xamarin.iOS の、特に Objective-C で作成されたライブラリを Xamarin.iOS で使う「Binding」についてのお話が聞けるのは大変希少です。</p>

<h2>【9/20・品川】<a href="http://kokucheese.com/event/index/215384/">9月20日 .NETラボ 勉強会 2014年9月(東京都)</a></h2>

<p>セッションの一つに</p>

<ul>
<li>「Xamarin.FormsのMVVM」のお話（Microsoft MVP for Visual C# 増田 智明）</li>
</ul>


<p>があります。Xamarin.Forms は iOS/Android/WinPhone でUIを共通化する新しいフレームワークで、且つ、MVVMフレームワークでもあります。これも大変価値のあるセッションです。</p>

<h2>【9/30・渋谷】<a href="http://connpass.com/event/8706/">「Xamarin」って何？ Wエバンジェリストによる特濃「Xamarin」勉強会 &ndash; connpass</a></h2>

<p>「Xamarinって何？」というタイトルの通り、Xamarin を知らない／興味のある方向けのセッションと思います。エクセルソフト田淵さんとMS渡辺さんは Xamarin について各所でプレゼンしまくってるので、これからXamarinを始めてみようという方にはピッタリだと思います。</p>

<h2>【10/18・渋谷】<a href="http://www.wankuma.com/seminar/20141018tokyo92/">Xamarin Day &ndash; わんくま同盟</a></h2>

<p>　わんくま同盟で、一日Xamarinぶち抜きしてくれるとは嬉しい限りですね。
勝手なイメージですが、わんくまはマイクロソフト系開発者が多いと思うので、Windows や Visual Studio での Xamarin 開発についてのセッションが多いのではないでしょうか。</p>

<h2>【10/6-10・アメリカ】<a href="https://evolve.xamarin.com/">Xamarin Evolve 2014</a></h2>

<p>　Xamarin 社主催の年に一度の大イベント「Evolve 2014」です。Apple でいうところの WWDC、Google で言えば I/O のような大きなイベントです。
Microsoft, IBM, Amazon, Salesforce とかなんだこの豪華なスポンサーは！
昨年は KeyNote がライブ配信されたので、今年もあるんじゃないかと思います。新しい Feature の発表もあるかもしれないので、必見です。日本のXamarin開発の第一人者 @iseebi さんも現地で参加されるとのことで、Live で盛り上がりましょう！</p>

<h2>【時期未定】第2回 Japan Xamarin User Group Conference</h2>

<p>日本唯一の Xamarin ユーザーコミュニティ JXUG の第2回コンファレンス、秋くらいに開催されるんじゃないかなーと、期待も込めて書かせて頂きました。</p>

<p>最新情報は <a href="https://www.facebook.com/groups/778386365523431/">Japan Xamarin User Group (JXUG)</a> に参加してチェックしましょう。</p>

<p>　すごい！１年前からは想像もできないくらいに Xamarin が盛り上がってきていて、ひたすら Qiita にネタを投稿してきた身としてはとても嬉しいです。地方在住者にはなかなか参加が厳しいですが、関東から次第に全国にコミュニティが広がっていってくれたらいいなと思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.Forms で複数ボタンの均等割り付けをする]]></title>
    <link href="http://blog.amay077.net/blog/2014/09/10/xamarin-forms-view-equal-width-and-fill-layouting/"/>
    <updated>2014-09-10T22:57:08+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/09/10/xamarin-forms-view-equal-width-and-fill-layouting</id>
    <content type="html"><![CDATA[<p>　Android では、例えば画面の幅に対して、複数のボタンを同じ幅でいい感じに Fill させることができます。(これを均等割り付けというのが正しいのかはよくわかりませんが)</p>

<!--more-->


<ul>
<li><a href="http://inujirushi123.blog.fc2.com/blog-entry-106.html">LinearLayout を使って均等割り付け : layout_weight &ndash; 戌印-INUJIRUSHI- （Androidあれこれ） &ndash;</a></li>
<li><a href="http://blog.imho.jp/2011/08/android-linearlayout.html">Androidレイアウトの要点だけ: LinearLayoutでパーツを均等に配置したい | スマートフォン要点だけブログ</a></li>
</ul>


<p>これで画面の解像度が違っても、横向きになっても、同じ幅のボタンで埋まる、という事ができます。</p>

<p><a href="http://xamarin.com/forms">Xamarin.Forms</a> でこれを実現するにはどうしたら良いか、試してみました。</p>

<h2>StackLayout を利用した試み</h2>

<p>Xamarin.Forms では、LinearLayout に相当するレイアウトとして <a href="http://iosapi.xamarin.com/?link=T%3aXamarin.Forms.StackLayout">StackLayout</a> があります。</p>

<p>まずはこれを利用してみます。</p>

<p><code>StackLayout</code> を <code>Orientation = Horizontal</code> とし、<code>Children</code> にボタンを3つ配置しています。ボタンの幅は全て <code>HorizontalOptions = FillAndExpand</code> とします。</p>

<p>```csharp App.cs
public class App
{</p>

<pre><code>public static Page GetMainPage()
{   
    return new ContentPage
    { 
        Content = new StackLayout
        {
            HorizontalOptions = LayoutOptions.FillAndExpand,
            VerticalOptions = LayoutOptions.Center,
            Orientation = StackOrientation.Horizontal,
            Children = 
            {
                new Button
                {
                    VerticalOptions = LayoutOptions.Center,
                    HorizontalOptions = LayoutOptions.FillAndExpand,
                    Text = "one",
                    TextColor = Color.Black,
                    BackgroundColor = Color.Aqua,
                },
                new Button
                {
                    VerticalOptions = LayoutOptions.Center,
                    HorizontalOptions = LayoutOptions.FillAndExpand,
                    Text = "two two",
                    TextColor = Color.Black,
                    BackgroundColor = Color.Fuschia,
                },   
                new Button
                {
                    VerticalOptions = LayoutOptions.Center,
                    HorizontalOptions = LayoutOptions.FillAndExpand,
                    Text = "three three three",
                    TextColor = Color.Black,
                    BackgroundColor = Color.Lime,
                },
            },
        },
    };
}
</code></pre>

<p>}
```</p>

<p>　これを iOS/Android 双方で実行すると、こうなりました。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/xamarin_forms_view_equal_width_and_fill_layouting_01.png" alt="" /></p>

<p>うーん、そうじゃない（汗
どうやらボタンのテキストが全て表示されるように頑張ってくれちゃうようです。
まあ、これはこれで使える感じもします。</p>

<h2>Grid を利用した試み</h2>

<p>他のレイアウトで考えてみます。Android の TableLayout に相当する <a href="http://iosapi.xamarin.com/?link=T%3aXamarin.Forms.Grid">Grid</a> を使ってみます。</p>

<p>さっきの <code>App.cs</code> の実装を次のように変えます。</p>

<p><code>Grid</code> に1行3列の表を定義します。
列の定義 <code>ColumnDefinition</code> で幅を <code>new GridLength(1, GridUnitType.Star)</code> としているのは、「3列とも同じ比率の幅とする」ことを意味しています。(ということは比率を2:1:1にしたければ、最初の列だけ<code>2</code>にすればOKです)</p>

<p>```csharp App.cs
public class App
{</p>

<pre><code>public static Page GetMainPage()
{   
    var grid = new Grid
    {
        HorizontalOptions = LayoutOptions.FillAndExpand,
        VerticalOptions = LayoutOptions.Center,
        RowDefinitions =
        {
            new RowDefinition() { Height = GridLength.Auto }
        },
        ColumnDefinitions = 
        {
            new ColumnDefinition() { Width = new GridLength(1, GridUnitType.Star) },
            new ColumnDefinition() { Width = new GridLength(1, GridUnitType.Star) },
            new ColumnDefinition() { Width = new GridLength(1, GridUnitType.Star) },
        }
    };

    grid.Children.Add(new Button
    {
        VerticalOptions = LayoutOptions.Center,
        HorizontalOptions = LayoutOptions.FillAndExpand,
        Text = "one",
        TextColor = Color.Black,
        BackgroundColor = Color.Aqua,
    }, 0, 0);

    grid.Children.Add(new Button
    {
        VerticalOptions = LayoutOptions.Center,
        HorizontalOptions = LayoutOptions.FillAndExpand,
        Text = "two two",
        TextColor = Color.Black,
        BackgroundColor = Color.Fuschia,
    }, 1, 0);

    grid.Children.Add(new Button
    {
        VerticalOptions = LayoutOptions.Center,
        HorizontalOptions = LayoutOptions.FillAndExpand,
        Text = "three three three",
        TextColor = Color.Black,
        BackgroundColor = Color.Lime,
    }, 2, 0);

    return new ContentPage
    { 
        Content = grid,
    };
}
</code></pre>

<p>}
```</p>

<p>　これを iOS/Android 双方で実行すると、こうなりました。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/xamarin_forms_view_equal_width_and_fill_layouting_02.png" alt="" /></p>

<p>　おーけー、意図したレイアウトになりました。ボタンに入りきらないテキストはiOSだと省略され、Androidだと折り返されるという違いはありますが、レイアウトの一貫性は保つことができました。</p>

<p>　ちなみに横向きにしても大丈夫です。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/xamarin_forms_view_equal_width_and_fill_layouting_03.png" alt="" /></p>

<h2>まとめ</h2>

<p>　Xamarin.Forms でも、Android+LinearLayoutのような均等配置ができました。
　クロスプラットフォームなので、iOSでも同じように動作します。
iPhone6 が発表されてiOS開発でも多解像度対応が必須になるので、これは有用な感じがします。
（というか Storyboard の AutoLayout では、これと同じことができる気がしないのですが。。。）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.Forms と ReactiveProperty で快適MVVM生活]]></title>
    <link href="http://blog.amay077.net/blog/2014/09/09/using-xamarin-forms-with-reactiveproperty/"/>
    <updated>2014-09-09T21:38:29+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/09/09/using-xamarin-forms-with-reactiveproperty</id>
    <content type="html"><![CDATA[<p>　<a href="http://www.buildinsider.net/mobile/xamarintips/0005">Xamarin.Forms</a> は、Xamarin に新たに搭載されたクロスプラットフォームUIフレームワーク＆MVVMフレームワークです。</p>

<!--more-->


<p>　<a href="http://okazuki.hatenablog.com/entry/2014/05/07/014133">ReactiveProperty</a> は、MVVMの(特に ViewModelの)実装を強力にサポートしてくれる、<a href="http://www.atmarkit.co.jp/fdotnet/introrx/index/">Reactive Extensions</a> を基盤としたライブラリです。</p>

<p> 両者を組み合わせると、Android/iOSアプリが COOL な感じで書けるんじゃないか、という事で試してみました。</p>

<h2>0. 環境など</h2>

<p>Mac + Xamarin Studio を使いますが、Windows + Visual Studio + Xamarin-Addin でもイケると思います。</p>

<h2>1. 導入</h2>

<h3>プロジェクトの作成</h3>

<p>新規ソリューションを、［C#］−［Mobile Apps］−［Blank App(Xamarin.Forms Portable)］で作成します。</p>

<h3>PCL の Profile を変更</h3>

<p>　作成されたソリューションの一番上にあるプロジェクト(.Android とか .iOS が付いていないやつ)のプロジェクト設定を開いて Profile を <strong>PCL 4.5 &ndash; Profile49</strong> に変更します。元々の Profile78 では ReactiveProperty が Nuget からインストールできないためです。最近のプラットフォームを対象にするなら、あまり影響はなさそうです。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/using_xamarin_forms_with_reactiveproperty_01.png" alt="" /></p>

<h3>Nuget で Reactive Extensions と ReactiveProperty を追加</h3>

<p>　メニューの［プロジェクト］ー［Add Packages］で Nuget のダイアログを開き、図のように 「Reactive Extensions &ndash; Main Library」と「ReactiveProperty Portable」を追加します。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/using_xamarin_forms_with_reactiveproperty_02.png" alt="" /></p>

<p>（Reactive Extensions の追加の際、なにやらWarningが出るようですが、とりあえず進めます。）</p>

<h2>2. ViewModel の実装</h2>

<p>　PCL のプロジェクトに、<code>FirstViewModel.cs</code> を作成します。
　<code>FirstViewModel</code> は、以下のようなプロパティとコマンドを持ちます。</p>

<ul>
<li>InputTextプロパティ : EditBox の入力に応じて更新</li>
<li>DisplayTextプロパティ : InputText の変化から1秒後に、InputText を大文字にして更新</li>
<li>Clearコマンド : InputText が &lsquo;clear&rsquo; の時のみ有効。実行すると InputText を空にする。</li>
</ul>


<p>これらの実装が下のようになります。</p>

<p>```csharp FirstViewModel.cs
using System;
using Codeplex.Reactive;
using System.Reactive.Linq;</p>

<p>namespace FormsWithRxProperty.ViewModels
{</p>

<pre><code>public class FirstViewModel
{
    private readonly ReactiveProperty&lt;string&gt; _inputText = 
        new ReactiveProperty&lt;string&gt;("Hoge");
    public ReactiveProperty&lt;string&gt; InputText 
    { 
        get { return _inputText; }
    }

    public ReactiveProperty&lt;string&gt; DisplayText
    {
        get; private set;
    }

    public ReactiveCommand Clear
    {
        get; private set;
    }

    public FirstViewModel()
    {
        // DisplayText は、InputText の変更から1秒後に大文字にして更新
        this.DisplayText = _inputText
            .Delay(TimeSpan.FromSeconds(1))
            .Select(x =&gt; x.ToUpper())
            .ToReactiveProperty();

        // InputText が `clear` の時に実装可能
        this.Clear = _inputText
            .Select(x =&gt; x.Equals("clear"))
            .ToReactiveCommand();
        // 実行されたら、InputText を空にする
        this.Clear.Subscribe(_ =&gt; _inputText.Value = String.Empty);
    }

}
</code></pre>

<p>}
```</p>

<p>　面倒な <code>INotifyPropertyChanged</code> の実装が必要なく、すっきりと記述できます。
　また、他のプロパティに関連して(反応して)値が変化するプロパティや、コマンドの利用可否などが、Reactive Extensions の機能により、流れるように記述できます。</p>

<h2>3. 画面及び ViewModel との Binding の実装</h2>

<p>　画面(UI)は、Xamarin.Forms の恩恵で、Android/iOS 共通で実装できます。XAML も使えますが、よく知らないのでコードでUIを記述します。</p>

<p>　PCL のプロジェクトに、 <code>FirstPage.cs</code> を作成し、以下のように実装します。</p>

<p>```csharp FirstPage.cs
using System;
using Xamarin.Forms;
using FormsWithRxProperty.ViewModels;</p>

<p>namespace FormsWithRxProperty.Pages
{</p>

<pre><code>public class FirstPage : ContentPage
{
    public FirstPage()
    {
        // UI
        var entry = new Entry
        {
            Text = "Hello, Forms!",
            VerticalOptions = LayoutOptions.Center,
            HorizontalOptions = LayoutOptions.FillAndExpand,
        };

        var label = new Label
        {
            VerticalOptions = LayoutOptions.Center,
            HorizontalOptions = LayoutOptions.CenterAndExpand,
        };

        var button = new Button
        {
            Text = "Clear (type 'clear' to enable)",
            VerticalOptions = LayoutOptions.Center,
            HorizontalOptions = LayoutOptions.FillAndExpand,
        };

        this.Content = new StackLayout
        {
            Padding = new Thickness(50f),
            VerticalOptions = LayoutOptions.Start,
            HorizontalOptions = LayoutOptions.Fill,
            Orientation = StackOrientation.Vertical,
            Children =
            {
                entry,
                label,
                button
            }
        };

        // ViewModel との Binding
        this.BindingContext = new FirstViewModel();
        entry.SetBinding&lt;FirstViewModel&gt;(Entry.TextProperty, vm=&gt;vm.InputText.Value);
        label.SetBinding&lt;FirstViewModel&gt;(Label.TextProperty, vm=&gt;vm.DisplayText.Value);
        button.SetBinding&lt;FirstViewModel&gt;(Button.CommandProperty, vm=&gt;vm.Clear);
    }
}
</code></pre>

<p>}
```</p>

<p>　ちょっと長いですが、画面に「エディットボックス」「ラベル」「ボタン」が縦に並んでいるだけです。</p>

<p>　下部の４行で、<code>FirstViewModel</code> の各プロパティ、コマンドと Bind しています。</p>

<p>　もともとあった <code>App.cs</code> は、<code>FirstPage</code> を生成するだけにします。</p>

<p>```csharp App.cs
using System;
using Xamarin.Forms;
using FormsWithRxProperty.Pages;</p>

<p>namespace FormsWithRxProperty
{</p>

<pre><code>public class App
{
    public static Page GetMainPage()
    {   
        return new FirstPage();
    }
}
</code></pre>

<p>}
```</p>

<h2>動かす！</h2>

<p> .Android か .iOS の付いたプロジェクトをスタートアップにして、実行します。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/using_xamarin_forms_with_reactiveproperty_03.gif" alt="" /></p>

<h3>追記 2014.9.10</h3>

<p>実機で動作確認するの忘れてました（実機はAOTなのに対してiOSシミュレータはJITなのでリフレクションとかが普通に動いてしまう）。
実機でも問題なく動作しました！</p>

<h2>追記 2014.9.11 INotifyPropertyChanged の利用</h2>

<p>ViewModel は <code>INotifyPropertyChanged</code> を実装して作成するのが一般的です。既にそのようにして作られた ViewModel でも <code>IObservable</code> 化して、ReactiveProperty で利用できます。</p>

<p>```csharp SecondViewModel.cs
public class SecondViewModel : INotifyPropertyChanged
{</p>

<pre><code>public ReactiveProperty&lt;string&gt; ValidationAttr { get; private set; }
public event PropertyChangedEventHandler PropertyChanged;

private string _myName = "HoGe";
public string MyName 
{
    get { return _myName; }
    set 
    { 
        if (_myName == value) return;

        _myName = value;
        PropertyChanged(this, new PropertyChangedEventArgs("MyName"));
    }
}

public ReactiveProperty&lt;string&gt; LowerText { get; private set; }

private ICommand _resetCommand;
public ICommand ResetCommand
{
    get
    {
        return _resetCommand ?? (_resetCommand = 
            new Xamarin.Forms.Command(() =&gt; MyName = "XAAAAMAAARIN!!"));
    }
}

public SecondViewModel()
{
    this.LowerText = this.ObserveProperty(x =&gt; x.MyName)
        .Select(x =&gt; x.ToLower())
        .ToReactiveProperty();
}
</code></pre>

<p>}
```</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/using_xamarin_forms_with_reactiveproperty_04.png" alt="" /></p>

<h2>まとめ</h2>

<p>　Reactive Extensions のメリットを活かして MVVM を構築できる ReactiveProperty と、ワンソースで Android/iOS の画面を定義でき、さらに Binding までも共通にできる Xamarin.Forms の組み合わせは、今後のモバイルアプリケーション開発をとても効率的にしてくれます、 <strong>そしてなにより楽しい！</strong></p>

<p>　今回のサンプルプログラムは</p>

<ul>
<li><a href="https://github.com/amay077/XamarinFormsWithReactivePropertySample/tree/master">amay077/XamarinFormsWithReactivePropertySample</a></li>
</ul>


<p>　に置きましたので、是非試してみてください。</p>

<h3>ReactiveProperty</h3>

<ul>
<li><a href="http://okazuki.hatenablog.com/entry/2014/05/07/014133">ReactiveProperty オーバービュー &ndash; かずきのBlog@hatena</a></li>
<li><a href="https://reactiveproperty.codeplex.com/releases/view/132232">ReactiveProperty &ndash; MVVM Extensions for Rx &ndash; Download: ReactiveProperty v1.0</a></li>
<li><a href="http://neue.cc/2011/08/26_341.html">neue cc &ndash; ReactiveProperty : Rx + MVVMへの試み</a></li>
<li><a href="http://yone64.wordpress.com/2014/06/20/reactiveproperty%E3%82%92%E4%BD%BF%E3%81%84%E3%81%9F%E3%81%84%E4%BA%BA%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%80%81reactiveextensions%E5%85%A5%E9%96%80%EF%BC%88%E3%81%9D%E3%81%AE%EF%BC%91%EF%BC%89/">ReactivePropertyを使いたい人のための、ReactiveExtensions入門（その１） | 泥庭</a></li>
</ul>


<h3>Xamarin.Forms</h3>

<ul>
<li><a href="http://developer.xamarin.com/guides/cross-platform/xamarin-forms/">Xamarin.Forms | Xamarin</a></li>
<li><a href="http://www.buildinsider.net/mobile/insidexamarin/14">Xamarin.Formsの基本構想と仕組み &ndash; Build Insider</a></li>
<li><a href="http://www.buildinsider.net/tagcloud?tag=Xamarin.Forms">Xamarin.Forms &ndash; Build Insider</a></li>
<li><a href="http://furuya02.hatenablog.com/entry/2014/08/08/003036">Xamarin.Forms ListViewでTwitter風のレイアウトを作成してみました（機種依存コードなし） &ndash; SIN@SAPPOROWORKSの覚書</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
