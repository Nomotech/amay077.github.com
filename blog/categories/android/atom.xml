<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Experiments Never Fail]]></title>
  <link href="http://amay077.github.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://amay077.github.com/"/>
  <updated>2013-02-19T18:19:59+09:00</updated>
  <id>http://amay077.github.com/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[HTC J で NETWORK_PROVIDER で位置測位した時の機種依存バグ？]]></title>
    <link href="http://amay077.github.com/blog/2013/02/19/htc-j-networkprovider-bug/"/>
    <updated>2013-02-19T00:41:00+09:00</updated>
    <id>http://amay077.github.com/blog/2013/02/19/htc-j-networkprovider-bug</id>
    <content type="html"><![CDATA[<p><a href="mixi%20Engineers'%20Blog%20http://alpha.mixi.co.jp/2013/11572/">Androidの機種依存問題を吸収するプロジェクトAndroid-Device-Compatibilityを公開したお話</a> を見て、あーそう言えばこんなんあったなーと思い出したのでメモ。</p>

<h2>症状</h2>

<p>下記条件を満たす時に、LocationManager.requestLocationUpdates すると、最新の位置が取得されず、<strong>前回測位した位置</strong> が返される。</p>

<p>時刻は更新されてたか、、、あーどうだったかな。</p>

<!-- more -->


<h2>条件</h2>

<ul>
<li>NETWORK_PROVIDER で位置を取得した場合（GPS じゃない）</li>
<li>WiFi が無効の場合（つまり携帯電話の基地局のみを使った測位の場合）</li>
<li>スリープ中な場合</li>
<li>HTC J である(IS03, Nexus S では発生してない。 HTC J Butterfly はわからない)</li>
</ul>


<h2>こんな事してたら見つけた</h2>

<p>早い話が HexRinger なんですが、このアプリは、AlarmManager で一定時間毎に WiFi/基地局から位置を取得しています。デバッグで移動中のログを取ってたら、「この時間帯、電車で寝てたのになんか位置変わってないんだけどｗ」となりました。</p>

<h2>対策</h2>

<p>WakeLock する。ただし PARTIAL_WAKE_LOCK だとダメで、画面も起こしてやらないとダメだった。
SCREEN あるいは FULL_WAKELOCK が必要な常駐アプリって、最悪やん。</p>

<h2>いろいろ試した事とか推測</h2>

<ul>
<li>測位前に通信させればいけるか？と思ったけどダメだった。</li>
<li>そもそも「最寄りの基地局情報」がスリープ状態だと更新されないんじゃないか説。</li>
</ul>


<p>設置場所が山奥過ぎてこの地雷を踏む人はそうはいないと思いますが、「HTC J だけど問題ないよ？」「Butterfly でもダメだったわー」とかの情報あったらコメントください。 m(<em> </em>)m</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android の jUnit テストで Context が欲しい時]]></title>
    <link href="http://amay077.github.com/blog/2013/01/19/gets-context-on-android-junit/"/>
    <updated>2013-01-19T00:44:00+09:00</updated>
    <id>http://amay077.github.com/blog/2013/01/19/gets-context-on-android-junit</id>
    <content type="html"><![CDATA[<p>Activity のテストなら <code>ActivityInstrumentationTestCase2</code> 、 Service なら <code>ServiceTestCase</code> を使うべきなんでしょうけど、Android って事あるごとに Context が必要なので、ただのクラスライブラリのテストでも必要なことがシバシバ。</p>

<!-- more -->


<p>``` java HogeTest.java
public class HogeTest extends InstrumentationTestCase {</p>

<pre><code>/** ApplicationContext を取得します */
private Context getApplicationContext() {
    return this.getInstrumentation().getTargetContext().getApplicationContext();
}
</code></pre>

<p>}
```</p>

<h2>参考</h2>

<ul>
<li>[androidの単体テスト(AndroidTestCase) - Androidのド肝] (http://blog.haw.co.jp/android/?p=471) - クラス図がとても役に立ちました</li>
<li><a href="http://stackoverflow.com/questions/5544205/accessing-application-context-from-testsuite-in-setup-before-calling-getactivi">android - Accessing application context from TestSuite in Setup() before calling getActivity() - Stack Overflow</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Maps Android API v2 で OpenStreetMap を表示する]]></title>
    <link href="http://amay077.github.com/blog/2012/12/26/osm-on-googlemapv2/"/>
    <updated>2012-12-26T00:18:00+09:00</updated>
    <id>http://amay077.github.com/blog/2012/12/26/osm-on-googlemapv2</id>
    <content type="html"><![CDATA[<p>この記事は <a href="http://atnd.org/events/34052">FOSS4G Advent Calendar 2012</a> の 12/26 の記事です。</p>

<p>ベクトル地図が扱える新しい Google Maps Android API v2 については、<a href="http://qiita.com/items/7ad0244c0fb4b431e090">Google Map Android API v2 の v1 からの変更点メモ</a> で書きました。</p>

<p>ここでは、v2 で新しく追加された <code>TileOverlay</code> を使って、OpenStreetMap を重ねてみます。</p>

<h2>UrlTileProvider を使って OpenStreetMap を表示する</h2>

<p>SDK に同梱されるサンプル /extras/google/google_play_services/samples/maps の TileOverlayDemoActivity.java を見れば一目瞭然なので、それをベースにします。</p>

<!-- more -->


<h3>サンプルのコード</h3>

<p>``` java TileOverlayDemoActivity.java
/<em>* This returns moon tiles. </em>/
private static final String MOON_MAP_URL_FORMAT =</p>

<pre><code>    "http://mw1.google.com/mw-planetary/lunar/lunarmaps_v1/clem_bw/%d/%d/%d.jpg";
</code></pre>

<p>private GoogleMap mMap;</p>

<p>private void setUpMap() {</p>

<pre><code>mMap.setMapType(GoogleMap.MAP_TYPE_NONE);

TileProvider tileProvider = new UrlTileProvider(256, 256) {
    @Override
    public synchronized URL getTileUrl(int x, int y, int zoom) {
        // The moon tile coordinate system is reversed.  This is not normal.
        int reversedY = (1 &lt;&lt; zoom) - y - 1;
       String s = String.format(Locale.US, MOON_MAP_URL_FORMAT, zoom, x, reversedY);
        URL url = null;
        try {
            url = new URL(s);
        } catch (MalformedURLException e) {
            throw new AssertionError(e);
        }
        return url;
    }
};
mMap.addTileOverlay(new TileOverlayOptions().tileProvider(tileProvider));
</code></pre>

<p>}
```
修正前のコードは、Google Moon のタイル画像を使用しています。</p>

<p>これを OpenStreetMap を使用するように改造します。</p>

<p>``` java OsmTileOverlayDemoActivity.java
/<em>* This returns moon tiles. </em>/
private static final String OSM_MAP_URL_FORMAT =</p>

<pre><code>    "http://tile.openstreetmap.org/%d/%d/%d.png";
</code></pre>

<p>private GoogleMap mMap;</p>

<p>private void setUpMap() {</p>

<pre><code>mMap.setMapType(GoogleMap.MAP_TYPE_NONE);

TileProvider tileProvider = new UrlTileProvider(256, 256) {
    @Override
    public synchronized URL getTileUrl(int x, int y, int zoom) {
        String s = String.format(Locale.US, OSM_MAP_URL_FORMAT, zoom, x, y);
        URL url = null;
        try {
            url = new URL(s);
        } catch (MalformedURLException e) {
            throw new AssertionError(e);
        }
        return url;
    }
};
mMap.addTileOverlay(new TileOverlayOptions().tileProvider(tileProvider));
</code></pre>

<p>}
```</p>

<p>できました。うーん、簡単すぎる。
URL は OpenStreetMap のものを使います。y軸の値は、Google Moon では逆順となっていたのを正順のまま使用するだけです。</p>

<p>こんな感じで表示できます。</p>

<p><img src="https://dl.dropbox.com/u/264530/qiita/advent2012_osm.png" alt="OpenStreetMap on Google Map API" /></p>

<p>移動、拡大・縮小だけでなく、API v2 の恩恵で、回転やチルトもできるのが嬉しいですね。</p>

<h2>TileOverlay を透過させる</h2>

<p>さて、ベース地図を Google から他のものに差し替えてしまうならこれまでの使い方で十分でしょう。しかし Google のベクトル3Dグリグリ地図をベース地図として使いたいとは誰しもが思うことでしょう。</p>

<p>ここでは、Google地図の上に TileOverlay を透過で表示することにチャレンジしてみます。
ケースとしては、雨雲レーダーのメッシュや、統計メッシュなどを重ね合わせる事が考えられます。</p>

<p>さて、API v2 のもう一つの新機能 GroundOverlay には <a href="https://developers.google.com/maps/documentation/android/reference/com/google/android/gms/maps/model/GroundOverlay#setTransparency(float">setTransparentcy</a> というズバリなメソッドがあり、それを使えば一発です。</p>

<p>しかし、TileOverlay とその関連クラスには、透過に関するメソッドは見当たりません。
そこで TileProvider でダウンロードされた画像データを直接弄って、透過にします。</p>

<p>TileProvider は文字通り <a href="https://developers.google.com/maps/documentation/android/reference/com/google/android/gms/maps/model/Tile">Tile</a> を Provide します。そしてこの Tile はタイル画像データそのものです。</p>

<p><a href="https://developers.google.com/maps/documentation/android/reference/com/google/android/gms/maps/model/Tile#data">Tile.data</a> の説明には次のように記述があります。</p>

<blockquote><p>A byte array containing the image data. The image will be created from this data by calling <a href="https://developers.google.com/maps/documentation/android/reference/com/google/android/gms/maps/model/null#decodeByteArray(byte[],%20int,%20int">decodeByteArray(byte[], int, int)</a>).</p></blockquote>

<p>つまりこのプロパティの中身を透過させてあげれば良さげ、という事になります。</p>

<p>上記のコードで使用した UrlTileProvider の <a href="https://developers.google.com/maps/documentation/android/reference/com/google/android/gms/maps/model/UrlTileProvider#getTile(int,%20int,%20int">getTile</a> を override して…と思ったら、
＿人人人人人人人人人＿
＞　突然の final！　＜
￣<sup>Y<sup>Y<sup>Y<sup>Y<sup>Y<sup>Y<sup>Y<sup>￣</sup></sup></sup></sup></sup></sup></sup></sup>
という事で override できません。</p>

<p>仕方ががないので、独自の TileProvider を別途用意して、UrlTileProvider を内包する形で <code>TransparencyUrlTileProvider</code> というクラスを実装します。</p>

<p>```java TransparencyUrlTileProvider.java
public class TransparencyUrlTileProvider implements TileProvider {</p>

<pre><code>private static final String OSM_MAP_URL_FORMAT = "http://tile.openstreetmap.org/%d/%d/%d.png";

private int _transparency; // 透過率(0〜255)
private UrlTileProvider _osmTileProv; // 内包する TileProvider

public TransparencyUrlTileProvider(int width, int height, int transparency) {
    _transparency = transparency;

    _osmTileProv = new UrlTileProvider(width, height) {
        @Override
        public URL getTileUrl(int x, int y, int zoom) {
            String s = String.format(Locale.US, OSM_MAP_URL_FORMAT, zoom, x, y);
            URL url = null;
            try {
                url = new URL(s);
            } catch (MalformedURLException e) {
                throw new AssertionError(e);
            }
            return url;
        }
    };
}

@Override
public Tile getTile(int x, int y, int zoom) {
    Tile tile = _osmTileProv.getTile(x, y, zoom);

    // TODO ここで Tile の透過処理を行う

    return tile;
}
</code></pre>

<p>}
```</p>

<p>使う側は、こんな感じになります。</p>

<p>``` java OsmTileOverlayDemoActivity.java
private GoogleMap mMap;</p>

<p>private void setUpMap() {</p>

<pre><code>// mMap.setMapType(GoogleMap.MAP_TYPE_NONE); ベース地図は消さない

mMap.addTileOverlay(
    new TileOverlayOptions()
    .tileProvider(
        new TransparencyUrlTileProvider(256, 256, 100)));
</code></pre>

<p>}
```</p>

<p>ここまでで改造前と同じく OpenStreetMap が「非透過で」表示されるのは確認できます。</p>

<p>次にいよいよ Bitmap の透過処理です。
まず、Tile から Bitmap を抜き出します。API リファレンスによると、<a href="https://developers.google.com/maps/documentation/android/reference/com/google/android/gms/maps/model/Tile#data">Tile.data</a> というメンバがあるハズが…見つかりません。代わりに <code>Tile.bM</code> という byte[] なメンバがあります。こいつで間違いないでしょう。</p>

<p>Tile.bM の byte[] から Bitmap インスタンスを生成します。</p>

<pre><code>Bitmap bitmap = BitmapFactory.decodeByteArray(tile.bM, 0, tile.bM.length);
</code></pre>

<p>次に透過処理ですが、Android ではちょっと面倒なようです。
以下のサイトを参考にさせて頂いて、関数を作成しました。</p>

<ul>
<li><a href="http://d.hatena.ne.jp/hypercrab/20110730/1312038162">Android: Bitmap の背景を透明にする - 入隠者通信 ～病を嗜む～</a></li>
</ul>


<p>```java makeTransparentBmp.java
private static Bitmap makeTransparentBmp(final Bitmap bmp, int transparency) {</p>

<pre><code> int width = bmp.getWidth(); 
 int height = bmp.getHeight(); 
 int[] pixels = new int[width * height]; 

 Bitmap bitmap = Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888 );
 bmp.getPixels(pixels, 0, width, 0, 0, width, height); 
 for (int y = 0; y &lt; height; y++) { 
   for (int x = 0; x &lt; width; x++) { 
     int pixel = pixels[x + y * width];
     pixels[x + y * width] = Color.argb(transparency, 
             Color.red(pixel), Color.green(pixel), Color.blue(pixel)); 
   } 
 } 
 bitmap.eraseColor(Color.argb(0, 0, 0, 0)); 
 bitmap.setPixels(pixels, 0, width, 0, 0, width, height); 

 return bitmap;
</code></pre>

<p>}
```</p>

<p>では TODO の所に組み込みます。</p>

<p>```java TransparencyUrlTileProvider.java
public class TransparencyUrlTileProvider implements TileProvider {</p>

<pre><code>&lt;前略&gt;

@Override
public Tile getTile(int x, int y, int zoom) {
    Tile tile = _osmTileProv.getTile(x, y, zoom);

    // Tile の透過処理を行う
   Bitmap bmp = BitmapFactory.decodeByteArray(tile.bM, 0, tile.bM.length);
   Bitmap transparentBmp = makeTransparentBmp(bmp, _transparency);

   // Tile を作り直す
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    transparentBmp.compress(CompressFormat.PNG, 100, bos);
    Tile tranparentTile = new Tile(tile.width, tile.height, bos.toByteArray());

    return tranparentTile;
}

&lt;以下略&gt;
</code></pre>

<p>}
```</p>

<p>動かしてみます。</p>

<p><img src="https://dl.dropbox.com/u/264530/qiita/advent2012_osmwithg.png" alt="OpenStreetMap with Google Map API" /></p>

<p>これは、GoogleMap の衛星写真の上に OpenStreetMap を透過して重ねた例です（分かりづらい</p>

<h2>まとめ</h2>

<p>このように Google Maps Android API v2 では、TileProvider を使って、タイル地図画像を簡単に表示させることができます。</p>

<p>Google Maps Javascript API や、MapKit でも他のタイル地図画像を利用することはできましたが、それらよりもより簡単に使えます。ハックというよりも API が公式にサポートしている、という感じです。</p>

<p>これまで Android には、Javascript の OpenLayers や、 iOS の route-me のような、地図タイルデータソースを扱える地図SDKはありませんでした（いや OsmDroid くらいか）</p>

<p>それを Google Maps Android API v2 がサポートしたのですから使わない手はありません。地図SDK としては一番高性能で事実上標準なのですから。</p>

<p>これに、OpenStreetMap や電子国土地図、衛星画像などの背景地図や、統計データメッシュや、アメダスなどの主題図的なタイル地図が重ねられるといろいろできそうだなあ、という感じです。
(Yahoo! さんの<a href="http://weather.yahoo.co.jp/weather/zoomradar/">雨雲レーダー</a> のタイル画像もこっそり試してみて「こりゃ面白い」と思ったので公式に提供して欲しいですｗ)</p>

<p>私にはタイル地図データを作る知識は無いので、タイル地図のポータルみたいなものがあるといいなあと思います。 <a href="https://www.facebook.com/chitaikyo">地図タイル工法協会</a> さんよろしくおねがいします。</p>

<p>というわけで、Android で地図使いたいなら(今のところ) Google Maps API v2 一択！ 他社さんもガンバレ！</p>

<p>※あれ？このネタどこが FOSS4G だ？ま、いっか。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android/EditTextでIMEの未確定文字列が確定された瞬間(のフォーク)]]></title>
    <link href="http://amay077.github.com/blog/2012/12/26/edittext-ontextchanged/"/>
    <updated>2012-12-26T00:00:00+09:00</updated>
    <id>http://amay077.github.com/blog/2012/12/26/edittext-ontextchanged</id>
    <content type="html"><![CDATA[<p>Android の EditText の文字列と、String 変数値を同期させたいケースって結構あると思うんですけど、<a href="http://developer.android.com/reference/android/view/View.OnFocusChangeListener.html">LostFocus</a> みたいなのでやると、オンフォーカスな状態で Activity が閉じられた時に LostFocus が呼ばれなくてあぼんとなるのは VB6あがりのプログラマ(=私)なら誰もが経験するんじゃないでしょうか？</p>

<!-- more -->


<p>じゃあ <a href="http://developer.android.com/reference/android/text/TextWatcher.html#onTextChanged(java.lang.CharSequence,%20int,%20int,%20int">onTextChanged</a> だぜ、って仕込んでみると、Android のこれは IME で変換中の文字列もバンバン飛んで来まして大変使い勝手が悪い。(サジェストなんかする際には必要なんでしょうけども)</p>

<p>例えば、以下で紹介されている方法</p>

<ul>
<li><a href="http://blog.global-eng.co.jp/android/2011/04/08/textwatcher%e3%81%a7edittext%e3%81%ae%e5%85%a5%e5%8a%9b%e5%86%85%e5%ae%b9%e3%82%92%e3%83%aa%e3%82%a2%e3%83%ab%e3%82%bf%e3%82%a4%e3%83%a0%e3%81%ab%e5%8f%8d%e6%98%a0%e3%81%99%e3%82%8b/">TextWatcherでEditTextの入力内容をリアルタイムに反映する | GE Android Blog</a></li>
</ul>


<p>を実装しますと、IME確定前の文字列もじゃんじゃん同期してくれちゃいます。</p>

<p>これに起因したであろう Android アプリもありまして(Instagram とか。今は治ってる。)、なんとかならんかなーと思っていました。</p>

<p>そんな時、こちら↓</p>

<ul>
<li><a href="http://www.spiritek.co.jp/spkblog/2012/10/25/androidedittext%e3%81%a7ime%e3%81%ae%e6%9c%aa%e7%a2%ba%e5%ae%9a%e6%96%87%e5%ad%97%e5%88%97%e3%81%8c%e7%a2%ba%e5%ae%9a%e3%81%95%e3%82%8c%e3%81%9f%e7%9e%ac%e9%96%93/">Android/EditTextでIMEの未確定文字列が確定された瞬間 | SpiriteK Blog</a></li>
</ul>


<p>の記事にめぐり逢いまして、まさに私が求めていたそのもの。</p>

<p>ですが、未確定文字＝下線付き(<code>UnderlineSpan</code>)である、という前提がどうにもしっくり来ませんで(未確定文字に下線を付けない IME もそりゃあるだろうなーという意味で)。</p>

<p>もちろん、その前で言及されている内部クラス <code>android.view.inputmethod.ComposingText</code> を文字列比較するのもうーん…。</p>

<p>で、自分でも試行錯誤してみたところ、<a href="http://developer.android.com/reference/android/text/Spanned.html#getSpanFlags(java.lang.Object">Spanned.getSpanFlags</a> というメソッドがあるのに気づきました。あと、<a href="http://developer.android.com/reference/android/text/Spanned.html#SPAN_COMPOSING">SPAN_COMPOSING</a> というフラグも。</p>

<p>これらを使って、文字列が確定されているかどうか？を識別することができるのではないかと考え、前出の記事のコードを以下のように修正してみました。</p>

<p>```java DetermineComposingText.java
edit1.addTextChangedListener(new TextWatcher()
{</p>

<pre><code>int currentLength = 0;

@Override
public void onTextChanged(CharSequence s, int start, int before, int count) {}

@Override
public void beforeTextChanged(CharSequence s, int start, int count, int after) {
    currentLength = s.toString().length();
}

@Override
public void afterTextChanged(Editable s) {
    Log.v("", "after:" + s.toString());
    if (s.toString().length() &lt; currentLength) {
        return;
    }
    boolean unfixed = false;
    Object[] spanned = s.getSpans(0, s.length(), Object.class);
    if (spanned != null) {
        for (Object obj : spanned) {
            // UnderlineSpan での判定から getSpanFlags への判定に変更。
            // if (obj instanceof android.text.style.UnderlineSpan) {
            if ((s.getSpanFlags(obj) &amp; Spanned.SPAN_COMPOSING) == Spanned.SPAN_COMPOSING) {
                unfixed = true;
            }
        }
    }
    if (!unfixed) {
        Toast toast = Toast.makeText(getApplicationContext(), "確定", Toast.LENGTH_SHORT);
        toast.show();
    }
}
</code></pre>

<p>});
```</p>

<p><code>s.getSpanFlags(obj) &amp; Spanned.SPAN_COMPOSING) == Spanned.SPAN_COMPOSING)</code> で SPAN_COMPOSING(未確定文字)のフラグが立っているかを判定しています。</p>

<p>とりあえず手持ちの ATOK では修正前と同じように動作しているようです。</p>

<p>IME 側で「未確定文字は SPAN_COMPOSING を必ず設定する」ものかどうかは分かりませんが、個人的には UnderlineSpan を使った手法よりもすっきりしました、というお話でした。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Maps Android API v2 の図形の描画順(zIndex)を探る]]></title>
    <link href="http://amay077.github.com/blog/2012/12/25/googlemap-v2-zindex/"/>
    <updated>2012-12-25T17:48:00+09:00</updated>
    <id>http://amay077.github.com/blog/2012/12/25/googlemap-v2-zindex</id>
    <content type="html"><![CDATA[<p>Google Maps Android API v1 では Overlay をレイヤのように使うことで図形群の前後関係をコントロールできましたが、v2 では <code>Polyline</code> や <code>Polygon</code> クラスに <code>zIndex</code> が導入されました。</p>

<p>いくつかの図形を重ねて描画し、zIndex が与える影響を調べてみました。</p>

<!-- more -->


<h2>zIndex なし の場合</h2>

<p>まず zIndex を指定しない場合。</p>

<ol>
<li>マーカー</li>
<li>線(太)</li>
<li>線(細)</li>
<li>ポリゴン(青)</li>
<li>ポリゴン(緑)</li>
</ol>


<p>の順で <code>GoogleMap</code> に追加しています。</p>

<p>```java NoZindex.java
final LatLng TOKYO = new LatLng(35.691, 139.693);
final LatLng NAGOYA = new LatLng(35.1805, 136.9073);
final LatLng TOYOHASHI = new LatLng(34.770, 137.391);
final LatLng MATSUMOTO = new LatLng(36.239, 137.969);
final LatLng SHIZUOKA = new LatLng(34.99, 138.39);
final LatLng MAEBASHI = new LatLng(36.38, 139.04);</p>

<p>// マーカー
mMap.addMarker(new MarkerOptions()</p>

<pre><code>.position(new LatLng(35.47, 138.71))
.title("富士山"));
</code></pre>

<p>// ライン
mMap.addPolyline(new PolylineOptions()</p>

<pre><code>.add(TOKYO, NAGOYA)
.width(40)
.color(Color.BLUE));
</code></pre>

<p>mMap.addPolyline(new PolylineOptions()</p>

<pre><code>.add(TOKYO, NAGOYA)
.width(10)
.color(Color.RED));
</code></pre>

<p>// ポリゴン
mMap.addPolygon(new PolygonOptions()</p>

<pre><code>.add(TOKYO, MATSUMOTO, TOYOHASHI)
.fillColor(Color.CYAN));
</code></pre>

<p>mMap.addPolygon(new PolygonOptions()</p>

<pre><code>.add(TOKYO, MAEBASHI, SHIZUOKA)
.fillColor(Color.GREEN));
</code></pre>

<p>```</p>

<p>結果、こうなりました。</p>

<p><img src="https://dl.dropbox.com/u/264530/qiita/zindex_off.png" alt="noZindex" /></p>

<p>前後関係を見ると、奥から</p>

<ol>
<li>ポリゴン(青)</li>
<li>ポリゴン(緑)</li>
<li>線(太)</li>
<li>線(細)</li>
<li>マーカー</li>
</ol>


<p>となりました。描画順＝追加した順、であれば、マーカーや線は、ポリゴンによって覆い隠されてしまうのですが、そうなりませんでした。
図形によって前後関係が決められていて、
奥から ポリゴン → ライン → マーカー となるようです。
ちなみに、zindex を指定しない時の既定値は <code>0</code> です。</p>

<h2>zIndex を設定してみる</h2>

<p>次に zIndex を次のように設定してみます。</p>

<p>```java WithZindex.java
// マーカー
mMap.addMarker(new MarkerOptions()</p>

<pre><code>.position(new LatLng(35.47, 138.71))
.title("富士山"));
</code></pre>

<p>// ライン
mMap.addPolyline(new PolylineOptions()</p>

<pre><code>.add(TOKYO, NAGOYA)
.width(40)
.color(Color.BLUE)
.zIndex(1));
</code></pre>

<p>mMap.addPolyline(new PolylineOptions()</p>

<pre><code>.add(TOKYO, NAGOYA)
.width(10)
.color(Color.RED)
.zIndex(2));
</code></pre>

<p>// ポリゴン
mMap.addPolygon(new PolygonOptions()</p>

<pre><code>.add(TOKYO, MATSUMOTO, TOYOHASHI)
.fillColor(Color.CYAN)
.zIndex(3));
</code></pre>

<p>mMap.addPolygon(new PolygonOptions()</p>

<pre><code>.add(TOKYO, MAEBASHI, SHIZUOKA)
.fillColor(Color.GREEN)
.zIndex(4));
</code></pre>

<p>```</p>

<p>結果は以下のとおり。</p>

<p><img src="https://dl.dropbox.com/u/264530/qiita/zindex_on.png" alt="noZindex" /></p>

<ol>
<li>線(太)</li>
<li>線(細)</li>
<li>ポリゴン(青)</li>
<li>ポリゴン(緑)</li>
<li>マーカー</li>
</ol>


<p>む、ライン、ポリゴンに関係なく、zIndex で指定した順に奥から描画されているようです。</p>

<h2>Developer Guide の説明</h2>

<p>いつも試してから見る公式ガイドｗ</p>

<ul>
<li><a href="https://developers.google.com/maps/documentation/android/lines#customize_a_polyline">Customize a Polyline - Google Maps Android API v2</a></li>
</ul>


<blockquote><p>Z-index
The stack order of this Polyline, relative to other overlays (polylines, polygons, ground overlays and tile overlays) in the map. A Polyline with a high z-index is drawn above overlays with lower z-indexes. Two overlays with the same z-index are drawn in an arbitrary order. Set this property with PolylineOptions.zIndex(). You can change this after the Polyline has been added to the map with the Polyline.setZIndex() method.</p></blockquote>

<p>まあ、それっぽいことが書いてあるわｗ
どうやら <code>GroundOverlay</code> や <code>TileOverlay</code> にも zIndex があり、前後関係をコントロールできるようですね。</p>

<h2>まとめ</h2>

<p>Google Maps Android API v2 の Polyline と Polygon の zIndex はまとめると次のようになります。</p>

<ul>
<li>指定しない(<code>0</code>)と、追加の順番に関わらず <strong><em>Polyline の方が Polygon よりも手前</em></strong> に描画される。Polyline 同士、Polygon 同士は、追加順に奥から描画される。</li>
<li>指定した場合、Polyline、Polygon の区別なく、<strong><em>zIndex の順で</em></strong> 奥から描画される。</li>
<li>マーカーは常に一番手前に描画される。</li>
</ul>


<p>ということで、zIndex をうまく設定すれば、図形群の前後関係を調整・変更することができます。</p>
]]></content>
  </entry>
  
</feed>
