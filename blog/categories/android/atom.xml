<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Experiments Never Fail]]></title>
  <link href="http://amay077.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://amay077.github.io/"/>
  <updated>2014-06-16T15:36:18+09:00</updated>
  <id>http://amay077.github.io/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Xamarin.Forms でどうにかしたい iOS と Android の違い]]></title>
    <link href="http://amay077.github.io/blog/2014/06/10/difference-ios-and-android-in-xamarin-forms/"/>
    <updated>2014-06-10T15:30:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/06/10/difference-ios-and-android-in-xamarin-forms</id>
    <content type="html"><![CDATA[<p>Xamarin.Forms で簡単な iOS/Android 両対応アプリを作ってみてて、悩ましい点がいくつか見つかってるので、挙げてみる。</p>

<!--more-->


<h2><del>不可視の扱い</del></h2>

<p><del>Forms 側のパーツには <code>IsVisible = true | false</code> がある。
iOS は <code>true | false</code> なのでいいけど、Android の Visibility は、 <code>Visible | Invisible | Gone</code> の3つある。</del></p>

<p><del>Forms 側での <code>IsVisible = false</code> は、Android では <code>Invisible</code> に相当するみたい。つまり StackLayout とかで「不可視なパーツが <strong>詰められない</strong>」。 iOS の <code>Visible = false</code> は <strong>詰められる</strong> 模様。</del></p>

<p><code>IsVisible = false</code> は Android ではちゃんと <code>Gone</code> になってました、すいませんでした。</p>

<h2>空文字の扱い</h2>

<p>IsVisible と勘違いしてたのはこっちだった。</p>

<p>StackLayout に、Label を2つ積んで、上の Label を空文字にすると、iOSでは詰められるけど、Androidでは空白が空くみたい。こっちはちゃんと裏をとった(汗)</p>

<p>https://gist.github.com/amay077/cf0f4ca1aa14d54bac9a</p>

<h2>画面回転時の再構築</h2>

<p>Android だと、画面を回転させると <code>onCreate</code> からやり直しなのは常識。
Forms アプリを Android で動かして回転させると、なんと <strong>RootPage まで戻って</strong> しまう。なんじゃこりゃ。</p>

<h2>回避方法</h2>

<blockquote class="twitter-tweet" lang="ja"><p><a href="https://twitter.com/amay077">@amay077</a> あとAndroidの回転問題（バグです）はとりあえず ConfigurationChanges = ConfigChanges.ScreenSize | ConfigChanges.Orientation で回避するといいそうです（そりゃそうだ…）</p>&mdash; Atsushi Eno (@atsushieno) <a href="https://twitter.com/atsushieno/statuses/476645011602165760">2014, 6月 11</a></blockquote>


<script async src="http://amay077.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>こんな感じっすね。</p>

<p>```csharp MainActivity.cs
[Activity(MainLauncher = true,</p>

<pre><code>ConfigurationChanges = ConfigChanges.ScreenSize | ConfigChanges.Orientation )]
</code></pre>

<p>public class MainActivity : AndroidActivity
{
```</p>

<h2>BACKキーの扱い</h2>

<p>iOS なら <code>NavigationPage.SetHasNavigationBar(page, false)</code> としてしまえば、ナビゲーションバーが表示されなくなるので、前の画面に戻ることはできなくなるが、Android の BACKキーを無効にするにはどうしたら。。。</p>

<h3>自己解決</h3>

<p><code>AndroidActivity</code> のサブクラスで、<code>OnBackPressed</code> を override して実装を潰してしまえばよい。けど画面毎に「戻る／戻れない／Confirm出す」とか細かい制御ができるのかは不明。</p>

<h2>デフォルトスタイル</h2>

<p>iOS は白基調、Androidは黒基調なので、Forms側で <code>TextColor = Color.Black</code> などとすると、当たり前だが Android で見えない。
iOS はスタイル変えるのしんどいので、Android側の Theme を <code>Theme.Holo.Light</code> にしとく。</p>

<p>```csharp MainActivity.cs
[Activity(Label = "MyApp",<br/>
 MainLauncher = true,
 Theme = "@android:style/Theme.Holo.Light")]
public class MainActivity : AndroidActivity
{</p>

<pre><code>protected override void OnCreate(Bundle bundle)
{
    /* 以下省略 */
</code></pre>

<p>```</p>

<h2>起動時</h2>

<p>Android 側の起動時に ActionBar の付いた空白画面が表示される時間が割とながくて気になる(Galaxy Nexus だけど)。Forms の画面をロードするのに時間がかかるのだろうか？
ActionBar だけでも消したくて Theme を <code>Theme.Holo.Light.NoActionBar</code> にしてみたら Page が表示されなくなった。。。</p>

<p>NoActionBar な Theme を使うと Activity.ActionBar が null になるんだけど、Xamarin.Forms がそれに対応してない気がした（スタックトレース見ると UpdateActionBar で NullReferenceException だし）ので、<a href="https://bugzilla.xamarin.com/buglist.cgi?product=Forms&amp;component=Forms&amp;resolution=---&amp;list_id=92025">Bugzilla</a> に登録してみた、初めて。どうなるやら。</p>

<h2>文字の自動縮小</h2>

<p>iOS の <code>UITextField</code> は <code>adjustsFontSizeToFitWidth</code> を設定するとパーツのサイズに合わせて文字サイズを自動拡縮してくれる機能があったけど、Forms の <code>Label</code> にはそんなものはありません。<code>PageRenderer</code> を使って iOS 独自処理しないとダメ。</p>

<h3>自己解決</h3>

<p>やはり PageRenderer 使うとできた → <a href="http://qiita.com/amay077/items/8eaa595cc2fc88797b2f">Xamarin.Forms の Label から iOS の UILabel を取り出す</a></p>

<h2>iPhone と iPad</h2>

<p>StackLayout や RelativeLayout でUIを書けば、相対的な位置関係は iPhone と同じものが iPad でも再現されるが、サイズをリテラルで指定するところは、特にインテグレーションしてくれるわけでないので、プラットフォーム毎に調整が必要。例えば文字サイズは、iPad では iPhone より大きな値にしないと残念な感じに。</p>

<p>他にも見つけたら書きます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intent に Enum を詰めて、取り出す]]></title>
    <link href="http://amay077.github.io/blog/2014/04/23/put-and-get-enum-from-intent/"/>
    <updated>2014-04-23T15:22:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/04/23/put-and-get-enum-from-intent</id>
    <content type="html"><![CDATA[<p>タイトルの通りです。</p>

<!--more-->


<p>```java enum
public enum MyTypes {</p>

<pre><code>One,
Two,
Three
</code></pre>

<p>}
```</p>

<p><code>java put
intent.putExtra("hoge",MyType.Two);
</code></p>

<p><code>java get
MyTypes t = (MyTypes)intent.getSerializableExtra("hoge");
</code></p>

<p>取り出すのは <code>getSerializableExtra</code> であることに注意。</p>

<p>なんか int に変換されそうじゃん、と思って <code>getIntExtra</code> を使うと取り出せない。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.Android で Intent を受けとるには？]]></title>
    <link href="http://amay077.github.io/blog/2014/04/01/receive-intent-by-xamarin-android/"/>
    <updated>2014-04-01T15:26:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/04/01/receive-intent-by-xamarin-android</id>
    <content type="html"><![CDATA[<p>例えば、他のアプリからテキストを「送る」して、自作の Xamarin アプリでそれを受け取りたい時。</p>

<!--more-->


<p>普通の Android アプリ開発だと <code>AndroidManifest.xml</code> にこう書く。</p>

<p>```xml AndroidManifest.xml
<activity
  android:name="com.example.intenttest.MainActivity"
  android:label="@string/app_name" >
  <intent-filter></p>

<pre><code>&lt;action android:name="android.intent.action.MAIN" /&gt;
  &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
</code></pre>

<p>  </intent-filter></p>

<p>  <intent-filter></p>

<pre><code>&lt;action android:name="android.intent.action.SEND" /&gt;
&lt;category android:name="android.intent.category.DEFAULT" /&gt;
&lt;data android:mimeType="text/plain" /&gt;
</code></pre>

<p>  </intent-filter>
</activity>
```</p>

<p>Xamarin.Android では、Activity のソースファイルの属性として、以下のように書く。</p>

<p>```csharp MainActivity.cs
[Activity(Label = "MainActivity", MainLauncher = true)]
[IntentFilter (new []{ Intent.ActionSend },
  Categories = new []{ Intent.CategoryDefault },
  DataMimeType = "text/plain" )]
public class MainActivity : Activity
{</p>

<pre><code>protected override void OnCreate(Bundle bundle)
{
    base.OnCreate(bundle);
</code></pre>

<p>```</p>

<p>テキストでない場合は、mimetype を適宜変更する。省略したら動作しなかった。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Activity がメモリリークしにくくなってる件]]></title>
    <link href="http://amay077.github.io/blog/2014/03/19/android-memory-leaks-improvements/"/>
    <updated>2014-03-19T15:12:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/03/19/android-memory-leaks-improvements</id>
    <content type="html"><![CDATA[<p>2009年の情報なんですけどね。</p>

<!--more-->


<ul>
<li><a href="http://android-developers.blogspot.jp/2009/01/avoiding-memory-leaks.html">Avoiding memory leaks | Android Developers Blog</a></li>
<li><a href="http://d.hatena.ne.jp/androidzaurus/20090121/1232519066">Avoiding memory leaks （超訳） - Android Zaurusの日記</a></li>
<li><a href="http://tomokey.blogspot.jp/2011/05/android.html">暇なメモ帳: Androidのソースコードレビュー(メモリリーク)</a></li>
</ul>


<p>Android でメモリリークする典型的なパターンとして上で紹介されているものがあって、日頃はこうならないように気をつけて実装をしているわけです。</p>

<p>また、メモリリークの調査方法もたくさん情報があります。</p>

<ul>
<li><a href="http://rainbowdevil.jp/?p=1187">Androidでメモリリークの調査と、そのヒープダンプから画像を抽出する » RainbowDevilsLand</a></li>
<li><a href="http://tlync.hateblo.jp/entry/20111220/1324372308">富豪的 Android プログラマの為の Eclipse Memory Analyzer Tool 入門 - sandbox</a></li>
</ul>


<p>日頃、Xamarin.Android を触っているので、「Xamarin でも同じようにリークするよね」と思いやってみたところ全然リークしなかったので、もしや Android-Java でもリークしないんじゃ？と考え、試してみたのが以下の内容です。</p>

<h2>試した</h2>

<p>以下の2つのパターンについて試しました</p>

<ol>
<li>Avoiding memory leaks の 2番目の例。Activity への強参照を持った Drawable を static なメンバにキープしちゃう件。画面が回転した時に、Activity がリークしてしまう、とされる。</li>
<li>暇なメモ帳さんの「問題3」＋α。非static な Inner クラスが Activity の強参照を持ってる、且つ、このオブジェクトを Activity の static メンバにしちゃう。</li>
</ol>


<h2>結論</h2>

<p>から言うと、</p>

<p><strong>1. はリークせず、2. はリークしました。</strong></p>

<p>あれれ？</p>

<h2>パターン1のテストコード</h2>

<p>ほぼ元コードのコピペだけど、クラスが破棄された(<code>finalize</code>)時にログ吐くようにしています。</p>

<p>```java
public class MainActivity extends Activity {</p>

<pre><code>private static final String TAG = "MainActivity";
private static Drawable sBackground;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    Log.d(TAG, "onCreate:" + this.hashCode());

    Button button = new Button(this);
    button.setText("Leaks are bad");

    if (sBackground == null) {
        sBackground = getResources().getDrawable(R.drawable.ic_launcher);
    }
    button.setBackgroundDrawable(sBackground);
    setContentView(button);
}

@Override
protected void onDestroy() {
    Log.d(TAG, "onDestroy:" + this.hashCode());
    super.onDestroy();
}

@Override
protected void finalize() throws Throwable {
    Log.d(TAG, "finalize:" + this.hashCode());
    super.finalize();
}
</code></pre>

<p>}
```</p>

<h3>確認手順</h3>

<ol>
<li>このアプリを実行。Android2.3 のエミュレータ(4.0 の実機でも試した)。</li>
<li>画面を回転させる（Ctrl+F11）</li>
<li>DDMS から GC を走らせる</li>
<li>LogCat を収集</li>
</ol>


<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/improve_activity_leaks_02.png" alt="" />
<img src="https://dl.dropboxusercontent.com/u/264530/qiita/improve_activity_leaks_03.png" alt="" /></p>

<p>Logcat の出力結果はこう。</p>

<p><code>
03-19 21:28:09.539: D/MainActivity(382): onCreate:1079076320
03-19 21:29:15.979: D/MainActivity(382): onDestroy:1079076320
03-19 21:29:15.989: D/MainActivity(382): onCreate:1079106528 ←横画面のActivity
03-19 21:29:33.939: D/MainActivity(382): finalize:1079076320
</code></p>

<p>ちゃんと GC を走らせた後、 Activity の <code>finalize</code> が呼ばれています。
MAT でも確認したけど、リークは発見できませんでした。</p>

<h2>パターン2のテストコード</h2>

<p>こんな実装は早々お目にかからないと思うけど、非static な Inner クラスのインスタンスを、Activity の static メンバにしちゃうぞ、と。</p>

<p>```java
public class MainActivity extends Activity {</p>

<pre><code>private static final String TAG = "MainActivity";
private static SomeInnerClass innerClass;

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    Log.d(TAG, "onCreate");

    if (innerClass == null) {
        innerClass = new SomeInnerClass();
    }
}

@Override
protected void onDestroy() {
    Log.d(TAG, "onDestroy");
    super.onDestroy();
}

@Override
protected void finalize() throws Throwable {
    Log.d(TAG, "finalize");
    super.finalize();
}

class SomeInnerClass {
    public void doSomething() { }
}
</code></pre>

<p>}
```</p>

<h3>確認手順</h3>

<p>パターン1と同じです。</p>

<p>Logcat の出力結果はこちら。</p>

<p><code>
03-19 21:42:55.289: D/MainActivity(476): onCreate
03-19 21:43:05.369: D/MainActivity(476): onDestroy
03-19 21:43:05.549: D/MainActivity(476): onCreate
</code></p>

<p>ご覧のとおり、<code>finalize</code> が呼ばれない、つまり Activity がリークしています。</p>

<h2>考察っぽいの</h2>

<p>パターン2 がリークするのは当然と言えます。
Activity への強参照を持ったオブジェクトを、static フィールドで保持し続けてしまうので、Activity が破棄されない。</p>

<p>パターン1 も同じ理屈だと思うのですが（少なくとも冒頭の記事の説明ではそう）。これがリークしないのは、Android SDK が改善された(例えば、今まで Activity の強参照を持ってたのが弱参照に変わった)とか、Dalvik の GC が改善されたとかでしょうか？</p>

<p>まあ4年も経てば常識も変わるということで、Activity に関しては以前ほど神経質にならなくてもいいかもしれませんが、メモリリークの可能性が消えることは有り得ないので、このアンチパターンはこれからも遵守していかないといけませんね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin によるクロスプラットフォームモバイルアプリ開発、資料と補足]]></title>
    <link href="http://amay077.github.io/blog/2014/02/27/slides-from-my-xamarin-introduction/"/>
    <updated>2014-02-27T21:40:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/02/27/slides-from-my-xamarin-introduction</id>
    <content type="html"><![CDATA[<p>2/26 の <a href="http://atnd.org/events/47898">うずらインキュベータ</a> という勉強会で、Xamarin の話をしました。</p>

<!--more-->




<iframe src="http://www.slideshare.net/slideshow/embed_code/31674661" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px 1px 0; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>


<p> <div style="margin-bottom:5px"> <strong> <a href="https://www.slideshare.net/amay077/xamarin-31674661" title="Xamarin によるクロスプラットフォームモバイルアプリ開発" target="_blank">Xamarin によるクロスプラットフォームモバイルアプリ開発</a> </strong> from <strong><a href="http://www.slideshare.net/amay077" target="_blank">amay 077</a></strong> </div></p>

<p>45分という長い時間話すのは勉強会では初めてだったのですが、なんとか説明し切ることができました。（ちょっとデモが中途半端になってしまいましたが）</p>

<p>資料は <a href="http://qiita.com/tags/xamarin">Qiita に書いてきた</a> 内容のまとめみたいなものですが、少し補足します。</p>

<h2>Xamarin で作った経験あるの？</h2>

<p>仕事では、まだ無いです（<sup>_<sup>;）</sup></sup>
個人アプリでは「<a href="https://itunes.apple.com/us/app/fu-shifoto/id806913229">富士フォト</a>」というのを iOS 用は Xamarin.iOS で作りました。<a href="https://play.google.com/store/apps/details?id=com.amay077.android.fujiphoto">Android</a> は Java ですが Xamarin 化したいな。</p>

<h2>Win+Visual Studio ではダメなの？</h2>

<p>個人の見解ですから（<sup>_<sup>;）</sup></sup>
私も元々は Windowsの開発がメインで Visual Studio の強力さは知っていますが、iOS やるならどういう形にせよ Mac+Xcode を扱わないといけないので、慣れておいた方がよいかなと。</p>

<p>また、Microsoft との提携以降、Microsoft のエバンジェリストさんや MVP の方々が Visual Studio + Xamarin の話をものすごく展開されているので、そちらにお任せした次第です。</p>

<h2>実行モデルのとこ</h2>

<p>JavaSE が .NET に置き換わる図になっていますが、実際には少し違っていて、JavaSE のラッパもあります。例えば文字列型には、<code>System.String</code> と <code>Java.Lang.String</code> があります。当然、理由がなければ前者を使った方がよいわけですが。</p>

<p>iOS のスタックに関しては、実はどこからどこまでが「CocoaTouch」なのかよく分かってません。</p>

<h2>他のクロスプラットフォーム開発ツールとの比較</h2>

<p>Titanium, AIR については2年くらい前に少し触ったことがあります。PhoneGap と DelphiXE についてはスペックを見て＆詳しい方からの情報を元にしてます。</p>

<p>Titanium は次期 <a href="http://titanium-mobile.jp/38">Ti.Next</a> では JavaScriptCore を使ってすんごく速くなるそうですし、AIR も当時よりだいぶ <a href="http://www.slideshare.net/pik256/dev-sumi2014-13c4rev">高速になったらしい</a> です。</p>

<h2>C# のとこ</h2>

<p>https://xamarin.com/csharp よりは悪意のないコードかとｗ
（Objective-C と比較しようとすると Obj-C の方が画面に入らないので Java との比較にしました。）</p>

<p>こんなところで。
何かおかしなところがあったらコメント頂けるとありがたいです。</p>
]]></content>
  </entry>
  
</feed>
