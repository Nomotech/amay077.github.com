<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Experiments Never Fail]]></title>
  <link href="http://amay077.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://amay077.github.io/"/>
  <updated>2013-10-23T01:55:04+09:00</updated>
  <id>http://amay077.github.io/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[フラットな感じのボタンを作ってみた]]></title>
    <link href="http://amay077.github.io/blog/2013/10/23/android-flat-button-sample/"/>
    <updated>2013-10-23T01:53:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/10/23/android-flat-button-sample</id>
    <content type="html"><![CDATA[<p>Foursquare の Android 版をマネて、XML だけで作ってみた。
仕組みをすぐ忘れるので、ここにメモしておく。</p>

<!--more-->


<p>```xml flat_panel.xml
&lt;?xml version="1.0" encoding="utf-8"?>
<layer-list xmlns:android="http://schemas.android.com/apk/res/android" ></p>

<pre><code>&lt;item android:id="@+id/padding"&gt;
    &lt;shape&gt;
        &lt;solid android:color="#00FFFFFF" /&gt;
        &lt;padding android:bottom="8dp" android:left="8dp"
            android:right="8dp" android:top="8dp" /&gt;
    &lt;/shape&gt;
&lt;/item&gt;
&lt;item android:id="@+id/shadow"&gt;
    &lt;shape&gt;
        &lt;solid android:color="#D3CEC7" /&gt;
        &lt;padding android:bottom="2px" /&gt;
    &lt;/shape&gt;
&lt;/item&gt;
&lt;item android:id="@+id/face"&gt;
    &lt;shape&gt;
        &lt;stroke android:width="1px" android:color="#AEA8A3" /&gt;
        &lt;solid android:color="#FFFFFF" /&gt;
    &lt;/shape&gt;
&lt;/item&gt;
&lt;item android:id="@+id/state"&gt;
    &lt;selector&gt;
        &lt;item android:state_pressed="true"&gt;
            &lt;shape android:shape="rectangle"&gt;
                &lt;solid android:color="#FF82DEFF" /&gt;
            &lt;/shape&gt;
        &lt;/item&gt;
        &lt;item android:state_focused="true"&gt;
            &lt;shape android:shape="rectangle" &gt;
                &lt;solid android:color="#4082DEFF" /&gt;
            &lt;/shape&gt;
        &lt;/item&gt;
      &lt;/selector&gt;
&lt;/item&gt;
&lt;item android:id="@+id/child"&gt;
    &lt;shape&gt;
        &lt;solid android:color="#00FFFFFF" /&gt;
        &lt;padding android:bottom="8dp" android:left="8dp"
            android:right="8dp" android:top="8dp" /&gt;
    &lt;/shape&gt;
&lt;/item&gt;
</code></pre>

<p></layer-list>
```</p>

<h2>使い方</h2>

<p>上のファイル <code>flat_panel.xml</code> を、<code>res/drawable</code> ディレクトリに入れて、適用したい Button などに↓のように設定。</p>

<p>```xml part_of_activity_main.xml</p>

<pre><code>&lt;Button
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="@drawable/flat_panel"
    android:text="フラットなボタン" /&gt;
</code></pre>

<p>```</p>

<p>Theme とかにまとめたいけど、今日は割愛。</p>

<h2>ボタンに適用した結果</h2>

<h3>通常</h3>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/android_flat_button_sample_01.png" alt="img1" /></p>

<h3>押した時</h3>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/android_flat_button_sample_02.png" alt="img1" /></p>

<h2>仕組み</h2>

<p><code>&lt;layer-list&gt;</code> タグの中の要素は、上から順に描画される。また、下位(手前)の要素は、上位(奥)の要素の入れ子になるみたい。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/android_flat_button_sample_03.png" alt="img1" /></p>

<p>（図の id は flat_panel.xml と対応してます。）</p>

<ol>
<li>padding - ボタンの周りに少し余白を付ける役割（要らないなら消してもOK）</li>
<li>shadow - ボタンの下部にちょっとだけ見えてる影の部分。大部分が face によって隠れてるけど、実際はほとんど同じ領域を持つ。ここで padding bottom を 2px としているので、face の高さが 2px 縮んで、影っぽく見える仕組み。つまり影の強さはここで調整。</li>
<li>face - ボタンの「面」に該当。stroke でフチを、solid で面を塗りつぶしている。</li>
<li>state - ボタンの状態によって色などを変える役割。ここでは state_pressed=true（押された状態）と、state_focused=true（フォーカスを持ってる状態）だけ対応してる。face を描画した「後」で評価されるので、face の色を置き換えるものではない事に注意（透過時）。あと、状態は上から評価される。</li>
<li>child - LinearLayout など Group な View にこのスタイルを適用した時、子View への余白となる。</li>
</ol>


<p>みんなの大好きな方眼紙EXCEL とオートシェイプで再現してみた → <a href="https://dl.dropboxusercontent.com/u/264530/qiita/flat_panel.xlsx">DL</a></p>

<p>Activity の背景が白だと、あんまり映えない。。。</p>

<p>色の定義を、別の xml に分けて、アプリ毎に変えれば、それっぽくなるのかなーと。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[爆速エミュレータで Google Maps Android API v2 を動かす]]></title>
    <link href="http://amay077.github.io/blog/2013/10/20/using-gmapv2-on-intel-emulator/"/>
    <updated>2013-10-20T21:58:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/10/20/using-gmapv2-on-intel-emulator</id>
    <content type="html"><![CDATA[<p>Google APIs のエミュレータで Google Map Android API v2 が動くようになったのですが、やっぱり遅い、使えん。
という訳で、Intel の爆速エミュレータで GMapV2 を使う手順の備忘録です。(ご利用は自己責任で)</p>

<!--more-->


<h2>爆速エミュレータの導入</h2>

<p>こちら等を参考にセットアップします。</p>

<ul>
<li><a href="http://qiita.com/gabu/items/8bc1a11f1382409f1d2a">Android再入門 - エミュレータの作成</a></li>
</ul>


<h2>エミュレータで Google Maps Android API v2 を動かす</h2>

<p><code>com.google.android.gms.apk</code> と <code>com.android.vending.apk</code> が必要なのでどうにかして入手しインストールします。(ほとんど答えだけど下記参照)</p>

<ul>
<li><a href="http://stackoverflow.com/questions/14040185/running-google-maps-v2-on-android-emulator">Running Google Maps v2 on Android Emulator - Stack Overflow</a></li>
</ul>


<p>apk が古いとうまく動作しません。なるべく新しいものを探しましょう。(ﾎﾞｿ</p>

<h2>AndroidManifest.xml から com.google.android.maps の定義を消す</h2>

<p>意外とハマったのがコレ。</p>

<p><code>AndroidManifest.xml</code> で</p>

<p><code>
&lt;uses-library android:name="com.google.android.maps" /&gt;
</code></p>

<p>が定義してあると、</p>

<p><code>
10-20 11:35:52.977: E/PackageManager(1178): Package xxxx requires unavailable shared library com.google.android.maps; failing!
</code></p>

<p>というエラーになります。</p>

<p>この <code>com.google.android.maps</code> は Google Maps API v1 で必要だったもので、v2 では必要ありません。削除しましょう。</p>

<p>v2 の使い方を説明するブログやサイトで、これが含まれてしまってるものがあるようです。(かくいう自分もそんなサイトからコピペしてきたまま使ってたのでエラーになりました（汗）</p>

<h2>動かす</h2>

<p>あとは、実機と変わりません。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/using_gmapv2_on_intel_emulator_01.png" alt="img" /></p>

<p>やばい、PC性能とネットワーク環境のおかげで実機より快適になったｗ</p>

<h2>参考</h2>

<ul>
<li><a href="http://d.hatena.ne.jp/ria10/20121218/1355794748">AndroidでGoogle Maps v2 をエミュレータで動かしてしかも爆速 - リア充爆発日記</a></li>
<li><a href="http://denshikousaku.net/how-to-make-android-google-maps-v2-work-in-android-emulator">エミュレータでGoogle Maps for Android V2を動かす方法 | アプリ開発とRaspberry PIとArduino実験</a></li>
<li><a href="http://stackoverflow.com/questions/14040185/running-google-maps-v2-on-android-emulator">Running Google Maps v2 on Android Emulator - Stack Overflow</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TextView で、テキストの一部だけクリック可能にする]]></title>
    <link href="http://amay077.github.io/blog/2013/10/17/make-clickable-from-part-of-text/"/>
    <updated>2013-10-17T21:16:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/10/17/make-clickable-from-part-of-text</id>
    <content type="html"><![CDATA[<p>Android の TextView で、「テキストの一部を押すとなんかのアクションが起こる」というのが <code>ClickableSpan</code> というのを使えばできそうだったので、やってみました。</p>

<!--more-->


<p>```java ClikcableSpanTestActivity.java
public class ClikcableSpanTestActivity extends Activity {</p>

<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    final List&lt;Pair&lt;String, String&gt;&gt; data = new ArrayList&lt;Pair&lt;String,String&gt;&gt;();
    data.add(new Pair&lt;String, String&gt;("りんご", "隠し味としてカレーに入れます"));
    data.add(new Pair&lt;String, String&gt;("みかん", "あぶりだしに使います"));
    data.add(new Pair&lt;String, String&gt;("すいか", "種を食べると盲腸になります（嘘）"));

    final SpannableStringBuilder sb = new SpannableStringBuilder();
    final String SEP = ", ";
    int spanStart = 0;

    for (final Pair&lt;String, String&gt; p : data) {
        sb.append(p.first);
        sb.append(SEP);

        // 追加した文字列を Span にする
        sb.setSpan(new ClickableSpan() {
            @Override
            public void onClick(View widget) {
                Toast.makeText(getApplicationContext(), 
                    p.second, Toast.LENGTH_SHORT).show();
            }
        }, spanStart, spanStart + p.first.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);

        spanStart += (p.first.length() + SEP.length());
    }

    TextView tv = (TextView)findViewById(R.id.text);
    tv.setText(sb);
    tv.setMovementMethod(LinkMovementMethod.getInstance()); // これ忘れるとクリックできなくて小一時間悩む
}
</code></pre>

<p>}
```</p>

<p>項目をカンマつなぎで表示して、項目のところだけリンクっぽくします。
リンクをクリックすると Toast を表示します。（下図のように）
また <code>URLSpan</code> というクラスもあり、クリックすると指定したURLに移動（ブラウザアプリが起動）します。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/using_clickablespan_01.png" alt="" /></p>

<h2>参考</h2>

<p>装飾したり位置やサイズ変えたり、TextView でもいろいろできるんですねー。
(VB6の)Label とは違うのだよ、Label とは！</p>

<ul>
<li><a href="http://y-anz-m.blogspot.com/2011/08/androidspannable.html">Y.A.M の 雑記帳: Android Spannable を使って文字列の一部を装飾する</a></li>
<li><a href="http://d.hatena.ne.jp/androidprogram/20100529/1275086958">Tips TextView を使いこなそう ～表示編～ その4 - - Google Android - 雑記帳</a></li>
<li><a href="http://developer.android.com/reference/android/text/style/package-summary.html">android.text.style | Android Developers</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[metersToEquatorPixels を Google Maps Android API v2 で]]></title>
    <link href="http://amay077.github.io/blog/2013/10/09/meterstoequatorpixels-in-gmap-v2/"/>
    <updated>2013-10-09T00:21:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/10/09/meterstoequatorpixels-in-gmap-v2</id>
    <content type="html"><![CDATA[<p>Google Map API v1 には、「地図上の距離(ｍ)を画面上の距離(ピクセル)に変換する」ためのメソッド <a href="https://developers.google.com/maps/documentation/android/v1/reference/com/google/android/maps/Projection#metersToEquatorPixels(float">Projection.metersToEquatorPixels</a>) がありましたが、v2 ではなくなってしまいました。</p>

<!--more-->


<p>ので、以下のような代替関数を作ってみました。</p>

<p>```java metersToEquatorPixels.java
public static int metersToEquatorPixels(GoogleMap map, LatLng base, float meters) {</p>

<pre><code>final double OFFSET_LON = 0.5d;

Location baseLoc = new Location("");
baseLoc.setLatitude(base.latitude);
baseLoc.setLongitude(base.longitude);

Location dest = new Location("");
dest.setLatitude(base.latitude);
dest.setLongitude(base.longitude + OFFSET_LON);

double degPerMeter = OFFSET_LON / baseLoc.distanceTo(dest); // 1m は何度？
double lonDistance = meters * degPerMeter; // m を度に変換

Projection proj = map.getProjection();
Point basePt = proj.toScreenLocation(base);
Point destPt = proj.toScreenLocation(new LatLng(base.latitude, base.longitude + lonDistance));

return Math.abs(destPt.x - basePt.x);
</code></pre>

<p>}
```</p>

<p>行っていることは単純で、基準となる緯度経度:<code>base</code> から、適当に(ここでは 0.5度)東へ移動した緯度経度を <code>Location.distanceTo</code> で求め、その結果から、「1ｍは何度か？」を求めます。あとは、この係数を使って 地図上の距離:<code>meters</code> を度に変換し、最後に、<code>base</code> と移動後の緯度経度それぞれを画面座標に変換して、画面上の距離を返す、というものです。</p>

<p>「1ｍは何度か？」は、赤道上の値を使っても良いのですが、緯度によって値が大きく変わるので、このような手法を取りました。</p>

<p>ただこれでも、求める距離の精度によっては、<code>OFFSET_LON</code> の値の調整が必要な気がします。また、経度:0 をまたぐような地域では正しく動かない気がします。(いずれも未検証)</p>

<p>また、緯度方向にもそれなりに正確な数値を出すには、上記と同じことを緯度に対しても行う必要があります。(これは v1 の API にもなかった)</p>

<p>v2 になって、描画系でピクセル座標を意識することはなくなったんであまり使うことも無いと思いますが、なにかで必要になったら思い出す程度で。</p>

<h3>追記</h3>

<p>あとで気づいたんですが、 v1 の <a href="https://developers.google.com/maps/documentation/android/v1/reference/com/google/android/maps/Projection#metersToEquatorPixels(float">Projection.metersToEquatorPixels</a>) は、赤道上の距離で算出してたんですね。それと比べるとちょっとオーバースペックでした。</p>

<p> それと、この記事を書く前に私のツイートを読まれた @honjo2 さんが、 v1 と同じ(赤道の距離を使う)仕様の関数を公開してくださいました。</p>

<blockquote class="twitter-tweet"><p>どうぞ <a href="https://t.co/quYnqvn1tw">https://t.co/quYnqvn1tw</a> RT <a href="https://twitter.com/amay077">@amay077</a>: Google Map Android v2 になって metersToEquatorPixels がなくなっちゃったのが地味に不便だ。</p>&mdash; 本城 博昭 (@honjo2) <a href="https://twitter.com/honjo2/statuses/387368608541589505">October 8, 2013</a></blockquote>


<script async src="http://amay077.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[moveCamera(CameraUpdateFactory.newLatLngBounds で落ちる]]></title>
    <link href="http://amay077.github.io/blog/2013/09/29/movecamera-with-cameraupdatefactory-newlatlngbounds-crashes/"/>
    <updated>2013-09-29T21:16:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/09/29/movecamera-with-cameraupdatefactory-newlatlngbounds-crashes</id>
    <content type="html"><![CDATA[<p>Google Map Android API v2 では、指定した範囲にいいかんじにズームしてくれるメソッドがあって（これを使うと下記事のようなことができる）、とても便利なのですが、普通に使ってたら落ちました（泣</p>

<!--more-->


<ul>
<li><a href="http://tryworks-design.com/?p=1530">Android GooglMapを使い、現在値と目的地を（２点間）を表示させる。 | App Camp</a></li>
</ul>


<p>その理由と、対策を記録しておきます。</p>

<h2>エラーになるコード</h2>

<p>GoogleMap v2 を使ったよくあるコード。</p>

<p>```java MainActivity.java
@Override
protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);

SupportMapFragment fragment = ((SupportMapFragment)getSupportFragmentManager()
        .findFragmentById(R.id.map));
GoogleMap gmap = fragment.getMap();

LatLngBounds bounds = LatLngBounds.builder()
    .include(new LatLng(35.4433011,139.646108)) // 横浜
    .include(new LatLng(35.6846001,139.696919)) // 東京
    .build();

gmap.moveCamera(CameraUpdateFactory.newLatLngBounds(bounds, 15));
</code></pre>

<p>}
```</p>

<p>起動時に、横浜-東京 が画面内に入るようにズームする、つもりのコード。</p>

<p>これは以下のエラーになる。</p>

<blockquote><p>09-29 20:22:58.508: E/AndroidRuntime(18904): FATAL EXCEPTION: main<br/>
09-29 20:22:58.508: E/AndroidRuntime(18904): java.lang.RuntimeException: Unable to start activity ComponentInfo{com.amay077.<br/>android/com.amay077.android.mapsample.view.MainActivity}: java.lang.IllegalStateException: Map size should not be 0. Most likely, layout has not yet occured for the map view.</p></blockquote>

<h2>エラーの原因</h2>

<p>StackOverflow さまに載ってた。</p>

<ul>
<li><a href="http://stackoverflow.com/questions/13692579/movecamera-with-cameraupdatefactory-newlatlngbounds-crashes">android - moveCamera with CameraUpdateFactory.newLatLngBounds crashes - Stack Overflow</a></li>
</ul>


<p>また、<a href="https://developers.google.com/maps/documentation/android/views#changing_camera_position">APIリファレンス</a> にも次のように記載がある。</p>

<blockquote><p>Note: Only use the simpler method newLatLngBounds(boundary, padding) to generate a CameraUpdate if it is going to be used to move the camera after the map has undergone layout. During layout, the API calculates the display boundaries of the map which are needed to correctly project the bounding box. In comparison, you can use the CameraUpdate returned by the more complex method newLatLngBounds(boundary, width, height, padding) at any time, even before the map has undergone layout, because the API calculates the display boundaries from the arguments that you pass.</p></blockquote>

<p>意訳すると <code>newLatLngBounds(boundary, padding)</code> は、レイアウトが完了した後で使ってね、そうでない場合は、<code>newLatLngBounds(boundary, width, height, padding)</code> を使ってね。ということらしい。</p>

<p>確かに <code>onCreate</code> ではまだレイアウトされていないので納得。</p>

<h2>対策</h2>

<p>上の StackOverflow でも解決策として、<code>ViewTreeObserver.addOnGlobalLayoutListener</code> を使って、レイアウトが完了したタイミングで moveCamera する方法が紹介されているが、もうちっとシンプルにできないかなと思っていたところ、ちょうど別件で「ビューのサイズが確定(して Width/Height が取得できる)タイミング」を調べていて、同じく StackOverflow で以下の情報を発見。</p>

<ul>
<li><a href="http://stackoverflow.com/questions/4393612/when-can-i-first-measure-a-view/15301092#15301092">android - When Can I First Measure a View? - Stack Overflow</a></li>
</ul>


<p>これによると <code>view.post(new Runnable() { … })</code> のタイミングでも OK らしいので、今回はこれを使ってみる。</p>

<p>```java MainActivity.java
@Override
protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);

SupportMapFragment fragment = ((SupportMapFragment)getSupportFragmentManager()
        .findFragmentById(R.id.map));
final GoogleMap gmap = fragment.getMap();

// NOTE MainActivity.this.runOnUiThread(new Runnable() { ではダメだった
fragment.getView().post(new Runnable() {
    @Override
    public void run() {
        LatLngBounds bounds = LatLngBounds.builder()
                .include(new LatLng(35.4433011,139.646108)) // 横浜
                .include(new LatLng(35.6846001,139.696919)) // 東京
                .build();

        gmap.moveCamera(CameraUpdateFactory.newLatLngBounds(bounds, 15));
    }
});
</code></pre>

<p>}
```</p>

<p>としたところ、正常に地図がズームされました。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/movecamera_with_cameraupdatefactory_newlatlngbounds_crashes_01.png" alt="img" /></p>

<p>ちなみに、処理をメインスレッド上で行う <code>Activity.runOnUiThread</code> や <code>Handler.post</code> では NG、冒頭と同じエラーでした。処理は UIスレッド上で行われるけど、Map はまだレイアウト未完了、という事だと思います。</p>

<p>起動時の処理は、全ての View で post 内に書いておいた方がいいのかも。</p>
]]></content>
  </entry>
  
</feed>
