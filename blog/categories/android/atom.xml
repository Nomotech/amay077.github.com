<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Experiments Never Fail]]></title>
  <link href="http://amay077.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://amay077.github.io/"/>
  <updated>2014-04-04T15:36:49+09:00</updated>
  <id>http://amay077.github.io/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Xamarin.Android で Intent を受けとるには？]]></title>
    <link href="http://amay077.github.io/blog/2014/04/01/receive-intent-by-xamarin-android/"/>
    <updated>2014-04-01T15:26:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/04/01/receive-intent-by-xamarin-android</id>
    <content type="html"><![CDATA[<p>例えば、他のアプリからテキストを「送る」して、自作の Xamarin アプリでそれを受け取りたい時。</p>

<!--more-->


<p>普通の Android アプリ開発だと <code>AndroidManifest.xml</code> にこう書く。</p>

<p>```xml AndroidManifest.xml
<activity
  android:name="com.example.intenttest.MainActivity"
  android:label="@string/app_name" >
  <intent-filter></p>

<pre><code>&lt;action android:name="android.intent.action.MAIN" /&gt;
  &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
</code></pre>

<p>  </intent-filter></p>

<p>  <intent-filter></p>

<pre><code>&lt;action android:name="android.intent.action.SEND" /&gt;
&lt;category android:name="android.intent.category.DEFAULT" /&gt;
&lt;data android:mimeType="text/plain" /&gt;
</code></pre>

<p>  </intent-filter>
</activity>
```</p>

<p>Xamarin.Android では、Activity のソースファイルの属性として、以下のように書く。</p>

<p>```csharp MainActivity.cs
[Activity(Label = "MainActivity", MainLauncher = true)]
[IntentFilter (new []{ Intent.ActionSend },
  Categories = new []{ Intent.CategoryDefault },
  DataMimeType = "text/plain" )]
public class MainActivity : Activity
{</p>

<pre><code>protected override void OnCreate(Bundle bundle)
{
    base.OnCreate(bundle);
</code></pre>

<p>```</p>

<p>テキストでない場合は、mimetype を適宜変更する。省略したら動作しなかった。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Activity がメモリリークしにくくなってる件]]></title>
    <link href="http://amay077.github.io/blog/2014/03/19/android-memory-leaks-improvements/"/>
    <updated>2014-03-19T15:12:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/03/19/android-memory-leaks-improvements</id>
    <content type="html"><![CDATA[<p>2009年の情報なんですけどね。</p>

<!--more-->


<ul>
<li><a href="http://android-developers.blogspot.jp/2009/01/avoiding-memory-leaks.html">Avoiding memory leaks | Android Developers Blog</a></li>
<li><a href="http://d.hatena.ne.jp/androidzaurus/20090121/1232519066">Avoiding memory leaks （超訳） - Android Zaurusの日記</a></li>
<li><a href="http://tomokey.blogspot.jp/2011/05/android.html">暇なメモ帳: Androidのソースコードレビュー(メモリリーク)</a></li>
</ul>


<p>Android でメモリリークする典型的なパターンとして上で紹介されているものがあって、日頃はこうならないように気をつけて実装をしているわけです。</p>

<p>また、メモリリークの調査方法もたくさん情報があります。</p>

<ul>
<li><a href="http://rainbowdevil.jp/?p=1187">Androidでメモリリークの調査と、そのヒープダンプから画像を抽出する » RainbowDevilsLand</a></li>
<li><a href="http://tlync.hateblo.jp/entry/20111220/1324372308">富豪的 Android プログラマの為の Eclipse Memory Analyzer Tool 入門 - sandbox</a></li>
</ul>


<p>日頃、Xamarin.Android を触っているので、「Xamarin でも同じようにリークするよね」と思いやってみたところ全然リークしなかったので、もしや Android-Java でもリークしないんじゃ？と考え、試してみたのが以下の内容です。</p>

<h2>試した</h2>

<p>以下の2つのパターンについて試しました</p>

<ol>
<li>Avoiding memory leaks の 2番目の例。Activity への強参照を持った Drawable を static なメンバにキープしちゃう件。画面が回転した時に、Activity がリークしてしまう、とされる。</li>
<li>暇なメモ帳さんの「問題3」＋α。非static な Inner クラスが Activity の強参照を持ってる、且つ、このオブジェクトを Activity の static メンバにしちゃう。</li>
</ol>


<h2>結論</h2>

<p>から言うと、</p>

<p><strong>1. はリークせず、2. はリークしました。</strong></p>

<p>あれれ？</p>

<h2>パターン1のテストコード</h2>

<p>ほぼ元コードのコピペだけど、クラスが破棄された(<code>finalize</code>)時にログ吐くようにしています。</p>

<p>```java
public class MainActivity extends Activity {</p>

<pre><code>private static final String TAG = "MainActivity";
private static Drawable sBackground;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    Log.d(TAG, "onCreate:" + this.hashCode());

    Button button = new Button(this);
    button.setText("Leaks are bad");

    if (sBackground == null) {
        sBackground = getResources().getDrawable(R.drawable.ic_launcher);
    }
    button.setBackgroundDrawable(sBackground);
    setContentView(button);
}

@Override
protected void onDestroy() {
    Log.d(TAG, "onDestroy:" + this.hashCode());
    super.onDestroy();
}

@Override
protected void finalize() throws Throwable {
    Log.d(TAG, "finalize:" + this.hashCode());
    super.finalize();
}
</code></pre>

<p>}
```</p>

<h3>確認手順</h3>

<ol>
<li>このアプリを実行。Android2.3 のエミュレータ(4.0 の実機でも試した)。</li>
<li>画面を回転させる（Ctrl+F11）</li>
<li>DDMS から GC を走らせる</li>
<li>LogCat を収集</li>
</ol>


<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/improve_activity_leaks_02.png" alt="" />
<img src="https://dl.dropboxusercontent.com/u/264530/qiita/improve_activity_leaks_03.png" alt="" /></p>

<p>Logcat の出力結果はこう。</p>

<p><code>
03-19 21:28:09.539: D/MainActivity(382): onCreate:1079076320
03-19 21:29:15.979: D/MainActivity(382): onDestroy:1079076320
03-19 21:29:15.989: D/MainActivity(382): onCreate:1079106528 ←横画面のActivity
03-19 21:29:33.939: D/MainActivity(382): finalize:1079076320
</code></p>

<p>ちゃんと GC を走らせた後、 Activity の <code>finalize</code> が呼ばれています。
MAT でも確認したけど、リークは発見できませんでした。</p>

<h2>パターン2のテストコード</h2>

<p>こんな実装は早々お目にかからないと思うけど、非static な Inner クラスのインスタンスを、Activity の static メンバにしちゃうぞ、と。</p>

<p>```java
public class MainActivity extends Activity {</p>

<pre><code>private static final String TAG = "MainActivity";
private static SomeInnerClass innerClass;

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    Log.d(TAG, "onCreate");

    if (innerClass == null) {
        innerClass = new SomeInnerClass();
    }
}

@Override
protected void onDestroy() {
    Log.d(TAG, "onDestroy");
    super.onDestroy();
}

@Override
protected void finalize() throws Throwable {
    Log.d(TAG, "finalize");
    super.finalize();
}

class SomeInnerClass {
    public void doSomething() { }
}
</code></pre>

<p>}
```</p>

<h3>確認手順</h3>

<p>パターン1と同じです。</p>

<p>Logcat の出力結果はこちら。</p>

<p><code>
03-19 21:42:55.289: D/MainActivity(476): onCreate
03-19 21:43:05.369: D/MainActivity(476): onDestroy
03-19 21:43:05.549: D/MainActivity(476): onCreate
</code></p>

<p>ご覧のとおり、<code>finalize</code> が呼ばれない、つまり Activity がリークしています。</p>

<h2>考察っぽいの</h2>

<p>パターン2 がリークするのは当然と言えます。
Activity への強参照を持ったオブジェクトを、static フィールドで保持し続けてしまうので、Activity が破棄されない。</p>

<p>パターン1 も同じ理屈だと思うのですが（少なくとも冒頭の記事の説明ではそう）。これがリークしないのは、Android SDK が改善された(例えば、今まで Activity の強参照を持ってたのが弱参照に変わった)とか、Dalvik の GC が改善されたとかでしょうか？</p>

<p>まあ4年も経てば常識も変わるということで、Activity に関しては以前ほど神経質にならなくてもいいかもしれませんが、メモリリークの可能性が消えることは有り得ないので、このアンチパターンはこれからも遵守していかないといけませんね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin によるクロスプラットフォームモバイルアプリ開発、資料と補足]]></title>
    <link href="http://amay077.github.io/blog/2014/02/27/slides-from-my-xamarin-introduction/"/>
    <updated>2014-02-27T21:40:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/02/27/slides-from-my-xamarin-introduction</id>
    <content type="html"><![CDATA[<p>2/26 の <a href="http://atnd.org/events/47898">うずらインキュベータ</a> という勉強会で、Xamarin の話をしました。</p>

<!--more-->




<iframe src="http://www.slideshare.net/slideshow/embed_code/31674661" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px 1px 0; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>


<p> <div style="margin-bottom:5px"> <strong> <a href="https://www.slideshare.net/amay077/xamarin-31674661" title="Xamarin によるクロスプラットフォームモバイルアプリ開発" target="_blank">Xamarin によるクロスプラットフォームモバイルアプリ開発</a> </strong> from <strong><a href="http://www.slideshare.net/amay077" target="_blank">amay 077</a></strong> </div></p>

<p>45分という長い時間話すのは勉強会では初めてだったのですが、なんとか説明し切ることができました。（ちょっとデモが中途半端になってしまいましたが）</p>

<p>資料は <a href="http://qiita.com/tags/xamarin">Qiita に書いてきた</a> 内容のまとめみたいなものですが、少し補足します。</p>

<h2>Xamarin で作った経験あるの？</h2>

<p>仕事では、まだ無いです（<sup>_<sup>;）</sup></sup>
個人アプリでは「<a href="https://itunes.apple.com/us/app/fu-shifoto/id806913229">富士フォト</a>」というのを iOS 用は Xamarin.iOS で作りました。<a href="https://play.google.com/store/apps/details?id=com.amay077.android.fujiphoto">Android</a> は Java ですが Xamarin 化したいな。</p>

<h2>Win+Visual Studio ではダメなの？</h2>

<p>個人の見解ですから（<sup>_<sup>;）</sup></sup>
私も元々は Windowsの開発がメインで Visual Studio の強力さは知っていますが、iOS やるならどういう形にせよ Mac+Xcode を扱わないといけないので、慣れておいた方がよいかなと。</p>

<p>また、Microsoft との提携以降、Microsoft のエバンジェリストさんや MVP の方々が Visual Studio + Xamarin の話をものすごく展開されているので、そちらにお任せした次第です。</p>

<h2>実行モデルのとこ</h2>

<p>JavaSE が .NET に置き換わる図になっていますが、実際には少し違っていて、JavaSE のラッパもあります。例えば文字列型には、<code>System.String</code> と <code>Java.Lang.String</code> があります。当然、理由がなければ前者を使った方がよいわけですが。</p>

<p>iOS のスタックに関しては、実はどこからどこまでが「CocoaTouch」なのかよく分かってません。</p>

<h2>他のクロスプラットフォーム開発ツールとの比較</h2>

<p>Titanium, AIR については2年くらい前に少し触ったことがあります。PhoneGap と DelphiXE についてはスペックを見て＆詳しい方からの情報を元にしてます。</p>

<p>Titanium は次期 <a href="http://titanium-mobile.jp/38">Ti.Next</a> では JavaScriptCore を使ってすんごく速くなるそうですし、AIR も当時よりだいぶ <a href="http://www.slideshare.net/pik256/dev-sumi2014-13c4rev">高速になったらしい</a> です。</p>

<h2>C# のとこ</h2>

<p>https://xamarin.com/csharp よりは悪意のないコードかとｗ
（Objective-C と比較しようとすると Obj-C の方が画面に入らないので Java との比較にしました。）</p>

<p>こんなところで。
何かおかしなところがあったらコメント頂けるとありがたいです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[手抜きカラー選択ダイアログを作る]]></title>
    <link href="http://amay077.github.io/blog/2014/02/27/make-shoddy-colorpicker/"/>
    <updated>2014-02-27T21:38:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/02/27/make-shoddy-colorpicker</id>
    <content type="html"><![CDATA[<p>Android で「定められた色リストから１つ選択する」ダイアログを作ります。</p>

<!--more-->


<h2>さっそくコード</h2>

<p><code>AlertDialog</code> には自作の <code>Adapter</code> が設定できるので、「項目値を背景色にする Adapter」を作って設定すれば OK でした。</p>

<p>```java MainActivity.java
public class MainActivity extends Activity {</p>

<pre><code>final private Integer[] _colors = { Color.RED, Color.BLUE, Color.GREEN }; // 色リスト
final int ID_COLOR_PICKER = 1;

// 背景に色リストを適用する ListAdapter
static class ColorListAdapter extends ArrayAdapter&lt;Integer&gt; {
    public ColorListAdapter(Context context, Integer[] colors) {
        super(context, android.R.layout.simple_list_item_1, colors);
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        TextView view = (TextView)super.getView(position, convertView, parent);
        view.setBackgroundColor(getItem(position));
        view.setTextColor(Color.TRANSPARENT); // 色値が表示されないように隠す
        return view;
    }
}

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    findViewById(R.id.button1).setOnClickListener(new OnClickListener() {
        @Override
        public void onClick(View v) {
            showDialog(ID_COLOR_PICKER); // ダメよ直接 Dialog.show() しちゃ
        }
    });
}

@Override
protected Dialog onCreateDialog(int id) {
    switch (id) {
    case ID_COLOR_PICKER:
        ColorListAdapter adapter = new ColorListAdapter(MainActivity.this, _colors);

        return new AlertDialog.Builder(MainActivity.this)
            .setTitle("Select color")
            .setAdapter(adapter, new DialogInterface.OnClickListener() {
                @Override
                public void onClick(DialogInterface dialog, int which) {
                    Toast.makeText(MainActivity.this, 
                            "You picked index=" + which, Toast.LENGTH_LONG).show();
                }
            }).create();

    default:
        return super.onCreateDialog(id);
    }
}
</code></pre>

<p>}
```</p>

<p>キャストしてるところがちょっと不安ですけど、まあいいでしょう。</p>

<h2>動かしてみる</h2>

<p>こんな感じです。だいぶ味気ないけど、要件は満たします。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/making_shoddy_color_picking_dialog_01.png" alt="" /></p>

<h2>Xamarin でも作ってみる</h2>

<p>本題とまったく関係ありませんが、同じものを Xamarin.Android で作ると、こうなります。</p>

<p>```csharp MainActivity.cs
[Activity(Label = "ColorPickerSample", MainLauncher = true)]
public class MainActivity : Activity
{</p>

<pre><code>readonly Color[] _colors = { Color.Red, Color.Blue, Color.Green };
const int ID_COLOR_PICKER = 1;

class ColorListAdapter : ArrayAdapter&lt;Color&gt;
{
    public ColorListAdapter(Context context, Color[] colors) 
        : base(context, Android.Resource.Layout.SimpleListItem1, colors)
    {
    }

    public override View GetView(int position, View convertView, ViewGroup parent)
    {
        var view = base.GetView(position, convertView, parent) as TextView;
        view.SetBackgroundColor(new Color(GetItem(position)));
        view.SetTextColor(Color.Transparent); // 色値が表示されないように隠す
        return view;
    }
}

protected override void OnCreate(Bundle bundle)
{
    base.OnCreate(bundle);
    SetContentView(Resource.Layout.Main);

    FindViewById&lt;Button&gt;(Resource.Id.myButton)
        .Click += (s, e) =&gt; ShowDialog(ID_COLOR_PICKER);
}

protected override Dialog OnCreateDialog(int id)
{
    switch (id)
    {
        case ID_COLOR_PICKER:
            var adapter = new ColorListAdapter(this, _colors);

            return new AlertDialog.Builder(this)
                .SetTitle("Select color")
                .SetAdapter(adapter, 
                    (s, e) =&gt; Toast.MakeText(
                        this, "You picked index=" + e.Which.ToString(), 
                        ToastLength.Long).Show())
                .Create();

        default:
            return base.OnCreateDialog(id);
    }
}
</code></pre>

<p>}
```</p>

<p>Android API は同じなのでほとんど同じ、言語仕様の特性で少しコンパクトになりますかね。</p>

<p>では、また。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MVVMフレームワーク「ReactiveUI」を Xamarin.iOS で使ってみる]]></title>
    <link href="http://amay077.github.io/blog/2014/02/27/using-reactiveui-on-xamarin-ios/"/>
    <updated>2014-02-27T21:34:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/02/27/using-reactiveui-on-xamarin-ios</id>
    <content type="html"><![CDATA[<p>ReactiveUI は、Reactive Extensions を全面的に取り入れた クロスプラットフォームな MVVMフレームワークです。</p>

<!--more-->


<ul>
<li><a href="http://www.reactiveui.net/">ReactiveUI</a></li>
</ul>


<p>作者は GitHub の中の人 <a href="http://twitter.com/xpaulbettsx">Paul Betts</a> 氏、<a href="http://xamarin.com/mvp">Xamarin の MVP</a> でもあります。</p>

<p>元々は WPF, Silverlight, WinRT, Windows Phone に対応していましたが、Xamarin.iOS や Xamarin.Android, Xamarin.Mac にも <a href="http://blog.paulbetts.org/index.php/2013/03/12/reactiveui-4-5-is-released/">対応が進んで来た</a> ので、使ってみる事にしました。</p>

<p>Visual Studio + WPF 等なら、nuget から取得できて楽なんでしょうけども、なにせ Mac なので、Xamarin Studio のみでいきます。</p>

<h2>とりあえず使ってみる</h2>

<p>Github が公開した <a href="http://log.paulbetts.org/open-source-githubs-xamarin-starter-apps/">GitHub's Xamarin starter apps</a>, これに ReactiveUI も含まれているので、こちらを Clone して Xamarin Studio で開いてビルド、すぐ動きます。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/using_reactiveui_01.png" alt="" /></p>

<p>これ、ViewModel側で UUID を生成して、View側の Label にバインドしているのですが、何ともシンプル過ぎて…。</p>

<p>それでもこのフレームワークの構成を知るには十分です。</p>

<h2>ReactiveUI に必要なもの</h2>

<p>ソリューションツリーを見ると次の4つのプロジェクトがあります。</p>

<ul>
<li>Starter-Core-Android</li>
<li>Starter-Core-iOS</li>
<li>Starter-Android</li>
<li>Starter-iOS</li>
</ul>


<h3>ViewModel-Model層</h3>

<p>Starter-Core-xxx は、ディレクトリ的には同じ場所にあり、Android用とiOS用のプロジェクトファイル(.csproj)が用意してあるだけです。ここはアプリケーションの ViewModel-Model層になります。PCL化はされていないようですね(その内、とサイトに書いてありました)。</p>

<p>サンプルで用意されてる ViewModel を見てみます。</p>

<p>```csharp TestViewModel.cs
using System;
using ReactiveUI;
using System.Runtime.Serialization;</p>

<p>namespace Starter.Core.ViewModels
{</p>

<pre><code>[DataContract]
public class TestViewModel : ReactiveObject
{
    string _TheGuid;
    [DataMember] public string TheGuid {
        get { return _TheGuid; }
        set { this.RaiseAndSetIfChanged(ref _TheGuid, value); }
    }

    public TestViewModel()
    {
        TheGuid = Guid.NewGuid().ToString();
    }
}
</code></pre>

<p>}
```</p>

<p>MvvmCross とか、他の MVVM-FW とだいたい同じですね(そりゃそうだ)。
基底クラスの <code>ReactiveObject</code> が、BaseViewModel的な役割をします。(が、Reactive を冠しているだけに、随所で Rx の力が発揮される、はずです←まだ分かってない)</p>

<p>このコードでは、TestViewModel の生成と同時に、Guid を生成して、<code>TheGuid</code> プロパティに設定しています。</p>

<h3>View層</h3>

<p>Starter-Android, Starter-iOS はそれぞれの View層になります。</p>

<p>Starter-iOS の TestViewController.cs を見てみます。</p>

<p>```csharp TestViewController.cs
namespace Starter.Views
{</p>

<pre><code>public partial class TestViewController : ReactiveViewController, IViewFor&lt;TestViewModel&gt;
{
    [省略]

    public override async void ViewDidLoad()
    {
        base.ViewDidLoad();
        this.OneWayBind(ViewModel, vm =&gt; vm.TheGuid, v =&gt; v.TheGuid.Text);

        ViewModel = await BlobCache.LocalMachine.GetOrCreateObject("TestViewModel", () =&gt; {
            return new TestViewModel();
        });
    }

    TestViewModel _ViewModel;
    public TestViewModel ViewModel {
        get { return _ViewModel; }
        set { this.RaiseAndSetIfChanged(ref _ViewModel, value); }
    }

    [省略]
}
</code></pre>

<p>}
```</p>

<p><code>UIViewController</code> ではなく <code>ReactiveViewController</code> から派生させてます。この辺もよくあるやり方。<code>IViewFor</code> は、今はスルーで。</p>

<p>バインドは <code>this.OneWayBind</code> で。
ViewModel の TheGuid プロパティを、View の TheGuidラベルの Text プロパティへ単方向(OneWay)バインドしてます。</p>

<p>TestViewModel の生成は、ここでは Akavache というストレージライブラリの生成を待ってから行っていますが、Akavache を使わない場合は普通に <code>this.ViewModel = new TestViewModel()</code> で OK でしょう。</p>

<p>これで、TestViewModelの生成 → Guidの生成 → vm.TheGuidプロパティへ設定 → vm より TheGuid の変更が通知される → View側のBindingが変更を検知 → Viewのラベルを書き換える、という流れになります。</p>

<h2>ちょっと拡張してみる</h2>

<h3>双方向バインディング</h3>

<p>ViewModel→View だけでなく、View→ViewModel もやってみましょう。</p>

<p>まず TestViewModel にプロパティを追加します。
プロパティは <code>MyName</code> とします。
初期値として "Enter your name" とでも設定しましょうか。</p>

<p>```csharp TestViewModel.cs
namespace Starter.Core.ViewModels
{</p>

<pre><code>[DataContract]
public class TestViewModel : ReactiveObject
{
    string _TheGuid;
    [DataMember] public string TheGuid {
        get { return _TheGuid; }
        set { this.RaiseAndSetIfChanged(ref _TheGuid, value); }
    }

    string _myName;
    [DataMember] public string MyName {
        get { return _myName; }
        set { this.RaiseAndSetIfChanged(ref _myName, value); }
    }

    public TestViewModel()
    {
        TheGuid = Guid.NewGuid().ToString();

        this.MyName = "Enter your name";
    }
}
</code></pre>

<p>}
```</p>

<p>次に Interface Builder で TestViewController に、UITextField と UILabel を追加し、Outlet を "MyText", "MyLabel" とします。これで Xamarin.iOS から <code>MyText</code>, <code>MyLabel</code> でインスタンスにアクセスできるはず、ですよね。</p>

<p><code>MyText</code>, <code>MyLabel</code> に、vm.MyName をバインドします。</p>

<p>```csharp TestViewController.cs
namespace Starter.Views
{</p>

<pre><code>public partial class TestViewController : ReactiveViewController, IViewFor&lt;TestViewModel&gt;
{
    [省略]

    public override async void ViewDidLoad()
    {
        base.ViewDidLoad();
        this.OneWayBind(ViewModel, vm =&gt; vm.TheGuid, v =&gt; v.TheGuid.Text);

        this.Bind(ViewModel, vm=&gt; vm.MyName, v =&gt; v.MyText.Text);
        this.OneWayBind(ViewModel, vm =&gt; vm.MyName, v =&gt; v.MyLabel.Text);

        ViewModel = await BlobCache.LocalMachine.GetOrCreateObject("TestViewModel", () =&gt; {
            return new TestViewModel();
        });
    }

    [省略]
}
</code></pre>

<p>}
```</p>

<p>編集できる <code>MyText</code> は <code>this.Bind</code> を使って双方向バインドします。プロパティの値を表示するだけの <code>MyLabel</code> は、 <code>this.OneWayBind</code> で。</p>

<p>これで動かしてみます。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/using_reactiveui_02.gif" alt="" /></p>

<p>UITextField への入力が、vm.MyName へ適用され、その変更を MyLabel に表示させる、という流れです。</p>

<p>今日はこの辺で。まだ全然 Reactive じゃないですが、次回以降、Command の実装やバインディングについて試してみようと思います。</p>

<p>ここまでのコードは、</p>

<ul>
<li>https://github.com/amay077/starter-mobile/tree/N_plus_1</li>
</ul>


<p>に置いておきます。徐々に進化させていこうと思います。</p>
]]></content>
  </entry>
  
</feed>
