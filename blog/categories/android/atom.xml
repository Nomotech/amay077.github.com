<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Experiments Never Fail]]></title>
  <link href="http://amay077.github.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://amay077.github.com/"/>
  <updated>2013-02-28T16:44:08+09:00</updated>
  <id>http://amay077.github.com/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Xamarin.Android で作った HelloWorld のソースを眺めてみる]]></title>
    <link href="http://amay077.github.com/blog/2013/02/28/helloworld-on-xamarin-android/"/>
    <updated>2013-02-28T00:38:00+09:00</updated>
    <id>http://amay077.github.com/blog/2013/02/28/helloworld-on-xamarin-android</id>
    <content type="html"><![CDATA[<p>MonoDroid とか Mono for Android とか呼ばれてた時は、「あーどうせ MonoDevelop と他のモジュールあれこれインストールしなきゃいけないんでしょ？」と腰が重かったのですが、<a href="http://www.forest.impress.co.jp/docs/news/20130221_588816.html">Xamarin 2.0 としてオールインワン化</a>されるとこうも食指が動きますか。</p>

<!-- more -->


<p>さっそく Xamarin.Android のプロジェクトを作って、中身をみてみました。</p>

<h2>ダウンロード</h2>

<p><a href="http://xamarin.com/">Xamarin.com</a> から <strong>Download Now</strong> しましたよ。あ、環境は Mac(Lion) です。</p>

<h2>インストール</h2>

<p>dmg 開いてインストーラっぽいのを実行するだけ。Android と iOS の SDK の場所を聞かれましたがデフォのまま続行しました。たぶん Android 開発者はもう SDK あるのでそこを指定しても良いのでしょう。</p>

<h2>起動、プロジェクト作成</h2>

<p>C# - Android - Android Ice Cream Sandwitch Application を選択。</p>

<p><img src="https://dl.dropbox.com/u/264530/qiita/xamarin_create_project.png" alt="&quot;create_project&quot;" /></p>

<p>ちなみに VB.NET もありますが、Android用のプロジェクトテンプレがありませんでした。</p>

<h2>プロジェクトの中身はこんな感じ</h2>

<p><img src="https://dl.dropbox.com/u/264530/qiita/xamarin_helloworld.png" alt="&quot;project&quot;" /></p>

<p>ソリューションツリー、Visual Studio っぽさと Android っぽさが同居していてなんか不思議な感じです。</p>

<p>「参照」「Properties」「Resource.designer.cs」あたりは Visual Studio っぽいですね。
一方、「Assets」「drawable」「layout」「values」あたりは Android っぽいですね。
ちなみに、<code>layout/Main.axml</code> というファイルがあります。一瞬「ザムル(Xaml)？」と見間違えましたが、開いてみるとなんのことはない、ただの Android Layout XML でした(<sup>_<sup>;)</sup></sup></p>

<p>そして <code>MainActivity.cs</code> 、混血ですね。</p>

<p>ソースを見てみましょう。</p>

<p>```c# MainActivity.cs
using System;</p>

<p>using Android.App;
using Android.Content;
using Android.Runtime;
using Android.Views;
using Android.Widget;
using Android.OS;</p>

<p>namespace HelloXamarinAndroid
{</p>

<pre><code>[Activity (Label = "HelloXamarinAndroid", MainLauncher = true)]
public class Activity1 : Activity
{
    int count = 1;

    protected override void OnCreate(Bundle bundle)
    {
        base.OnCreate(bundle);

        // Set our view from the "main" layout resource
        SetContentView(Resource.Layout.Main);

        // Get our button from the layout resource,
        // and attach an event to it
        Button button = FindViewById&lt;Button&gt;(Resource.Id.myButton);

        button.Click += delegate
        {
            button.Text = string.Format("{0} clicks!", count++);
        };
    }
}
</code></pre>

<p>}
```</p>

<p>ソースの中にも Android の要素がたくさん確認できます。</p>

<p><code>[Activity (Label = "HelloXamarinAndroid", MainLauncher = true)]</code>
これ、本家では AndroidManifest.xml の Intent-Filter に定義する設定ですね。ここに書けちゃうみたいです。</p>

<p><code>public class Activity1 : Activity</code>
Activity クラスを継承するのも変わりません。</p>

<p><code>protected override void OnCreate(Bundle bundle)</code>
onCreate を override するのも、その中で setContentView するのも、findViewById するのも本家と変わりません。C# っぽくメソッド名が大文字で始まっているのと、若干メンバ名(R.id が Resource.Id とか)が変わっているくらいです。</p>

<p>そしてボタンクリックらへんの処理、</p>

<p>```c#
Button button = FindViewById<Button>(Resource.Id.myButton);</p>

<p>button.Click += delegate
{</p>

<pre><code>button.Text = string.Format("{0} clicks!", count++);
</code></pre>

<p>};
```</p>

<p>C# ならではの匿名delegate 使ってます。OnClickListener インターフェースを実装しなければならない本家に比べて短く書けます。
更に短くするなら以下でしょうか。</p>

<p>```c#
var button = FindViewById<Button>(Resource.Id.myButton);</p>

<p>button.Click += (sender, e) =></p>

<pre><code>button.Text = string.Format("{0} clicks!", count++);
</code></pre>

<p>```</p>

<p>まず <code>var</code>。型推論ですよ Variant じゃないですよ。
そしてイベントハンドラはラムダ式で１行で書けます。いや嬉しい。</p>

<p>あと地味にイベントハンドラが += で複数追加できるのもありがたいと思う時が来るでしょう。</p>

<h2>ビルド、実行</h2>

<p>実行すると、こんなダイアログが出てきます。</p>

<p><img src="https://dl.dropbox.com/u/264530/qiita/xamarin_device_select.png" alt="&quot;devices&quot;" /></p>

<p>実機もちゃんと認識されます。</p>

<h2>まとめ</h2>

<p>ソースコード見るまで勘違いしてました。クロスプラットフォームをうたっているから HelloWorld くらいなら "Write once, run anywhere" なのかと。</p>

<p>全然違いました。Xamarin.Android は気持ち良いくらいに Android SDK のラッパですし、Xamarin.iOS は iOS SDK のラッパでした。</p>

<p>UI は共通化できませんし、プラットフォーム固有の機能を使うロジックも共通化できません。M-V-VM なら、共通化できるのは M の一部と VM くらい？それも <code>DependencyProperty</code> みたいなのは用意されていないので自作する必要があります。</p>

<p>しかしラッパなだけに元々 Android の開発をしていた人にとっての学習コストは低いです。
Obj-C やりたくねー、って思ってた人にもちょうど良いかも知れません。</p>

<p>なんといっても、スマホアプリ開発で async/await とか Reactive Extensions とか使えるのかと思うと wktk です(<sup>^)</sup></p>

<p>最後に Xamarin.android も Xamarin Studio も、ここまで完成度が高いとは思ってませんでした。Xamarin さん、Mono さんごめんなさい。(ソースコードエディタで日本語入力ができないのは僕だけでしょうか？)
なんか C# 楽しいので<a href="https://store.xamarin.com/">買っちゃい</a>そうです、INDEE くらいなら。</p>

<h2>参考</h2>

<ul>
<li><a href="http://ufcpp.wordpress.com/2013/02/24/xamarin-2-0/">Xamarin 2.0 | ++C++; // 未確認飛行 C ブログ</a></li>
</ul>


<p>Mono ランタイムが同梱されているのですね。上の HelloWorld で 1.2MB くらいでした。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Maps API v2 のマーカーの Anchor を探る]]></title>
    <link href="http://amay077.github.com/blog/2013/02/19/googlemap-v2-anchor/"/>
    <updated>2013-02-19T23:10:00+09:00</updated>
    <id>http://amay077.github.com/blog/2013/02/19/googlemap-v2-anchor</id>
    <content type="html"><![CDATA[<p>Google Maps API の Marker には、<a href="https://developers.google.com/maps/documentation/android/reference/com/google/android/gms/maps/model/MarkerOptions#anchor(float,%20float">Anchor</a> というプロパティがあり、緯度経度と、画像のどの位置をマッピングさせるかを設定する事ができます。</p>

<!-- more -->


<p>Marker の既定の画像は、よく見るピンみたいなやつですが、既定の Anchor は、0.5f/1.0f になっています。設定値は、画像に対する「x軸の割合」と「y軸の割合」で、言わんとすることは、「緯度経度の位置を画像の、横方向はちょうど真ん中、縦方向は最下部に合わせる」という事です。</p>

<p><img src="https://dl.dropbox.com/u/264530/qiita/marker_anchor.png" alt="Marker.anchor の設定値" /></p>

<p>以下のように、設定値を変更すると、それぞれマーカーの表示位置が変わります。(Android SDK に同梱される Google Maps API v2 のサンプルをベースにしています)</p>

<p>```java anchor_center_bottom.java
mAdelaide = mMap.addMarker(new MarkerOptions()</p>

<pre><code>.position(ADELAIDE)
.title("Adelaide")
.snippet("Population: 1,213,000")
.anchor(0.5f, 1.0f)); // 既定値と同じ
</code></pre>

<p><code>
</code>java anchor_left_top.java
mAdelaide = mMap.addMarker(new MarkerOptions()</p>

<pre><code>.position(ADELAIDE)
.title("Adelaide")
.snippet("Population: 1,213,000")
.anchor(0.0f, 0.0f)); // 左上
</code></pre>

<p><code>
</code>java anchor_right_middle.java
mAdelaide = mMap.addMarker(new MarkerOptions()</p>

<pre><code>.position(ADELAIDE)
.title("Adelaide")
.snippet("Population: 1,213,000")
.anchor(1.0f, 0.5f)); // 右中
</code></pre>

<p>```</p>

<p><img src="https://dl.dropbox.com/u/264530/qiita/marker_anchor_sample.png" alt="Marker.anchor examples" /></p>

<h2>v1 ではどうだったっけ？</h2>

<p>Google Maps API v1 では、<a href="https://developers.google.com/maps/documentation/android/v1/reference/">ItemizedOverlay</a> の <code>boundCenter</code> と <code>boundCenterBottom</code> に相当する機能ですね。こちらはメソッド名の通り、「中央/中心」と「中央/下部」しか対応してなかったので、より柔軟になったと言えます。</p>

<h2>ハマりどころ</h2>

<ul>
<li>最初、anchor はピクセル指定だ、と勝手に勘違いして、画像のサイズを取得してゴニョゴニョやってたのは内緒。</li>
<li>0.0〜1.0 の範囲であることを忘れて、0〜100 の値を設定すると、<strong>「マーカーが全部消えます」</strong></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTC J で NETWORK_PROVIDER で位置測位した時の機種依存バグ？]]></title>
    <link href="http://amay077.github.com/blog/2013/02/19/htc-j-networkprovider-bug/"/>
    <updated>2013-02-19T00:41:00+09:00</updated>
    <id>http://amay077.github.com/blog/2013/02/19/htc-j-networkprovider-bug</id>
    <content type="html"><![CDATA[<p><a href="mixi%20Engineers'%20Blog%20http://alpha.mixi.co.jp/2013/11572/">Androidの機種依存問題を吸収するプロジェクトAndroid-Device-Compatibilityを公開したお話</a> を見て、あーそう言えばこんなんあったなーと思い出したのでメモ。</p>

<h2>症状</h2>

<p>下記条件を満たす時に、LocationManager.requestLocationUpdates すると、最新の位置が取得されず、<strong>前回測位した位置</strong> が返される。</p>

<p>時刻は更新されてたか、、、あーどうだったかな。</p>

<!-- more -->


<h2>条件</h2>

<ul>
<li>NETWORK_PROVIDER で位置を取得した場合（GPS じゃない）</li>
<li>WiFi が無効の場合（つまり携帯電話の基地局のみを使った測位の場合）</li>
<li>スリープ中な場合</li>
<li>HTC J である(IS03, Nexus S では発生してない。 HTC J Butterfly はわからない)</li>
</ul>


<h2>こんな事してたら見つけた</h2>

<p>早い話が HexRinger なんですが、このアプリは、AlarmManager で一定時間毎に WiFi/基地局から位置を取得しています。デバッグで移動中のログを取ってたら、「この時間帯、電車で寝てたのになんか位置変わってないんだけどｗ」となりました。</p>

<h2>対策</h2>

<p>WakeLock する。ただし PARTIAL_WAKE_LOCK だとダメで、画面も起こしてやらないとダメだった。
SCREEN あるいは FULL_WAKELOCK が必要な常駐アプリって、最悪やん。</p>

<h2>いろいろ試した事とか推測</h2>

<ul>
<li>測位前に通信させればいけるか？と思ったけどダメだった。</li>
<li>そもそも「最寄りの基地局情報」がスリープ状態だと更新されないんじゃないか説。</li>
</ul>


<p>設置場所が山奥過ぎてこの地雷を踏む人はそうはいないと思いますが、「HTC J だけど問題ないよ？」「Butterfly でもダメだったわー」とかの情報あったらコメントください。 m(<em> </em>)m</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android の jUnit テストで Context が欲しい時]]></title>
    <link href="http://amay077.github.com/blog/2013/01/19/gets-context-on-android-junit/"/>
    <updated>2013-01-19T00:44:00+09:00</updated>
    <id>http://amay077.github.com/blog/2013/01/19/gets-context-on-android-junit</id>
    <content type="html"><![CDATA[<p>Activity のテストなら <code>ActivityInstrumentationTestCase2</code> 、 Service なら <code>ServiceTestCase</code> を使うべきなんでしょうけど、Android って事あるごとに Context が必要なので、ただのクラスライブラリのテストでも必要なことがシバシバ。</p>

<!-- more -->


<p>``` java HogeTest.java
public class HogeTest extends InstrumentationTestCase {</p>

<pre><code>/** ApplicationContext を取得します */
private Context getApplicationContext() {
    return this.getInstrumentation().getTargetContext().getApplicationContext();
}
</code></pre>

<p>}
```</p>

<h2>参考</h2>

<ul>
<li>[androidの単体テスト(AndroidTestCase) - Androidのド肝] (http://blog.haw.co.jp/android/?p=471) - クラス図がとても役に立ちました</li>
<li><a href="http://stackoverflow.com/questions/5544205/accessing-application-context-from-testsuite-in-setup-before-calling-getactivi">android - Accessing application context from TestSuite in Setup() before calling getActivity() - Stack Overflow</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Maps Android API v2 で OpenStreetMap を表示する]]></title>
    <link href="http://amay077.github.com/blog/2012/12/26/osm-on-googlemapv2/"/>
    <updated>2012-12-26T00:18:00+09:00</updated>
    <id>http://amay077.github.com/blog/2012/12/26/osm-on-googlemapv2</id>
    <content type="html"><![CDATA[<p>この記事は <a href="http://atnd.org/events/34052">FOSS4G Advent Calendar 2012</a> の 12/26 の記事です。</p>

<p>ベクトル地図が扱える新しい Google Maps Android API v2 については、<a href="http://qiita.com/items/7ad0244c0fb4b431e090">Google Map Android API v2 の v1 からの変更点メモ</a> で書きました。</p>

<p>ここでは、v2 で新しく追加された <code>TileOverlay</code> を使って、OpenStreetMap を重ねてみます。</p>

<!-- more -->


<h2>UrlTileProvider を使って OpenStreetMap を表示する</h2>

<p>SDK に同梱されるサンプル /extras/google/google_play_services/samples/maps の TileOverlayDemoActivity.java を見れば一目瞭然なので、それをベースにします。</p>

<h3>サンプルのコード</h3>

<p>``` java TileOverlayDemoActivity.java
/<em>* This returns moon tiles. </em>/
private static final String MOON_MAP_URL_FORMAT =</p>

<pre><code>    "http://mw1.google.com/mw-planetary/lunar/lunarmaps_v1/clem_bw/%d/%d/%d.jpg";
</code></pre>

<p>private GoogleMap mMap;</p>

<p>private void setUpMap() {</p>

<pre><code>mMap.setMapType(GoogleMap.MAP_TYPE_NONE);

TileProvider tileProvider = new UrlTileProvider(256, 256) {
    @Override
    public synchronized URL getTileUrl(int x, int y, int zoom) {
        // The moon tile coordinate system is reversed.  This is not normal.
        int reversedY = (1 &lt;&lt; zoom) - y - 1;
       String s = String.format(Locale.US, MOON_MAP_URL_FORMAT, zoom, x, reversedY);
        URL url = null;
        try {
            url = new URL(s);
        } catch (MalformedURLException e) {
            throw new AssertionError(e);
        }
        return url;
    }
};
mMap.addTileOverlay(new TileOverlayOptions().tileProvider(tileProvider));
</code></pre>

<p>}
```
修正前のコードは、Google Moon のタイル画像を使用しています。</p>

<p>これを OpenStreetMap を使用するように改造します。</p>

<p>``` java OsmTileOverlayDemoActivity.java
/<em>* This returns moon tiles. </em>/
private static final String OSM_MAP_URL_FORMAT =</p>

<pre><code>    "http://tile.openstreetmap.org/%d/%d/%d.png";
</code></pre>

<p>private GoogleMap mMap;</p>

<p>private void setUpMap() {</p>

<pre><code>mMap.setMapType(GoogleMap.MAP_TYPE_NONE);

TileProvider tileProvider = new UrlTileProvider(256, 256) {
    @Override
    public synchronized URL getTileUrl(int x, int y, int zoom) {
        String s = String.format(Locale.US, OSM_MAP_URL_FORMAT, zoom, x, y);
        URL url = null;
        try {
            url = new URL(s);
        } catch (MalformedURLException e) {
            throw new AssertionError(e);
        }
        return url;
    }
};
mMap.addTileOverlay(new TileOverlayOptions().tileProvider(tileProvider));
</code></pre>

<p>}
```</p>

<p>できました。うーん、簡単すぎる。
URL は OpenStreetMap のものを使います。y軸の値は、Google Moon では逆順となっていたのを正順のまま使用するだけです。</p>

<p>こんな感じで表示できます。</p>

<p><img src="https://dl.dropbox.com/u/264530/qiita/advent2012_osm.png" alt="OpenStreetMap on Google Map API" /></p>

<p>移動、拡大・縮小だけでなく、API v2 の恩恵で、回転やチルトもできるのが嬉しいですね。</p>

<h2>TileOverlay を透過させる</h2>

<p>さて、ベース地図を Google から他のものに差し替えてしまうならこれまでの使い方で十分でしょう。しかし Google のベクトル3Dグリグリ地図をベース地図として使いたいとは誰しもが思うことでしょう。</p>

<p>ここでは、Google地図の上に TileOverlay を透過で表示することにチャレンジしてみます。
ケースとしては、雨雲レーダーのメッシュや、統計メッシュなどを重ね合わせる事が考えられます。</p>

<p>さて、API v2 のもう一つの新機能 GroundOverlay には <a href="https://developers.google.com/maps/documentation/android/reference/com/google/android/gms/maps/model/GroundOverlay#setTransparency(float">setTransparentcy</a> というズバリなメソッドがあり、それを使えば一発です。</p>

<p>しかし、TileOverlay とその関連クラスには、透過に関するメソッドは見当たりません。
そこで TileProvider でダウンロードされた画像データを直接弄って、透過にします。</p>

<p>TileProvider は文字通り <a href="https://developers.google.com/maps/documentation/android/reference/com/google/android/gms/maps/model/Tile">Tile</a> を Provide します。そしてこの Tile はタイル画像データそのものです。</p>

<p><a href="https://developers.google.com/maps/documentation/android/reference/com/google/android/gms/maps/model/Tile#data">Tile.data</a> の説明には次のように記述があります。</p>

<blockquote><p>A byte array containing the image data. The image will be created from this data by calling <a href="https://developers.google.com/maps/documentation/android/reference/com/google/android/gms/maps/model/null#decodeByteArray(byte[],%20int,%20int">decodeByteArray(byte[], int, int)</a>).</p></blockquote>

<p>つまりこのプロパティの中身を透過させてあげれば良さげ、という事になります。</p>

<p>上記のコードで使用した UrlTileProvider の <a href="https://developers.google.com/maps/documentation/android/reference/com/google/android/gms/maps/model/UrlTileProvider#getTile(int,%20int,%20int">getTile</a> を override して…と思ったら、
＿人人人人人人人人人＿
＞　突然の final！　＜
￣<sup>Y<sup>Y<sup>Y<sup>Y<sup>Y<sup>Y<sup>Y<sup>￣</sup></sup></sup></sup></sup></sup></sup></sup>
という事で override できません。</p>

<p>仕方ががないので、独自の TileProvider を別途用意して、UrlTileProvider を内包する形で <code>TransparencyUrlTileProvider</code> というクラスを実装します。</p>

<p>```java TransparencyUrlTileProvider.java
public class TransparencyUrlTileProvider implements TileProvider {</p>

<pre><code>private static final String OSM_MAP_URL_FORMAT = "http://tile.openstreetmap.org/%d/%d/%d.png";

private int _transparency; // 透過率(0〜255)
private UrlTileProvider _osmTileProv; // 内包する TileProvider

public TransparencyUrlTileProvider(int width, int height, int transparency) {
    _transparency = transparency;

    _osmTileProv = new UrlTileProvider(width, height) {
        @Override
        public URL getTileUrl(int x, int y, int zoom) {
            String s = String.format(Locale.US, OSM_MAP_URL_FORMAT, zoom, x, y);
            URL url = null;
            try {
                url = new URL(s);
            } catch (MalformedURLException e) {
                throw new AssertionError(e);
            }
            return url;
        }
    };
}

@Override
public Tile getTile(int x, int y, int zoom) {
    Tile tile = _osmTileProv.getTile(x, y, zoom);

    // TODO ここで Tile の透過処理を行う

    return tile;
}
</code></pre>

<p>}
```</p>

<p>使う側は、こんな感じになります。</p>

<p>``` java OsmTileOverlayDemoActivity.java
private GoogleMap mMap;</p>

<p>private void setUpMap() {</p>

<pre><code>// mMap.setMapType(GoogleMap.MAP_TYPE_NONE); ベース地図は消さない

mMap.addTileOverlay(
    new TileOverlayOptions()
    .tileProvider(
        new TransparencyUrlTileProvider(256, 256, 100)));
</code></pre>

<p>}
```</p>

<p>ここまでで改造前と同じく OpenStreetMap が「非透過で」表示されるのは確認できます。</p>

<p>次にいよいよ Bitmap の透過処理です。
まず、Tile から Bitmap を抜き出します。API リファレンスによると、<a href="https://developers.google.com/maps/documentation/android/reference/com/google/android/gms/maps/model/Tile#data">Tile.data</a> というメンバがあるハズが…見つかりません。代わりに <code>Tile.bM</code> という byte[] なメンバがあります。こいつで間違いないでしょう。</p>

<p>Tile.bM の byte[] から Bitmap インスタンスを生成します。</p>

<pre><code>Bitmap bitmap = BitmapFactory.decodeByteArray(tile.bM, 0, tile.bM.length);
</code></pre>

<p>次に透過処理ですが、Android ではちょっと面倒なようです。
以下のサイトを参考にさせて頂いて、関数を作成しました。</p>

<ul>
<li><a href="http://d.hatena.ne.jp/hypercrab/20110730/1312038162">Android: Bitmap の背景を透明にする - 入隠者通信 ～病を嗜む～</a></li>
</ul>


<p>```java makeTransparentBmp.java
private static Bitmap makeTransparentBmp(final Bitmap bmp, int transparency) {</p>

<pre><code> int width = bmp.getWidth(); 
 int height = bmp.getHeight(); 
 int[] pixels = new int[width * height]; 

 Bitmap bitmap = Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888 );
 bmp.getPixels(pixels, 0, width, 0, 0, width, height); 
 for (int y = 0; y &lt; height; y++) { 
   for (int x = 0; x &lt; width; x++) { 
     int pixel = pixels[x + y * width];
     pixels[x + y * width] = Color.argb(transparency, 
             Color.red(pixel), Color.green(pixel), Color.blue(pixel)); 
   } 
 } 
 bitmap.eraseColor(Color.argb(0, 0, 0, 0)); 
 bitmap.setPixels(pixels, 0, width, 0, 0, width, height); 

 return bitmap;
</code></pre>

<p>}
```</p>

<p>では TODO の所に組み込みます。</p>

<p>```java TransparencyUrlTileProvider.java
public class TransparencyUrlTileProvider implements TileProvider {</p>

<pre><code>&lt;前略&gt;

@Override
public Tile getTile(int x, int y, int zoom) {
    Tile tile = _osmTileProv.getTile(x, y, zoom);

    // Tile の透過処理を行う
   Bitmap bmp = BitmapFactory.decodeByteArray(tile.bM, 0, tile.bM.length);
   Bitmap transparentBmp = makeTransparentBmp(bmp, _transparency);

   // Tile を作り直す
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    transparentBmp.compress(CompressFormat.PNG, 100, bos);
    Tile tranparentTile = new Tile(tile.width, tile.height, bos.toByteArray());

    return tranparentTile;
}

&lt;以下略&gt;
</code></pre>

<p>}
```</p>

<p>動かしてみます。</p>

<p><img src="https://dl.dropbox.com/u/264530/qiita/advent2012_osmwithg.png" alt="OpenStreetMap with Google Map API" /></p>

<p>これは、GoogleMap の衛星写真の上に OpenStreetMap を透過して重ねた例です（分かりづらい</p>

<h2>まとめ</h2>

<p>このように Google Maps Android API v2 では、TileProvider を使って、タイル地図画像を簡単に表示させることができます。</p>

<p>Google Maps Javascript API や、MapKit でも他のタイル地図画像を利用することはできましたが、それらよりもより簡単に使えます。ハックというよりも API が公式にサポートしている、という感じです。</p>

<p>これまで Android には、Javascript の OpenLayers や、 iOS の route-me のような、地図タイルデータソースを扱える地図SDKはありませんでした（いや OsmDroid くらいか）</p>

<p>それを Google Maps Android API v2 がサポートしたのですから使わない手はありません。地図SDK としては一番高性能で事実上標準なのですから。</p>

<p>これに、OpenStreetMap や電子国土地図、衛星画像などの背景地図や、統計データメッシュや、アメダスなどの主題図的なタイル地図が重ねられるといろいろできそうだなあ、という感じです。
(Yahoo! さんの<a href="http://weather.yahoo.co.jp/weather/zoomradar/">雨雲レーダー</a> のタイル画像もこっそり試してみて「こりゃ面白い」と思ったので公式に提供して欲しいですｗ)</p>

<p>私にはタイル地図データを作る知識は無いので、タイル地図のポータルみたいなものがあるといいなあと思います。 <a href="https://www.facebook.com/chitaikyo">地図タイル工法協会</a> さんよろしくおねがいします。</p>

<p>というわけで、Android で地図使いたいなら(今のところ) Google Maps API v2 一択！ 他社さんもガンバレ！</p>

<p>※あれ？このネタどこが FOSS4G だ？ま、いっか。</p>
]]></content>
  </entry>
  
</feed>
