<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: reactivex | Experiments Never Fail]]></title>
  <link href="http://blog.amay077.net/blog/categories/reactivex/atom.xml" rel="self"/>
  <link href="http://blog.amay077.net/"/>
  <updated>2016-04-06T22:40:28+09:00</updated>
  <id>http://blog.amay077.net/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RxJava でズンドコキヨシ(window or buffer 使用)]]></title>
    <link href="http://blog.amay077.net/blog/2016/03/13/zundoko-with-rxjava/"/>
    <updated>2016-03-13T23:59:59+09:00</updated>
    <id>http://blog.amay077.net/blog/2016/03/13/zundoko-with-rxjava</id>
    <content type="html"><![CDATA[<p>調子に乗って RxJava でもやってみた。</p>

<!--more-->




<blockquote class="twitter-tweet" data-lang="ja"><p lang="ja" dir="ltr">Javaの講義、試験が「自作関数を作り記述しなさい」って問題だったから<br>「ズン」「ドコ」のいずれかをランダムで出力し続けて「ズン」「ズン」「ズン」「ズン」「ドコ」の配列が出たら「キ・ヨ・シ！」って出力した後終了って関数作ったら満点で単位貰ってた</p>&mdash; てくも (@kumiromilk) <a href="https://twitter.com/kumiromilk/status/707437861881180160">2016年3月9日</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


<ul>
<li><a href="http://qiita.com/amay077/items/85dfc4bd194f57c52c57">C# と Reactive Extensions でズンドコキヨシ</a></li>
</ul>


<p>がんばって <a href="http://reactivex.io/documentation/operators/window.html"><code>Observable.window</code></a> を使ってみた。</p>

<p>```java zondoko.java</p>

<p>// なんちゃってラムダ使用。あと Android。
public void doZondoko() {</p>

<pre><code>final Random random = new Random();
final List&lt;String&gt; PATTERN = Arrays.asList("ずん", "ずん", "ずん", "ずん", "どこ");
final String K = "キ・ヨ・シ！";

Observable.concat( // ※ の Observable&lt;List&lt;String&gt;&gt; を直列に連結
    Observable.interval(500, TimeUnit.MILLISECONDS)
        .map(_ -&gt; random.nextInt(2) == 0 ? "ずん" : "どこ") // ランダムに ずん or どこ
        .window(PATTERN.size(), 1) // 要素数5のWindowを1ずつズラしてく
        .map(window -&gt; window.toList())) // Observable&lt;Observable&lt;String&gt;&gt; を Observable&lt;List&lt;String&gt;&gt; に変換 ※
    .flatMap(window -&gt; {
        if (sequenceEqual(window, PATTERN)) { // パターンと一致していたら…
            final List&lt;String&gt; says = new ArrayList&lt;&gt;();
            says.addAll(window);
            says.add(K);                      // キ・ヨ・シ！を追加
            return Observable.concat(
                    Observable.just(says),
                    Observable.just(Collections.&lt;String&gt;emptyList())); // 終了判定用の空リスト
        } else {
            return Observable.just(window);
        }
    })
    .takeWhile(says -&gt; !says.isEmpty())  // 空リストになるまで繰り返す
    .subscribe(says -&gt; Log.d(TAG, dump(says)));
</code></pre>

<p>}</p>

<p>/<em>* リストとリストの要素一致 </em>/
private boolean sequenceEqual(List<String> listA, List<String> listB) {</p>

<pre><code>Iterator&lt;String&gt; iterA = listA.iterator();
Iterator&lt;String&gt; iterB = listB.iterator();

while (iterA.hasNext() &amp;&amp; iterB.hasNext()) {
    if (iterA.next() != iterB.next()) {
        return false;
    }
}
return (!iterA.hasNext() &amp;&amp; !iterB.hasNext());
</code></pre>

<p>}</p>

<p>/<em>* リスト内容をダンプ </em>/
private String dump(List<String> list) {</p>

<pre><code>final StringBuilder b = new StringBuilder();
for (String s : list) {
    if (!TextUtils.isEmpty(b.toString())) {
        b.append(", ");
    }
    b.append(s);
}

return b.toString();
</code></pre>

<p>}
```</p>

<blockquote><p>どこ, ずん, どこ, どこ, ずん<br/>
ずん, どこ, どこ, ずん, どこ<br/>
どこ, どこ, ずん, どこ, ずん<br/>
どこ, ずん, どこ, ずん, どこ<br/>
ずん, どこ, ずん, どこ, どこ<br/>
どこ, ずん, どこ, どこ, ずん<br/>
ずん, どこ, どこ, ずん, ずん<br/>
どこ, どこ, ずん, ずん, ずん<br/>
どこ, ずん, ずん, ずん, ずん<br/>
ずん, ずん, ずん, ずん, どこ, キ・ヨ・シ！</p></blockquote>

<p>「window(5, 1) &ndash;> toList &ndash;> concat してるならそれは <code>buffer(5, 1)</code> やんけ」というのを <a href="http://qiita.com/do6gop/items/c4941f6fb2bdc1c0c0f1">こちら</a> で知って、 <code>buffer</code> 版も書いてみた。</p>

<p>```java Zondoko_buffer.java
public void doZondoko() {</p>

<pre><code>final Random random = new Random();
final List&lt;String&gt; PATTERN = Arrays.asList("ずん", "ずん", "ずん", "ずん", "どこ");
final String K = "キ・ヨ・シ！";

Observable.interval(500, TimeUnit.MILLISECONDS)
    .map(_ -&gt; random.nextInt(2) == 0 ? "ずん" : "どこ") // ランダムに ずん or どこ
    .buffer(PATTERN.size(), 1) // 要素数5のBufferを1ずつズラしてく
    .flatMap(buf -&gt; {
        if (sequenceEqual(buf, PATTERN)) { // パターンと一致していたら…
            final List&lt;String&gt; says = new ArrayList&lt;&gt;();
            says.addAll(buf);
            says.add(K);                      // キ・ヨ・シ！を追加
            return Observable.concat(
                    Observable.just(says),
                    Observable.just(Collections.&lt;String&gt;emptyList())); // 終了判定用の空リスト
        } else {
            return Observable.just(buf);
        }
    })
    .takeWhile(says -&gt; !says.isEmpty())  // 空リストになるまで繰り返す
    .subscribe(says -&gt; Log.d(TAG, dump(says)));
</code></pre>

<p>}
```</p>

<ul>
<li><a href="http://qiita.com/B73W56H84/items/519e27a1aed5e6d5304f#%E3%81%82%E3%82%8F%E3%81%9B%E3%81%A6%E8%AA%AD%E3%81%BF%E3%81%9F%E3%81%84">さまざまなズンドコキヨシ</a></li>
<li><a href="http://qiita.com/shunsugai@github/items/971a15461de29563bf90">ズンドコキヨシまとめ</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C# と Reactive Extensions でズンドコキヨシ]]></title>
    <link href="http://blog.amay077.net/blog/2016/03/12/zundoko-with-reactive-extensions/"/>
    <updated>2016-03-12T23:59:59+09:00</updated>
    <id>http://blog.amay077.net/blog/2016/03/12/zundoko-with-reactive-extensions</id>
    <content type="html"><![CDATA[<p>流行り？に乗っていくスタイル。</p>

<!--more-->




<blockquote class="twitter-tweet" data-lang="ja"><p lang="ja" dir="ltr">Javaの講義、試験が「自作関数を作り記述しなさい」って問題だったから<br>「ズン」「ドコ」のいずれかをランダムで出力し続けて「ズン」「ズン」「ズン」「ズン」「ドコ」の配列が出たら「キ・ヨ・シ！」って出力した後終了って関数作ったら満点で単位貰ってた</p>&mdash; てくも (@kumiromilk) <a href="https://twitter.com/kumiromilk/status/707437861881180160">2016年3月9日</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>```csharp Zondoko.cs
var random = new Random();
var K = &ldquo;キ・ヨ・シ！&rdquo;;
var PATTERN = new string[] { &ldquo;ずん&rdquo;, &ldquo;ずん&rdquo;, &ldquo;ずん&rdquo;, &ldquo;ずん&rdquo;, &ldquo;どこ&rdquo; };</p>

<p>Observable.Interval(TimeSpan.FromMilliseconds(100))</p>

<pre><code>.Select(_ =&gt; (random.Next() % 2 == 0) ? "ずん" : "どこ") // ランダムに ずんorどこ
.Scan(new List&lt;string&gt;(), (queue, x) =&gt; // 最大５つのQueueに貯める
    {
        queue.Add(x);
        while (queue.Count &gt; PATTERN.Count) { queue.RemoveAt(0);}
        return queue;
    })
.SelectMany(queue =&gt; queue.SequenceEqual(PATTERN) ? // パターンと一致したら…
    Observable.Concat(
        Observable.Return(queue.Last()),   // Queueの最後
        Observable.Return(K),              // + キ・ヨ・シ！
        Observable.Return(string.Empty)) : // + 空文字(終了判定用)
    Observable.Return(queue.Last()))
.TakeWhile(x =&gt; !string.IsNullOrEmpty(x))  // 空文字になるまで繰り返す
.Subscribe(
    x =&gt; Console.WriteLine(x),
    () =&gt; Console.WriteLine("complete!!"));
</code></pre>

<p>```</p>

<blockquote><p>どこ<br/>
どこ<br/>
ずん<br/>
ずん<br/>
ずん<br/>
どこ<br/>
どこ<br/>
どこ<br/>
ずん<br/>
どこ<br/>
ずん<br/>
ずん<br/>
ずん<br/>
ずん<br/>
どこ<br/>
キ・ヨ・シ！<br/>
complete!!</p></blockquote>

<p><code>SelectMany</code> に頼ってるのが気に入らない。。。</p>

<ul>
<li>RxJava 版はこちら &ndash; <a href="http://qiita.com/amay077/items/2c8575753e37fcc94f87">RxJava でズンドコキヨシ(window 使用)</a></li>
<li><a href="http://qiita.com/B73W56H84/items/519e27a1aed5e6d5304f#%E3%81%82%E3%82%8F%E3%81%9B%E3%81%A6%E8%AA%AD%E3%81%BF%E3%81%9F%E3%81%84">さまざまなズンドコキヨシ</a></li>
<li><a href="http://qiita.com/shunsugai@github/items/971a15461de29563bf90">ズンドコキヨシまとめ</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RxJava で Observable の並列処理を直列化する]]></title>
    <link href="http://blog.amay077.net/blog/2016/02/08/serialize-operation-in-rxjava/"/>
    <updated>2016-02-08T01:16:02+09:00</updated>
    <id>http://blog.amay077.net/blog/2016/02/08/serialize-operation-in-rxjava</id>
    <content type="html"><![CDATA[<p><code>rx.Observable&lt;T&gt;</code> のオペレータは、通常は非同期で、並列に処理されます。</p>

<!--more-->


<p>例えば以下のような場合:</p>

<p>```java
public void start() {</p>

<pre><code>Observable.range(1, 5)
    .flatMap(x -&gt; fatTask(x))
    .subscribe(x -&gt; Log.d(TAG, "onNext - " + x));
</code></pre>

<p>}</p>

<p>private final Random rand = new Random();
private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(5);</p>

<p>// ランダムにスリープした後 x を onNext する
private Observable<Integer> fatTask(final int x) {</p>

<pre><code>return Observable.create(subscriber -&gt; {
    long sleep = (long) (rand.nextDouble() * 10000L);
    Log.d(TAG, "fatTask(" + x + ") - start.");

    executor.schedule(() -&gt; {
        subscriber.onNext(x);
        subscriber.onCompleted();
    }, sleep, TimeUnit.MILLISECONDS);
});
</code></pre>

<p>}
```</p>

<p>このプログラムの出力はこうなります。</p>

<blockquote><p>出力:<br/>
fatTask(1) &ndash; start.<br/>
fatTask(2) &ndash; start.<br/>
fatTask(3) &ndash; start.<br/>
fatTask(4) &ndash; start.<br/>
fatTask(5) &ndash; start.<br/>
onNext &ndash; 3<br/>
onNext &ndash; 5<br/>
onNext &ndash; 4<br/>
onNext &ndash; 2<br/>
onNext &ndash; 1<br/></p></blockquote>

<p>fatTask は 1,2,3,4,5 の順で <em>完了を待たずに</em> 呼びだされます。
が、それぞれ処理にかかる時間が異なるので、 <code>onNext</code> が呼ばれる順は 1〜 とは限りません。</p>

<p>ソースとなる Stream の順番を崩したくない場合は、 <code>fatTask(1)</code> が完了してから <code>fatTask(2)</code> を開始する、というように直列化しなければなりません。</p>

<h2>Observable.Concat(concatWith)</h2>

<p>これを行うのが <code>Observable.Concat</code> です(RxJava では <code>Observable.concatWith</code> のようですね)。
複数の <code>Observable</code> を順に（完了してから次へ）処理していきます。</p>

<h3>使い方</h3>

<p><code>toList</code> で一旦ただの <code>List</code> にしてから、<code>concatWith</code> で数珠つなぎにします。</p>

<p>```java
public void start() {</p>

<pre><code>Observable.range(1, 5)
    .toList()
    .flatMap(list -&gt; {
        // fatTask(1).contat(fatTask(2)).contat(fatTask(3))... 
        // にする（fold 使えれば…)
        Observable&lt;Integer&gt; task = null;
        for (int x : list) {
            if (task == null) {
                task = fatTask(x);
            } else {
                task = task.concatWith(fatTask(x));
            }
        }
        return task;
    })
    .subscribe(x -&gt; Log.d(TAG, "onNext - " + x));
</code></pre>

<p>}
```</p>

<p>このプログラムの出力はこうなります。</p>

<blockquote><p>出力<br/>
fatTask(1) &ndash; start.<br/>
onNext &ndash; 1<br/>
fatTask(2) &ndash; start.<br/>
onNext &ndash; 2<br/>
fatTask(3) &ndash; start.<br/>
onNext &ndash; 3<br/>
fatTask(4) &ndash; start.<br/>
onNext &ndash; 4<br/>
fatTask(5) &ndash; start.<br/>
onNext &ndash; 5<br/></p></blockquote>

<p><code>fatTask(1)</code> の完了を待ってから、次の <code>fatTask(2)</code> が実行されています。</p>

<p>※
Rx.NET では、</p>

<p><code>csharp
static IObservable&lt;T&gt; Concat&lt;T&gt;(IEnumerable&lt;IObservable&lt;T&gt;&gt; sources)
</code></p>

<p>で、複数の <code>IObservable</code> を一括で渡せるのですが、 RxJava にはないようで、、、。</p>

<p><code>java
static &lt;T&gt; Observable&lt;T&gt; concatEager(Iterable&lt;? extends Observable&lt;? extends T&gt;&gt; sources)
</code></p>

<p>というのがあったんですが、期待通りうごいてくれず、 Eager? なんでしょう？</p>

<h2>ソースが無限リストだったら？</h2>

<p><code>toList</code> で一旦ただの List にしているのが非常に気に入らないですね。
<code>range(1, 5)</code> が <code>interval(1, TimeUnit.SECONDS)</code> のように無限の Stream だったら使えません。</p>

<p>そこで、 <code>concat</code> には、こんな overload もあります。</p>

<p><code>java
static &lt;T&gt; Observable&lt;T&gt; concat(Observable&lt;? extends Observable&lt;? extends T&gt;&gt; observables)
</code></p>

<p>Observable<T> を通知する Observable？ ややこしいですがこう使います。</p>

<p>```java
public void start() {</p>

<pre><code>// 2. を concat する
Observable.concat( 
    // 1. Observable&lt;Long&gt;
    Observable.interval(1, TimeUnit.SECONDS) 
        // 2. Long を Observable&lt;Integer&gt; に変換 
        //    → Observable&lt;Observable&lt;Integer&gt;&gt; になる
        .map(x -&gt; fatTask(x.intValue()))) 
    .subscribe(x -&gt; Log.d(TAG, "onNext - " + x));
</code></pre>

<p>}
```</p>

<p>このプログラムの出力はこうなります。</p>

<blockquote><p>出力<br/>
fatTask(0) &ndash; start.<br/>
onNext &ndash; 0<br/>
fatTask(1) &ndash; start.<br/>
onNext &ndash; 1<br/>
fatTask(2) &ndash; start.<br/>
onNext &ndash; 2<br/>
…つづく<br/></p></blockquote>

<p>無限リストながら、並列処理せずに順序通り動いてくれます。</p>

<p><code>interval</code> の値を単純に <code>map</code> で <code>Observable&lt;Integer&gt;</code> に変換してやります。するとこれは <code>Observable&lt;Observable&lt;Integer&gt;&gt;</code> になり、<code>concat</code> 可能になります。 <code>flatMap</code> だと平坦化されちゃうのでただの <code>map</code> です。</p>

<h2>まとめ</h2>

<p>Observable は普通は非同期で並列処理。
非同期ながら直列化したい場合は <code>Observable.concat</code> でできます。</p>

<ol>
<li>GPS から緯度経度を取得</li>
<li>なんか重い計算を行う</li>
<li>結果をテキストファイルに書き出す</li>
</ol>


<p>みたいな処理をするとき 3. を 1. の順序と同じにしたいのでこれを使います。</p>

<p>はじめ自分は <code>flatMap</code> で繋いでいくだけですべて直列化されているのかなーと勘違いしていたので、これを知った時は目からウロコでした。</p>

<h2>参考</h2>

<ul>
<li><a href="http://www.introtorx.com/content/v1.0.10621.0/12_CombiningSequences.html">Intro to Rx &ndash; Combining sequences</a></li>
<li><a href="http://reactivex.io/documentation/operators/concat.html">ReactiveX &ndash; Concat operator</a></li>
<li><a href="http://blog.okazuki.jp/entry/20120219/1329663635">Reactive Extensions再入門 その４１「どんどん合成するよ」 &ndash; かずきのBlog@hatena</a></li>
<li><a href="https://twitter.com/neuecc/status/695604984763650050">https://twitter.com/neuecc/status/695604984763650050</a> &ndash; @neuecc さんありがとうございます！</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RxJava の ImmediateScheduler と TrampolineScheduler の違い]]></title>
    <link href="http://blog.amay077.net/blog/2016/02/05/difference-immediatescheduler-and-trumpolinescheduler/"/>
    <updated>2016-02-05T01:30:59+09:00</updated>
    <id>http://blog.amay077.net/blog/2016/02/05/difference-immediatescheduler-and-trumpolinescheduler</id>
    <content type="html"><![CDATA[<p>RxJava のスケジューラの中に <a href="http://reactivex.io/RxJava/javadoc/rx/schedulers/TrampolineScheduler.html"><code>TrampolineScheduler</code></a> というのがあり、<a href="https://twitter.com/amay077/status/693341525464346624">なんじゃこれ？</a>とつぶやいたところ、 <a href="http://reactivex.io/RxJava/javadoc/rx/schedulers/TrampolineScheduler.html">Rx.NET の <code>CurrentThreadScheduler</code> と同じっぽい</a> と教えてもらいました。</p>

<!--more-->


<p>その流れで、類似の Scheduler である <a href="http://reactivex.io/RxJava/javadoc/rx/schedulers/ImmediateScheduler.html">ImmediateScheduler</a> との違いについて語られているトピックを紹介してもらいました。</p>

<blockquote class="twitter-tweet" lang="ja"><p lang="ja" dir="ltr"><a href="https://twitter.com/amay077">@amay077</a> この辺読みとくと良いと思います（tranpolineというキーワードも登場します） <a href="https://t.co/A5TzOiobsC">https://t.co/A5TzOiobsC</a></p>&mdash; Atsushi Eno (@atsushieno) <a href="https://twitter.com/atsushieno/status/693396949643317248">2016, 1月 30</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


<h1>CurrentThreadScheduler vs ImmediateScheduler</h1>

<ul>
<li><a href="https://social.msdn.microsoft.com/Forums/en-US/7f75482f-eff2-4938-9491-47fe870989e8/currentthreadscheduler-vs-immediatescheduler?forum=rx">CurrentThreadScheduler vs ImmediateScheduler</a></li>
</ul>


<p>紹介してもらったこのディスカッションを、頑張って翻訳してみました（めちゃくちゃなとこは訂正願います）。
RxJava では <code>CurrentThreadScheduler</code> を <code>TrampolineScheduler</code> に読み替えてください。</p>

<p>－－訳ここから－－</p>

<h2>Ohad 氏の質問</h2>

<blockquote><p>Hi
ImmediateScheduler&rsquo;s Schedule method is pretty straightforward &ndash; it simply invokes the action.
In contrast, CurrentThreadScheduler seems more involved &ndash; it creates something called a trampoline, which in turn iterates over an action queue, sleeping between invocations of items in the queue and so forth</p></blockquote>

<p>やあ、
<code>ImmediateScheduler.Schedule</code> メソッドは単純をアクションを呼び出します。
対照的に、 <code>CurrentThreadScheduler</code> は複雑に見えます。トランポリンと呼ばれるものを作り、それはアクション・キューで、順次スリープの間に呼び出されます。</p>

<blockquote><p>I&rsquo;ve been trying to follow the code with reflector but I&rsquo;m having a hard time understanding the difference. As far as I can tell, CurrentThreadSchedule&rsquo;s schedule method calls Trampoline &rsquo;s Run method, which will end up blocking the current thread until the queued action is performed (on the current thread as well) &ndash; apparently just like in the case of ImmediateScheduler</p></blockquote>

<p>私はコードを追ってみましたが、理解するのに苦労しています。分かる範囲では、 <code>CurrentThreadSchedule.Schedule</code> メソッドは <code>Trampoline.Run</code> メソッドを呼び出しています。これは現在のスレッドを、キューのアクションが実行されるまで(カレントスレッドも同様に)ブロックしようとします。 &ndash; どうも <code>ImmediateScheduler</code> のようにみえます。</p>

<blockquote><p>I realize I&rsquo;m missing something, so an explanation would be really appreciated
Thanks !</p></blockquote>

<p>何か理解が足りないと思うので、説明してもらえると嬉しいです。</p>

<blockquote><p>EDIT &ndash; In the meantime I&rsquo;ve found a couple of resources that may shed light on the subject, if anyone&rsquo;s interested:</p></blockquote>

<p>２つのリソースを見つけました。何かの手がかりになれば。</p>

<p><a href="http://channel9.msdn.com/blogs/j.van.gogh/controlling-concurrency-in-rx">http://channel9.msdn.com/blogs/j.van.gogh/controlling-concurrency-in-rx</a></p>

<p><a href="http://community.bartdesmet.net/blogs/bart/archive/2009/11/08/jumping-the-trampoline-in-c-stack-friendly-recursion.aspx">http://community.bartdesmet.net/blogs/bart/archive/2009/11/08/jumping-the-trampoline-in-c-stack-friendly-recursion.aspx</a></p>

<h2>Dave 氏の回答</h2>

<blockquote><p>Hi,</p>

<p>The trampoline seems to serve three purposes:</p></blockquote>

<p>やあ、
トランポリンは３つの目的を持っているように見えます。</p>

<blockquote><p>1- Prevents dead-locks from scheduler reentrancy.</p></blockquote>

<p>1- スケジューラーの割り込みからデッドロックを防ぎます。</p>

<blockquote><p>2- Prevents infinite loops in observables that require recursion through scheduler reentrancy.</p></blockquote>

<p>2- スケジューラーの割り込みを使った再帰が必要な Observable の無限ループを防ぎます。</p>

<blockquote><p>3- Cooperative single-threaded multitasking; I guess it&rsquo;s similar to the proposed async/await feature in C# 5.0.  Calling CurrentThreadScheduler.Schedule is sort of like using await when the currently executing code was also scheduled via CurrentThreadScheduler.</p></blockquote>

<p>3- シングルスレッドでの「<a href="http://www.sophia-it.com/content/%E3%83%8E%E3%83%B3%E3%83%97%E3%83%AA%E3%82%A8%E3%83%B3%E3%83%97%E3%83%86%E3%82%A3%E3%83%96%E3%83%9E%E3%83%AB%E3%83%81%E3%82%BF%E3%82%B9%E3%82%AF">協調的マルチタスキング</a>」; 私は C# 5.0 に提案されている async/await に近いものだと思います。<code>CurrentThreadScheduler.Schedule</code> の呼び出しは、現在実行中のコードも <code>CurrentThreadScheduler</code> でスケジュールされていたときに await を使用するようなものです。（訳注: C# の async/await は協調的マルチタスキングではないと思います。これは async/await 登場以前に予想で書かれたものかと。</p>

<blockquote><p>In the observable world, calling Subscribe should be an asynchronous operation.  There&rsquo;s a problem if the scheduling of an observable dead-locks or blocks the current thread indefinitely because it attempts to execute immediately and never completes.</p></blockquote>

<p>Observable の世界では、<code>Subscribe</code> の呼び出しは、非同期処理で行わなければなりません。Observable のスケジューリングがデッドロックまたはカレントスレッドを無期限にブロックする場合、すぐに実行しようとしても完了しないので、問題になります。</p>

<blockquote><p>Ignore the type of scheduler for a moment and consider a scheduled action that eventually, through some sequence of method calls, uses the same scheduler to schedule another action.</p></blockquote>

<p>ちょっとこのスケジューラを無視して、いずれは、いくつかのシーケンスは別のアクションをスケジュールするために、同じスケジューラを使用することを考えてみてください。</p>

<blockquote><p>With the ImmediateScheduler, the inner action is executed immediately.</p></blockquote>

<p><code>ImmediateScheduler</code> では、”内側のアクション” はすぐに実行されます。</p>

<blockquote><ul>
<li>If the outer action acquires some resource on which the inner action depends, and the inner action cannot acquire this resource until it&rsquo;s released by the outer action, then these actions dead-lock.</li>
</ul>
</blockquote>

<ul>
<li>外側のアクションが、内側のアクションが依存しているリソースを取得した場合、
内側のアクションは外側のアクションがリソースを開放するまでそれを取得できず、これらのアクションはデッドロックします。</li>
</ul>


<blockquote><ul>
<li>If the outer action depends upon the inner action, and the inner action depends upon the outer action, then this could result in an infinite loop that never yields control to other actions.</li>
</ul>
</blockquote>

<ul>
<li>外側のアクションは内部アクションに依存し、内部アクションは外側の行動に依存している場合、他のアクションに制御が移らない無限ループになります。</li>
</ul>


<blockquote><p>For example: Observable.Return(1).Repeat().Take(1)</p></blockquote>

<p>例: <code>Observable.Return(1).Repeat().Take(1)</code></p>

<blockquote><p>By default, Return uses the ImmediateScheduler to call OnNext(1) then OnCompleted().  Repeat does not introduce any concurrency, so it sees OnCompleted immediately and then immediately resubscribes to Return.  Because there&rsquo;s no trampoline in Return, this pattern repeats itself, blocking the current thread indefinitely.  Calling Subscribe on this observable never returns.  See <a href="https://social.msdn.microsoft.com/Forums/en-US/f9c1a7a6-d6a3-44fd-ba8c-e6845b1717b2/possible-bug-repeat-observables-using-immediate-scheduler?forum=rx">this discussion</a> for more information.</p></blockquote>

<p>既定では、<code>Return</code> は <code>ImmediateScheduler</code> を使って <code>OnNext(1)</code> そして <code>OnCompleted()</code> を呼び出します。 <code>Repeat</code> はどんな並列性も使用しません、なのですぐに <code>OnCompleted</code> を検知して、すぐに <code>Return</code> を再購読します。なぜなら、 <code>Return</code> にはトランポリンがないので、このパターンは自分自身を繰り返し、無期限に現在のスレッドをブロックし続けます。この Observable を <code>Subscribe</code> すると処理が返ってきません。詳細については、<a href="https://social.msdn.microsoft.com/Forums/en-US/f9c1a7a6-d6a3-44fd-ba8c-e6845b1717b2/possible-bug-repeat-observables-using-immediate-scheduler?forum=rx">この説明</a>を参照してください。</p>

<blockquote><p>With the CurrentThreadScheduler, the inner action is scheduled (queued) for execution when the outer action ends.  Conceptually, inner actions are bounced on the trampoline until the current thread is ready to execute them.</p></blockquote>

<p><code>CurrentThreadScheduler</code> では、内側のアクションは、外側のアクションが終了された時に実行されるようにスケジュールされます。コンセプトとしては、内側のアクションは、現在のスレッドが実行可能になるまでトランポリンの上で跳ねます。</p>

<blockquote><ul>
<li>If the outer action acquires some resource on which the inner action depends, and the inner action cannot acquire this resource until it&rsquo;s released by the outer action, then these actions do not dead-lock because the inner action is not executed until the outer action completes.</li>
</ul>
</blockquote>

<ul>
<li>外側のアクションが、内側のアクションが依存しているリソースを取得し、内側のアクションは外側のアクションによってそれらが解放されるまで取得できない場合、これらのアクションはデッドロックしません、なぜなら。内側のアクションは外側のアクションが終了するまで実行されないためです。</li>
</ul>


<blockquote><ul>
<li>If the outer action recurses when the inner action completes, then there won&rsquo;t be an immediately infinite loop because the inner action does not complete until the outer action completes first.</li>
</ul>
</blockquote>

<ul>
<li>外側のアクションが内側のアクションが終了した時に再帰的な場合、無限ループになりません。なぜなら、内側のアクションは外側のアクションが完了するまで完了しないためです。</li>
</ul>


<blockquote><p>For example: Observable.Return(1, Scheduler.CurrentThread).Repeat().Take(1)</p></blockquote>

<p>例: <code>Observable.Return(1, Scheduler.CurrentThread).Repeat().Take(1)</code></p>

<blockquote><p>Here, Return is using the CurrentTheadScheduler to call OnNext(1) then OnCompleted().  Repeat does not introduce any concurrency, so it sees OnCompleted immediately and then immediately resubscribes to Return; however, this second subscription to Return schedules its (inner) actions on the trampoline because it&rsquo;s still executing on the OnCompleted callback from the first scheduled (outer) action, thus the repetition does not occur immediately.  This allows Repeat to return a disposable to Take, which eventually calls OnCompleted, cancels the repetition by disposing Repeat, and ultimately the call from Subscribe returns.</p></blockquote>

<p>ここでは、 <code>Return</code> は <code>CurrentTheadScheduler</code> を使って <code>OnNext(1)</code> そして <code>OnCompleted()</code> を呼び出します。 <code>Repeat</code> はどんな並列性も使用しません、なのですぐに <code>OnCompleted</code> を検知して、すぐに <code>Return</code> を再購読します。しかし、この２回目の <code>Return</code> の購読（内側のアクション）はトランポリンの上にあります、なぜなら、最初にスケジュールされたアクション（外側のアクション）の <code>OnCompleted</code> コールバックの上でまだ実行中であるからです、なので繰り返しはすぐに発生しません。
これは、<code>Repeat</code> は <code>Take</code> に disposable(subscription) を返すことができます、それはやがて <code>OnCompleted</code> を呼び出し、<code>Subscribe</code> の返値から <code>Repeat</code> の破棄により繰り返しをキャンセルします。</p>

<blockquote><p>Keep in mind that the examples with Return and Repeat do not introduce any concurrency.  When you call Subscribe, it will not return until the observable completes regardless of which of these schedulers you choose.  With the ImmediateScheduler, Take calls OnCompleted but it cannot cancel the repetition, so Subscribe blocks indefinitely.  Alternatively, the CurrentThreadScheduler allows for cooperative single-threaded multitasking between the Return and Repeat operators, thus allowing Take to cancel the repetition without having to introduce any concurrency.</p></blockquote>

<p>覚えておいて欲しいのは、 <code>Return</code> → <code>Repeat</code> はどんな並列性も使用しないことです。<code>Subscribe</code> を呼び出すと、あなたが選択した Scheduler に関係なく、Observable が終了するまで処理を返しません。 <code>ImmediateScheduler</code> では、<code>Take</code> は <code>OnCompleted</code> を呼び出しますが、繰り返しをキャンセルできません。なので <code>Subscribe</code> は無期限にブロックしてしまいます。代わりに <code>CurrentThreadScheduler</code> は <code>Return</code> と <code>Repeat</code> 操作の間、協調的マルチタスキングが可能になります、なので、並行性を使用することなく、繰り返しをキャンセルすることができます。</p>

<p>－－訳ここまで－－</p>

<h1>つまり？</h1>

<p><code>ImmediateScheduler</code> が処理をただ単に(割り込んで)実行するだけであるのに対し、 <code>CurrentScheduler</code>(<code>TrampolineScheduler</code>) は、擬似的なマルチタスクを行う（懐かしの VB の <a href="http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1112681621"><code>DoEvents</code></a> かぁ？）ことでデッドロックを防いでいる、と理解しました。</p>

<p>Dave 氏の回答にあった例</p>

<p><code>csharp
Observable.Return(1).Repeat().Take(1).Subscribe(...);
Debug.WriteLine("Hoge");
</code></p>

<p>を実行すると、確かに処理が帰ってこない、<code>Debug.WriteLine</code> へ進まないんです。</p>

<p>これはヤバい、<code>ImmediateScheduler</code> マジやべえと。
で、 RxJava でも同じだよねえと、</p>

<p><code>java
// just が ImmediateScheduler 使うのか不安だったから subscribeOn しているよ
Observable.just(1).subscribeOn(Schedulers.immediate()).repeat().take(1).subscribe(...);
Log.debug(TAG, "Hoge");
</code></p>

<p>と書いて実行してみたら、処理が帰ってくる！ <code>Log.debug</code> も実行される！
なんだこの違いは？改善されているのか、試し方が悪いのか。。。</p>

<p>なんだかモヤモヤした終わりかたですが、今回は <code>ImmediateScheduler</code> はちょっと要注意だというところまでです。</p>

<blockquote><p>In the observable world, calling Subscribe should be an asynchronous operation.</p></blockquote>

<p>との言葉通り、Rx.NET/RxJava を使うときは非同期にしたい事が全てだと思いますが、オペレータによっては既定で <code>ImmediateScheduler</code> を使うものもあるので、必ず <code>subscribeOn/observeOn</code> をするクセをつけておいた方がいいのかな？と思いました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Task→Observable 変換でハマったこと]]></title>
    <link href="http://blog.amay077.net/blog/2016/01/16/misunderstood-task-to-observable-conversion/"/>
    <updated>2016-01-16T23:59:59+09:00</updated>
    <id>http://blog.amay077.net/blog/2016/01/16/misunderstood-task-to-observable-conversion</id>
    <content type="html"><![CDATA[<p>.NET の <code>Task&lt;T&gt;</code> は、Reactive Extensions が提供する拡張メソッド <code>ToObservable()</code> で <code>IObservable&lt;T&gt;</code> に変換できます。</p>

<p>なにも考えずに <code>ToObservable()</code> を連発していたら、盛大にハマったのでメモ。</p>

<!--more-->


<h2>Task.Run().ToObservable() とか、意味ないっしょ</h2>

<p>ダメなコード。</p>

<p>```csharp
var i = 0;
IObservable<int> incrementObservable = Task.Run (() => {</p>

<pre><code>i++;
Debug.WriteLine($"increment! - {i}");
return i;
</code></pre>

<p>})
.ToObservable ();</p>

<p>Debug.WriteLine(&ldquo;Ready&hellip;&rdquo;);</p>

<p>incrementObservable // インクリメント</p>

<pre><code>.Repeat(3) // ３回繰り返す
.Subscribe(
    x  =&gt; Debug.WriteLine($"OnNext({x})"),
    ex =&gt; Debug.WriteLine($"OnError({ex.ToString()})"),
    () =&gt; Debug.WriteLine("OnCompleted"));
</code></pre>

<p>```</p>

<p><code>incrementObservable</code> は、副作用ありありですが、外部変数 i を +1 して後続に流す <code>IObservable&lt;int&gt;</code> です。
　これを <code>.Repeat(3)</code> して <code>.Subscribe</code> してますから、
　</p>

<blockquote><p>Ready&hellip;
increment! &ndash; 1
OnNext(1)
increment! &ndash; 2
OnNext(2)
increment! &ndash; 3
OnNext(3)
OnCompleted</p></blockquote>

<p>という出力を期待してました。
が、実際の出力はこう。</p>

<blockquote><p>increment! &ndash; 1
Ready&hellip;
OnNext(1)
OnNext(1)
OnNext(1)
OnCompleted</p></blockquote>

<p>Subscribe する前に Task が実行されてるし、 repeat してるのに increment されない。。。</p>

<p>「・・・ん？ Task.Run().ToObservable() って、タスクを実行した結果を IObservable 化してるだけじゃね？」</p>

<p>コード見たまんまなんですが、これに気づくのに１時間かかりました。。。</p>

<p>期待通り動くのはこう↓。</p>

<p>```csharp
var i = 0;
IObservable<int> incrementObservable = Observable.FromAsync(()=>Task.Run(() => {</p>

<pre><code>i++;
Debug.WriteLine($"increment! - {i}");
return i;
</code></pre>

<p>}));</p>

<p>Debug.WriteLine(&ldquo;Ready&hellip;&rdquo;);</p>

<p>incrementObservable // インクリメント</p>

<pre><code>.Repeat(3) // ３回繰り返す
.Subscribe(
    x  =&gt; Debug.WriteLine($"OnNext({x})"),
    ex =&gt; Debug.WriteLine($"OnError({ex.ToString()})"),
    () =&gt; Debug.WriteLine("OnCompleted"));
</code></pre>

<p>```</p>

<p><code>Observable.FromAsync</code> で Task の実行そのものを IObservable 化します。
これの結果は正しくこう↓なりました。</p>

<blockquote><p>Ready&hellip;
increment! &ndash; 1
OnNext(1)
increment! &ndash; 2
OnNext(2)
increment! &ndash; 3
OnNext(3)
OnCompleted</p></blockquote>

<h2>Task は１回しか実行できない</h2>

<p>ところで、 <code>Task&lt;T&gt;</code> は一度実行すると、２度目は実行できません。（Furure や Promise もそうだっけ）</p>

<p>```csharp
var i = 0;
Task<int> incrementTask = new Task<int>(() => {</p>

<pre><code>i++;
Debug.WriteLine($"increment! - {i}");
return i;
</code></pre>

<p>});</p>

<p>incrementTask.RunSynchronously();
incrementTask.RunSynchronously();
```</p>

<p>このコードは２回目の <code>RunSynchronously()</code> で例外がでます。</p>

<p>となると、 <code>incrementTask.ToObservable()</code> したとしても、期待通り動いてくれなさそうです。
（そもそも Task は <code>Start</code> などしないと実行されないので、Observable のチェインの中でいつ呼ぶの？）</p>

<p>というわけで、 <code>Task.ToObservable()</code> は、どういう時に使えばいいのかよくわかりませんでした。だれか教えて下さい。（汗）</p>
]]></content>
  </entry>
  
</feed>
