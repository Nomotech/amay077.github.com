<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ReactiveExtensions | Experiments Never Fail]]></title>
  <link href="http://amay077.github.io/blog/categories/reactiveextensions/atom.xml" rel="self"/>
  <link href="http://amay077.github.io/"/>
  <updated>2014-07-07T15:26:19+09:00</updated>
  <id>http://amay077.github.io/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rx で Chain of Responsibility]]></title>
    <link href="http://amay077.github.io/blog/2014/05/13/chain-of-resposibility-using-rx/"/>
    <updated>2014-05-13T15:24:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/05/13/chain-of-resposibility-using-rx</id>
    <content type="html"><![CDATA[<p>今さらだけど GoF の Chain of Responsibility パターン。「自分に処理できないタスクは上へ投げる」ってやつ。Reactive な感じでやるとこんな感じかなあと思って書いてみた。</p>

<!--more-->


<p>```csharp
void Main()
{</p>

<pre><code>var document = "有給届";

var kakariCho = CreateManager("係長", document, d =&gt; String.Equals(document, "遅刻届"));
var kaCho = CreateManager("課長", document, d =&gt; String.Equals(document, "有給届"));
var buCho = CreateManager("部長", document, d =&gt; String.Equals(document, "退職届"));

Observable.Concat(new [] { 
    kakariCho,  // 係長
    kaCho,      // 課長
    buCho       // 部長
})
.FirstOrDefault() // 最初の１人に承認されたら終了
.Timeout(TimeSpan.FromDays(1)) // 猶予１日
.Subscribe(x =&gt; Debug.WriteLine(String.IsNullOrEmpty(x) 
    ? "あなたの届書は却下されました" 
    : x + "が承認しました"));
</code></pre>

<p>}</p>

<p>/// 管理職を作成する（役職名、渡された届書、自分に承認できる届書）
IObservable<string> CreateManager(string managerTitle, string document, Predicate<string> canIAccept)
{</p>

<pre><code>return Observable.Create&lt;string&gt;(o =&gt; Task.Run(() =&gt; 
{
    if (canIAccept(document)) 
    {
        o.OnNext(managerTitle); // 承認
    }
    o.OnCompleted();
}));
</code></pre>

<p>}
```</p>

<p>管理職の人を <code>IObservable</code> に見立てて、自分が処理できるなら <code>OnNext</code> を呼ぶ、処理できないなら <code>OnNext</code> は呼ばずに <code>OnComplete</code> しちゃう。
で、係長・課長・部長の IObservable を <code>Concat</code> で役職の低い順につなげて、 <code>FirstOrDefault()</code> で最初の承認がもらえるまで待つ、みたいな。</p>

<p>係長・課長・部長が誰も承認しなかった時、タイムアウトするまで待ちが発生しちゃうのが難点。→ <code>Take(1)</code> じゃなくて <code>FirstOrDefault</code> すればいいみたい。誰も承認しなかった場合 <code>default(string)</code> つまり空文字が流れてくる。</p>

<p>あと、係長→課長→部長と管理職のハンコリレーが必要な場合に対応できていない、Concat なので係長の結果を課長に引き継いでないから。</p>

<p>んーどうしようか。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.iOS で FromEventPattern を使うときの注意点]]></title>
    <link href="http://amay077.github.io/blog/2014/04/03/notice-for-fromeventpattern-in-xamarin-ios/"/>
    <updated>2014-04-03T15:29:00+09:00</updated>
    <id>http://amay077.github.io/blog/2014/04/03/notice-for-fromeventpattern-in-xamarin-ios</id>
    <content type="html"><![CDATA[<p>Reactive Extensions の <code>FromEventPattern</code> を使うと、イベントを <code>IObservable</code> に変換できて、複数のイベントに時系列な関係を与えたり、他のストリーム処理とシームレスに扱えたりします。</p>

<!--more-->


<ul>
<li><a href="http://www.atmarkit.co.jp/fdotnet/introrx/introrx_02/introrx_02_02.html">イベント・プログラミングとRx － ＠IT</a></li>
</ul>


<p>Xamarin .iOS でも .Android でもこの機能を使うことができて大変便利ですが、Xamarin.iOS の場合 AOT による制限に気をつける必要があります。</p>

<p>以下は、なんの変哲もない、「ボタンを押したらタイトルを ”Clicked!” に変える」コードです。</p>

<p><code>csharp
MyButton.TouchUpInside += (s, e) =&gt; MyButton.SetTitle("Clicked!", UIControlState.Normal);
</code></p>

<p>これを FromEventPattern を使うとこう書けます。</p>

<p><code>csharp DoesNotWorkOnDevice.cs
Observable.FromEventPattern(MyButton, "TouchUpInside")
.Subscribe(x =&gt; MyButton.SetTitle("Clicked!", UIControlState.Normal));
</code></p>

<p>このコード、iOSシミュレータでは正常に動作しますが、 <strong>実機では、ビルドは通りますが動作しません。</strong> 実行時にこんなエラーがでます。</p>

<blockquote><p>System.InvalidOperationException: Could not find event 'TouchUpInside' on object of type 'MonoTouch.UIKit.UIButton'.</p></blockquote>

<p><code>TouchUpInside</code> が無いと言われます。</p>

<p>これは AOT により生成されたコードに、このイベントが含まれないのだと推測します。イベント名を文字列リテラルで指定しているので、そこまでの解析は期待できないですよね。</p>

<p>シミュレータで動作したのは、この場合は AOT でなく JIT で動作しているため。以下でも言及されています。</p>

<ul>
<li><a href="http://www.buildinsider.net/mobile/insidexamarin/05">Xamarin.iOSの仕組みとアプリケーションの構成 - Build Insider</a></li>
</ul>


<blockquote><p>対象がiOSシミュレーターである場合と、iOSデバイスである場合とで、大きく異なる。iOSシミュレーターは、エミュレーターではなく、あくまでMac OS Xが動作しているx86 CPUの上で動作している仮想マシンであり、アプリケーションはJITによって動作する。iOSデバイスはARMであり、iOSデバイス用にビルドされたアプリケーションはAOTによってARMのCPU命令に変換されており、ARM上でしか動作しない。</p></blockquote>

<p>Xamarin.iOS では実機で動作させないと安心ならないと言われる所以です。</p>

<p>さて、このケースでは、FromEventPattern の別なオーバーロードを使うことで解決です。</p>

<p><code>csharp WorkOnDevice.cs
Observable.FromEventPattern(
  h =&gt; MyButton.TouchUpInside+=h,
  h =&gt; MyButton.TouchUpInside-=h)
.Subscribe(x =&gt; MyButton.SetTitle("Clicked!", UIControlState.Normal));
</code></p>

<p>Xamarin.iOS の制限事項は以下に。</p>

<ul>
<li><a href="http://docs.xamarin.com/guides/ios/advanced_topics/limitations/">Limitations | Xamarin</a></li>
</ul>


<p>これまでこの制限に引っかかった事がなかったのですが、初めて引っかかりました。</p>

<p>メソッドを文字列リテラルで書いた時点で私の負けです、本当にありがとうございました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin に Reactive Extensions を導入する]]></title>
    <link href="http://amay077.github.io/blog/2013/12/12/installing-rx-in-xamarin/"/>
    <updated>2013-12-12T00:00:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/12/12/installing-rx-in-xamarin</id>
    <content type="html"><![CDATA[<p>昨日の <a href="http://qiita.com/amay077/items/49681b2de5d8cf208112">ポスト</a> を使ったのに、肝心の導入部分を説明するのを忘れていました。まあ Components から追加するだけなのですが。他のアドベントカレンダーとの掛け持ちで疲れたので、今日は軽く書いて済ませます。</p>

<!--more-->


<h2>Reactive Extensions を導入する</h2>

<p>Components で右クリック → Get more components → Reactive とかで検索 → 見つけたら Add to App で OK です。あ、この手順は .iOS でも .Android でも同じです。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/install_rx_to_xamarin_ios_01.gif" alt="" /></p>

<h2>使ってみましょうか</h2>

<p>イベントを Stream に変換する例を示してお茶を濁します。</p>

<p>まずこんな感じのどうでもいい画面を用意しまして、</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/install_rx_to_xamarin_ios_02.png" alt="" /></p>

<p><code>UIButton.TouchUpInside</code> を <code>IObservable</code> に変換する拡張メソッドを用意します。</p>

<p>```csharp UIButtonExtensions.cs
public static class UIButtonExtensions
{</p>

<pre><code>public static IObservable&lt;string&gt; ClickAsObservable(this UIButton button)
{
    return Observable.FromEventPattern&lt;EventArgs&gt;(button, "TouchUpInside")
            .Select(e =&gt; ((UIButton)e.Sender).TitleLabel.Text);
}
</code></pre>

<p>}
```</p>

<p>で、こんなコードを書きます。</p>

<p>```csharp MainViewController_amb.cs
public override void ViewDidLoad()
{</p>

<pre><code>base.ViewDidLoad();

Button1.ClickAsObservable()
    .Publish(_ =&gt; 
        Button2.ClickAsObservable()
        .Amb(
            Button3.ClickAsObservable()))
    .Subscribe(btnName =&gt; InvokeOnMainThread(() =&gt; 
        Label1.Text = btnName + " Clicked"));
</code></pre>

<p>}
```</p>

<h3>Observable.Amb (先にきた値を流す)</h3>

<p>Button1 を押すと処理の開始です。
Publish で分配して <strong>Amb</strong> は Button2 のクリックと Button3 のクリックで先に行われた方を Label1 に表示します。</p>

<h3>Observable.Zip (どちらの値も待つ)</h3>

<p>Amb を Zip に変えてみます。</p>

<p>```csharp MainViewController_zip.cs</p>

<pre><code>Button1.ClickAsObservable()
    .Publish(_ =&gt; 
        Button2.ClickAsObservable()
        .Zip(
            Button3.ClickAsObservable(), (l,r) =&gt; new {l, r}))
    .Subscribe(p =&gt; InvokeOnMainThread(() =&gt; 
        Label1.Text = p.l + " and " + p.r + "Clicked"));
</code></pre>

<p>```</p>

<p>Zip は2つのシーケンスの結果を待ってから後続へ流します。
なので、Button2 と Button3 の両方が押されると、Label1 に表示されます。</p>

<p>どちらもフツーに書くとフラグ変数なんか使って実現すると思うんですけど、Rx を使うと読みやすいコードになると思います。</p>

<p>あと、私は Android-Java の開発では <a href="https://code.google.com/p/reactive4java/">reactive4Java</a> を使ってるんですが、あれには <code>Observable.FromEventPattern</code> が無い(Java のイベントの Listener はイベントのマルチキャストに対応してないから仕方ない)ので、Xamarin にすることで「完全な」Rx を使うことができて、こりゃ勉強のしがいがあるなあと思ったのでした。</p>

<p>何の記事でしたっけ？という感じですけど Xamarin なら Linq も Rx も使えてハッピーという事で、今日は以上です。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.Android で GPS を使う(Reactive Extensions版)]]></title>
    <link href="http://amay077.github.io/blog/2013/03/17/xamarin-android-using-gps-by-rx/"/>
    <updated>2013-03-17T00:42:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/03/17/xamarin-android-using-gps-by-rx</id>
    <content type="html"><![CDATA[<p>RxM4A により <a href="http://amay077.github.com/blog/2013/03/01/how-to-use-rx-in-xamarin/">Reactive Extensions が使えるようになった</a> ので、以前に <a href="http://amay077.github.com/blog/2012/10/03/locate-using-reactive4java/">Android+reactive4Java でやったコレ</a> を Xamarin.Android でやってみます。</p>

<!--more-->


<p>```c# LocationManager.Extenstion.cs
namespace Amay077.Android.Locations
{</p>

<pre><code>static class LocationManagerExtenstion
{
    // 渡した Action&lt;Location&gt; を OnLocationChanged で実行されるようにしただけ
    class LocationListener : Java.Lang.Object, ILocationListener
    {
        private readonly Action&lt;Location&gt; _locationChangedHandler;

        public LocationListener(Action&lt;Location&gt; locationChangedHandler)
        {
            _locationChangedHandler = locationChangedHandler;
        }

        #region ILocationListener implementation
        public void OnLocationChanged(Location location)
        {
            _locationChangedHandler(location);
        }

        public void OnProviderDisabled(string provider) { }
        public void OnProviderEnabled(string provider) { }
        public void OnStatusChanged(string provider, Availability status, Bundle extras) { }
        #endregion
    }

    public static IConnectableObservable&lt;Location&gt; RequestLocationAsObservable(
        this LocationManager locMan,
        string provider)
    {
        return Observable.Create&lt;Location&gt;(o =&gt; 
        {
            try {
                var isStop = false; // RemoveUpdates してもすぐ止まるか分からんので一応フラグ持っとく

                var listener = new LocationListener(l =&gt; 
                {
                    if (isStop) return;
                    o.OnNext(l);
                });

                // 位置取得開始
                locMan.RequestLocationUpdates(provider, 0, 0, listener);

                return () =&gt; // Dispose() した時に停止
                {
                    if (isStop) return;
                    isStop = true;
                    locMan.RemoveUpdates(listener);
                    o.OnCompleted();
                };

            } catch (Exception ex) {
                o.OnError(ex);
                return () =&gt; { /* empty */ };
            }
        }).Publish(); // Hot な Observable に
    }
}
</code></pre>

<p>}
```</p>

<p><code>LocationManager</code> の拡張メソッドにしたいので、クラス名を慣例に習って <code>LocationManager.Extenstion.cs</code> に、メソッド <code>RequestLocationAsObservable</code> の第一引数に <code>this</code> を付けてます。</p>

<p><code>LocationListener</code> Inner クラスは、C# では匿名クラスが使えないので、コンストラクタで指定した <code>Action</code> が <code>OnLocationChanged</code> で呼ばれるようにしただけです。</p>

<p><code>RequestLocationAsObservable</code> メソッドがメイン。やってることは reactive4Java と同じです。Hot な Observable にしたので、最後に <code>.Publish()</code> してるので、返値が <code>IConnectableObservable</code> になってます。</p>

<p>さて使う方。</p>

<p>```c# Howtouse.cs
using Amay077.Android.Locations; // 拡張メソッドを使えるように</p>

<p>&lt;省略></p>

<p>// LocationManager を得る
var locationMan = (LocationManager)context.GetSystemService(Context.LocationService);
// RequestLocationAsObservable があたかも LocationManager のメンバのよ(ry
var observable = locationMan.RequestLocationAsObservable(LocationManager.GpsProvider);
observable.Take(3) // 3回取得
.Timeout(new TimeSpan(10000)) // 10秒待って取得できなかったらタイムアウト
.Subscribe(</p>

<pre><code>l =&gt; { Android.Util.Log.Debug(TAG, 
          String.Format("received: {0}/{1}", 
            l.Latitude, l.Longitude)); }, // 位置が取得される度に呼ばれる
e =&gt; Android.Util.Log.Debug(TAG, "error:" + e.Message), // エラー(タイムアウト含む)の時呼ばれる
() =&gt; Android.Util.Log.Debug(TAG, "finished.")); // 全部終わったら呼ばれる
</code></pre>

<p>observable.Connect(); // 接続開始
```</p>

<p>Reactive Extensions と C# の拡張メソッドなどのおかげで、Java よりもずいぶんとすっきり書けました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.Android で Reactive Extensions を使う]]></title>
    <link href="http://amay077.github.io/blog/2013/03/01/how-to-use-rx-in-xamarin/"/>
    <updated>2013-03-01T17:38:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/03/01/how-to-use-rx-in-xamarin</id>
    <content type="html"><![CDATA[<p>なんか一気にハードル上がったような。。。</p>

<!-- more -->


<p>Reactive Extensions(Rx) については、</p>

<ul>
<li><a href="http://www.atmarkit.co.jp/fdotnet/introrx/introrx_01/introrx_01_01.html">Reactive Extensionsの概要と利用方法 － ＠IT</a></li>
</ul>


<p>などを読んで頂くとして、Rx は昨年 <a href="http://www.infoq.com/jp/news/2012/11/rx-net-open-source">オープンソース化され</a>、本家を Mono for Android で使えるようにした</p>

<ul>
<li><a href="http://rxm4a.codeplex.com/">RxM4A - Mono For Android Reactive Extensions</a></li>
</ul>


<p>というプロジェクトがあります。
Mono で使えるということは Xamarin でももちろん…ということで使ってみます。</p>

<h2>サンプルアプリケーションを作る</h2>

<p>とりあえず Xamarin.Android で "XamarinAndroidRxSample" というプロジェクトを作りました。</p>

<h2>RxM4A のソースを Clone する</h2>

<p>上記のサイトからソースを取得します。以下のコマンドでもおｋ(要git)</p>

<blockquote><p>$git clone https://git01.codeplex.com/rxm4a</p></blockquote>

<h2>ソリューションにプロジェクトを追加する</h2>

<p>ソリューションツリーのソリューションのところで右クリック→追加→既存のプロジェクトを追加</p>

<p><img src="https://dl.dropbox.com/u/264530/qiita/xamarin_android_rxm4a.png" alt="&quot;add_project&quot;" /></p>

<p>で、先ほど取得した RxM4A のディレクトリへ移動します。</p>

<p><img src="https://dl.dropbox.com/u/264530/qiita/xamarin_android_rxm4a_projects.png" alt="&quot;projects&quot;" /></p>

<p>RxMonoForAndroid の中から以下のプロジェクトを追加します。</p>

<ul>
<li>System.Reactive.Interfaces</li>
<li>System.Reactive.Core</li>
<li>System.Reactive.Linq</li>
</ul>


<p>フォルダを掘ってくと xxx.csproj ってファイルがあるので、それを選択します。
依存関係があるので、上記の順番通りやらないとなにかエラーが出ますが、最終的に３つ揃えば問題ないでしょう。</p>

<h2>参照を追加する</h2>

<p>XamarinAndroidRxSample から、今追加した３つのプロジェクトを参照に追加します。</p>

<p>ソリューションツリーの XamarinAndroidRxSample のところで右クリック→参照アセンブリの追加 から、</p>

<p><img src="https://dl.dropbox.com/u/264530/qiita/xamarin_android_rxm4a_add_reference.png" alt="&quot;add_project_reference&quot;" />
<img src="https://dl.dropbox.com/u/264530/qiita/xamarin_android_rxm4a_add_reference2.png" alt="&quot;add_project_reference&quot;" /></p>

<p>ダイアログのタブで Projects を選ぶと３つ出てくるのでチェックをいれて OK してください。</p>

<h2>Reactive Extensions を使ってみる</h2>

<p>ボタンを押した時の処理で Rx を使ってみます。</p>

<p>```c# Main.cs
(ここまで省略)
using Android.Util;</p>

<p>using System.Reactive.Linq; // これ必要</p>

<p>namespace XamarinAndroidRxSample
{</p>

<pre><code>[Activity (Label = "XamarinAndroidRxSample", MainLauncher = true)]
public class Activity1 : Activity
{
    protected override void OnCreate(Bundle bundle)
    {
        base.OnCreate(bundle);

        // Set our view from the "main" layout resource
        SetContentView(Resource.Layout.Main);

        // Get our button from the layout resource,
        // and attach an event to it
        Button button = FindViewById&lt;Button&gt;(Resource.Id.myButton);

        button.Click += delegate
        {
            Observable.Range(0, 10) // 0〜9 のリスト
            .Where(n =&gt; n % 2 == 0) // 偶数だけ抽出
            .Select(n =&gt; n * 2) // 値を２倍して
            .Subscribe(n =&gt; Log.Debug("Activity1", n.ToString())); // 出力
        };
    }
}
</code></pre>

<p>}
```</p>

<p>動かしてみた結果</p>

<p><img src="https://dl.dropbox.com/u/264530/qiita/xamarin_android_rxm4a_output.png" alt="&quot;output&quot;" /></p>

<p>全然 Rx っぽくない(Linq だけでできる) 処理ですけど、Rx 関連クラスが使えることは確認できました。</p>

<p>使い倒すには、RxMonoForAndroid 配下の他のプロジェクトを参照に追加して〜となるでしょう。</p>

<h2>アセンブリ参照はどうやるの？</h2>

<p>ここではプロジェクト参照で行ったのですけど、各Rxプロジェクトをビルドしてできた</p>

<ul>
<li>System.Reactive.Interfaces.dll</li>
<li>System.Reactive.Core.dll</li>
<li>System.Reactive.Linq.dll</li>
</ul>


<p>をアセンブリ参照してもいいでしょ？と思ってやってみました。
それぞれの System.Reactive.Linq プロジェクトの <code>/bin/Debug</code> ディレクトリの中に上記ファイルができているので、てっとり早くそれを XamarinAndroidRxSample でアセンブリ参照してみました。(ほんとはちゃんと Release ビルドしてね)</p>

<p>そしたらアプリは動くには動いたのですが、ソリューションツリーに怪しげなエラーが↓</p>

<p><img src="https://dl.dropbox.com/u/264530/qiita/xamarin_android_rxm4a_error.png" alt="&quot;error&quot;" /></p>

<p>アプリとDLLでターゲットフレームワークが違う(アプリは ICS4.0.3 でDLLは 4.0.0) だとこうなるんでしょうか？
Yes、アプリ側を 4.0.0 にしてプロジェクトクリーン→Xamarin Studio を再起動したら消えました。(けどアプリの方がバージョン上位だったのに、下位互換性はどうなってるんでしょ？)</p>

<h2>サンプルプロジェクト</h2>

<p>これも github においておこう。RxM4A は Submodule として登録してみた。</p>

<ul>
<li><a href="https://github.com/amay077/XamarinAndroid_RxSample">amay077 / XamarinAndroid_RxSample</a></li>
</ul>


<h2>参考</h2>

<ul>
<li><a href="http://www.atmarkit.co.jp/fdotnet/introrx/introrx_01/introrx_01_01.html">Reactive Extensionsの概要と利用方法 － ＠IT</a></li>
<li><a href="http://rxm4a.codeplex.com/">RxM4A - Mono For Android Reactive Extensions</a></li>
<li><a href="http://neue.cc/">neue cc</a> スーパー勉強になります</li>
<li><a href="http://d.hatena.ne.jp/okazuki/20111114/1321277465">かずきのBlog@Hatena</a> 膨大なサンプル集がようやく Android開発で活かせます！</li>
<li><a href="https://code.google.com/p/reactive4java/">reactive4java</a> Java ではこれ使ってました</li>
</ul>

]]></content>
  </entry>
  
</feed>
