<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ReactiveExtensions | Experiments Never Fail]]></title>
  <link href="http://amay077.github.io/blog/categories/reactiveextensions/atom.xml" rel="self"/>
  <link href="http://amay077.github.io/"/>
  <updated>2013-10-16T09:50:47+09:00</updated>
  <id>http://amay077.github.io/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Xamarin.Android で GPS を使う(Reactive Extensions版)]]></title>
    <link href="http://amay077.github.io/blog/2013/03/17/xamarin-android-using-gps-by-rx/"/>
    <updated>2013-03-17T00:42:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/03/17/xamarin-android-using-gps-by-rx</id>
    <content type="html"><![CDATA[<p>RxM4A により <a href="http://amay077.github.com/blog/2013/03/01/how-to-use-rx-in-xamarin/">Reactive Extensions が使えるようになった</a> ので、以前に <a href="http://amay077.github.com/blog/2012/10/03/locate-using-reactive4java/">Android+reactive4Java でやったコレ</a> を Xamarin.Android でやってみます。</p>

<!--more-->


<p>```c# LocationManager.Extenstion.cs
namespace Amay077.Android.Locations
{</p>

<pre><code>static class LocationManagerExtenstion
{
    // 渡した Action&lt;Location&gt; を OnLocationChanged で実行されるようにしただけ
    class LocationListener : Java.Lang.Object, ILocationListener
    {
        private readonly Action&lt;Location&gt; _locationChangedHandler;

        public LocationListener(Action&lt;Location&gt; locationChangedHandler)
        {
            _locationChangedHandler = locationChangedHandler;
        }

        #region ILocationListener implementation
        public void OnLocationChanged(Location location)
        {
            _locationChangedHandler(location);
        }

        public void OnProviderDisabled(string provider) { }
        public void OnProviderEnabled(string provider) { }
        public void OnStatusChanged(string provider, Availability status, Bundle extras) { }
        #endregion
    }

    public static IConnectableObservable&lt;Location&gt; RequestLocationAsObservable(
        this LocationManager locMan,
        string provider)
    {
        return Observable.Create&lt;Location&gt;(o =&gt; 
        {
            try {
                var isStop = false; // RemoveUpdates してもすぐ止まるか分からんので一応フラグ持っとく

                var listener = new LocationListener(l =&gt; 
                {
                    if (isStop) return;
                    o.OnNext(l);
                });

                // 位置取得開始
                locMan.RequestLocationUpdates(provider, 0, 0, listener);

                return () =&gt; // Dispose() した時に停止
                {
                    if (isStop) return;
                    isStop = true;
                    locMan.RemoveUpdates(listener);
                    o.OnCompleted();
                };

            } catch (Exception ex) {
                o.OnError(ex);
                return () =&gt; { /* empty */ };
            }
        }).Publish(); // Hot な Observable に
    }
}
</code></pre>

<p>}
```</p>

<p><code>LocationManager</code> の拡張メソッドにしたいので、クラス名を慣例に習って <code>LocationManager.Extenstion.cs</code> に、メソッド <code>RequestLocationAsObservable</code> の第一引数に <code>this</code> を付けてます。</p>

<p><code>LocationListener</code> Inner クラスは、C# では匿名クラスが使えないので、コンストラクタで指定した <code>Action</code> が <code>OnLocationChanged</code> で呼ばれるようにしただけです。</p>

<p><code>RequestLocationAsObservable</code> メソッドがメイン。やってることは reactive4Java と同じです。Hot な Observable にしたので、最後に <code>.Publish()</code> してるので、返値が <code>IConnectableObservable</code> になってます。</p>

<p>さて使う方。</p>

<p>```c# Howtouse.cs
using Amay077.Android.Locations; // 拡張メソッドを使えるように</p>

<p>&lt;省略></p>

<p>// LocationManager を得る
var locationMan = (LocationManager)context.GetSystemService(Context.LocationService);
// RequestLocationAsObservable があたかも LocationManager のメンバのよ(ry
var observable = locationMan.RequestLocationAsObservable(LocationManager.GpsProvider);
observable.Take(3) // 3回取得
.Timeout(new TimeSpan(10000)) // 10秒待って取得できなかったらタイムアウト
.Subscribe(</p>

<pre><code>l =&gt; { Android.Util.Log.Debug(TAG, 
          String.Format("received: {0}/{1}", 
            l.Latitude, l.Longitude)); }, // 位置が取得される度に呼ばれる
e =&gt; Android.Util.Log.Debug(TAG, "error:" + e.Message), // エラー(タイムアウト含む)の時呼ばれる
() =&gt; Android.Util.Log.Debug(TAG, "finished.")); // 全部終わったら呼ばれる
</code></pre>

<p>observable.Connect(); // 接続開始
```</p>

<p>Reactive Extensions と C# の拡張メソッドなどのおかげで、Java よりもずいぶんとすっきり書けました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.Android で Reactive Extensions を使う]]></title>
    <link href="http://amay077.github.io/blog/2013/03/01/how-to-use-rx-in-xamarin/"/>
    <updated>2013-03-01T17:38:00+09:00</updated>
    <id>http://amay077.github.io/blog/2013/03/01/how-to-use-rx-in-xamarin</id>
    <content type="html"><![CDATA[<p>なんか一気にハードル上がったような。。。</p>

<!-- more -->


<p>Reactive Extensions(Rx) については、</p>

<ul>
<li><a href="http://www.atmarkit.co.jp/fdotnet/introrx/introrx_01/introrx_01_01.html">Reactive Extensionsの概要と利用方法 － ＠IT</a></li>
</ul>


<p>などを読んで頂くとして、Rx は昨年 <a href="http://www.infoq.com/jp/news/2012/11/rx-net-open-source">オープンソース化され</a>、本家を Mono for Android で使えるようにした</p>

<ul>
<li><a href="http://rxm4a.codeplex.com/">RxM4A - Mono For Android Reactive Extensions</a></li>
</ul>


<p>というプロジェクトがあります。
Mono で使えるということは Xamarin でももちろん…ということで使ってみます。</p>

<h2>サンプルアプリケーションを作る</h2>

<p>とりあえず Xamarin.Android で "XamarinAndroidRxSample" というプロジェクトを作りました。</p>

<h2>RxM4A のソースを Clone する</h2>

<p>上記のサイトからソースを取得します。以下のコマンドでもおｋ(要git)</p>

<blockquote><p>$git clone https://git01.codeplex.com/rxm4a</p></blockquote>

<h2>ソリューションにプロジェクトを追加する</h2>

<p>ソリューションツリーのソリューションのところで右クリック→追加→既存のプロジェクトを追加</p>

<p><img src="https://dl.dropbox.com/u/264530/qiita/xamarin_android_rxm4a.png" alt="&quot;add_project&quot;" /></p>

<p>で、先ほど取得した RxM4A のディレクトリへ移動します。</p>

<p><img src="https://dl.dropbox.com/u/264530/qiita/xamarin_android_rxm4a_projects.png" alt="&quot;projects&quot;" /></p>

<p>RxMonoForAndroid の中から以下のプロジェクトを追加します。</p>

<ul>
<li>System.Reactive.Interfaces</li>
<li>System.Reactive.Core</li>
<li>System.Reactive.Linq</li>
</ul>


<p>フォルダを掘ってくと xxx.csproj ってファイルがあるので、それを選択します。
依存関係があるので、上記の順番通りやらないとなにかエラーが出ますが、最終的に３つ揃えば問題ないでしょう。</p>

<h2>参照を追加する</h2>

<p>XamarinAndroidRxSample から、今追加した３つのプロジェクトを参照に追加します。</p>

<p>ソリューションツリーの XamarinAndroidRxSample のところで右クリック→参照アセンブリの追加 から、</p>

<p><img src="https://dl.dropbox.com/u/264530/qiita/xamarin_android_rxm4a_add_reference.png" alt="&quot;add_project_reference&quot;" />
<img src="https://dl.dropbox.com/u/264530/qiita/xamarin_android_rxm4a_add_reference2.png" alt="&quot;add_project_reference&quot;" /></p>

<p>ダイアログのタブで Projects を選ぶと３つ出てくるのでチェックをいれて OK してください。</p>

<h2>Reactive Extensions を使ってみる</h2>

<p>ボタンを押した時の処理で Rx を使ってみます。</p>

<p>```c# Main.cs
(ここまで省略)
using Android.Util;</p>

<p>using System.Reactive.Linq; // これ必要</p>

<p>namespace XamarinAndroidRxSample
{</p>

<pre><code>[Activity (Label = "XamarinAndroidRxSample", MainLauncher = true)]
public class Activity1 : Activity
{
    protected override void OnCreate(Bundle bundle)
    {
        base.OnCreate(bundle);

        // Set our view from the "main" layout resource
        SetContentView(Resource.Layout.Main);

        // Get our button from the layout resource,
        // and attach an event to it
        Button button = FindViewById&lt;Button&gt;(Resource.Id.myButton);

        button.Click += delegate
        {
            Observable.Range(0, 10) // 0〜9 のリスト
            .Where(n =&gt; n % 2 == 0) // 偶数だけ抽出
            .Select(n =&gt; n * 2) // 値を２倍して
            .Subscribe(n =&gt; Log.Debug("Activity1", n.ToString())); // 出力
        };
    }
}
</code></pre>

<p>}
```</p>

<p>動かしてみた結果</p>

<p><img src="https://dl.dropbox.com/u/264530/qiita/xamarin_android_rxm4a_output.png" alt="&quot;output&quot;" /></p>

<p>全然 Rx っぽくない(Linq だけでできる) 処理ですけど、Rx 関連クラスが使えることは確認できました。</p>

<p>使い倒すには、RxMonoForAndroid 配下の他のプロジェクトを参照に追加して〜となるでしょう。</p>

<h2>アセンブリ参照はどうやるの？</h2>

<p>ここではプロジェクト参照で行ったのですけど、各Rxプロジェクトをビルドしてできた</p>

<ul>
<li>System.Reactive.Interfaces.dll</li>
<li>System.Reactive.Core.dll</li>
<li>System.Reactive.Linq.dll</li>
</ul>


<p>をアセンブリ参照してもいいでしょ？と思ってやってみました。
それぞれの System.Reactive.Linq プロジェクトの <code>/bin/Debug</code> ディレクトリの中に上記ファイルができているので、てっとり早くそれを XamarinAndroidRxSample でアセンブリ参照してみました。(ほんとはちゃんと Release ビルドしてね)</p>

<p>そしたらアプリは動くには動いたのですが、ソリューションツリーに怪しげなエラーが↓</p>

<p><img src="https://dl.dropbox.com/u/264530/qiita/xamarin_android_rxm4a_error.png" alt="&quot;error&quot;" /></p>

<p>アプリとDLLでターゲットフレームワークが違う(アプリは ICS4.0.3 でDLLは 4.0.0) だとこうなるんでしょうか？
Yes、アプリ側を 4.0.0 にしてプロジェクトクリーン→Xamarin Studio を再起動したら消えました。(けどアプリの方がバージョン上位だったのに、下位互換性はどうなってるんでしょ？)</p>

<h2>サンプルプロジェクト</h2>

<p>これも github においておこう。RxM4A は Submodule として登録してみた。</p>

<ul>
<li><a href="https://github.com/amay077/XamarinAndroid_RxSample">amay077 / XamarinAndroid_RxSample</a></li>
</ul>


<h2>参考</h2>

<ul>
<li><a href="http://www.atmarkit.co.jp/fdotnet/introrx/introrx_01/introrx_01_01.html">Reactive Extensionsの概要と利用方法 － ＠IT</a></li>
<li><a href="http://rxm4a.codeplex.com/">RxM4A - Mono For Android Reactive Extensions</a></li>
<li><a href="http://neue.cc/">neue cc</a> スーパー勉強になります</li>
<li><a href="http://d.hatena.ne.jp/okazuki/20111114/1321277465">かずきのBlog@Hatena</a> 膨大なサンプル集がようやく Android開発で活かせます！</li>
<li><a href="https://code.google.com/p/reactive4java/">reactive4java</a> Java ではこれ使ってました</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cold を Hot にできる。そう、Publish ならね。]]></title>
    <link href="http://amay077.github.io/blog/2012/10/03/rx-cold-to-hot/"/>
    <updated>2012-10-03T19:13:00+09:00</updated>
    <id>http://amay077.github.io/blog/2012/10/03/rx-cold-to-hot</id>
    <content type="html"><![CDATA[<p>Rx いいよ Rx とか言っておきながら、いままで Cold と Hot の違いについて、ちゃんとわかってませんでしたスイマセン。</p>

<!--more-->


<p>そのため、</p>

<ul>
<li><a href="http://qiita.com/items/07762776102dbc84b1c7">reactive4java で端末の方位を取得しつづける - Qiita</a></li>
<li><a href="http://qiita.com/items/e15ba88d51938531b1a3">reactive4java で位置を取得し続ける - Qiita</a></li>
</ul>


<p>で作ったサンプルプログラム、盛大にバグってましたorz</p>

<h2>Cold な Observable と Hot な Observable</h2>

<p>音楽プレーヤ iPod に例えると自分なりにしっくり来ました。
Observable が iPod で、Observer は聴く人。
なんとこの iPod はイヤホンジャックがたくさんあります。
そしてさらにこの iPod はイヤホンを接続するだけで再生が始まり、抜くと停止します。</p>

<p>Cold な iPod では、聴く人がイヤホンを接続すると、音楽が最初から再生されます。
次の人がイヤホンを接続すると、また音楽が最初から再生されます。(最初の人は、再生されなおすわけじゃないよ。)</p>

<p>Hot な iPod では、最初に聴く人がイヤホンを接続すると、音楽が再生され始めます。
次の人が、イヤホンを接続すると、その人は途中から聴くことになります。一つのストリーミング放送をみんなで聴くみたいな。
最後の人がイヤホンを外すと、再生が止まります(この辺はストリーミングと微妙に感覚が異なる、ストリーミングって、聴いてる人が居ようが居まいが流され続けるってイメージだから)。</p>

<h2>何が問題か</h2>

<p>以上を踏まえた上で、<a href="http://qiita.com/items/e15ba88d51938531b1a3">reactive4java で位置を取得し続ける - Qiita</a> で作ったプログラムのどこが問題だったかというと。</p>

<p>位置を聞くために接続をすると、その都度、<code>locMan.requestLocationUpdates</code> が呼ばれているという事です。上記の音楽プレーヤで例えると、<code>player.start()</code> です。</p>

<p>位置情報の取得は、ホントに無限ストリーミングなので、一見問題無さげに見えますが、２つリスナを登録するのは頂けません。(中には複数のリスナを登録できない API もあるでしょう、ありました。それで気づいたんです。)</p>

<p>これは最初の register でのみ <code>locMan.requestLocationUpdates</code> が実行され、2番目以降の register では、observer.next だけが呼ばれるようにしないといけません。
そのためには、register した複数の observer を保持・管理する必要があります。うげー。</p>

<h2>そこで Publish ですよ。</h2>

<p>.publish() を Observable のおしりにくっつけます。はい、これだけ。本当に。簡単すぎて「いいの？」って思っちゃうくらい。</p>

<p>``java getCurrectLocationAsHotObservable.java
/<em>*
 * 位置を取得し続ける(Hot)
 </em>/
public static ObservableBuilder<Location> getCurrentLocationAsHotObservable(</p>

<pre><code>final Context context, final String provider) {
return ObservableBuilder.from(
    getCurrentlocationAsObservable(context, provider)
    ).publish(); // Cold → Hot へ変換！
</code></pre>

<p>}
```</p>

<p>これだけで、複数の人が位置を聴きに来ても、<code>locMan.requestLocationUpdates</code> が呼ばれるのは１回だけである、Hot な Observable になります。Rx すげえよ Rx！</p>

<p>reactive4java のソースを読んだところ、前述の「複数の observer を保持・管理して、最初だけリスナ登録して、誰もいなくなったらリスナ解除する」みたいな面倒なことを publish の中(正確には observeOn)で行なってくれているようです。</p>

<p>ますます Reactive Extensions が好きになりましたよ。</p>

<h2>.NET の Reactive Extensions と reactive4java の違い</h2>

<p>.NET の Reactive Extenstions では、Publish は、<code>IConnectableObservable&lt;T&gt;</code> を返すそうです。そして <code>Subscribe</code> しただけでは再生は開始されず、<code>Connect</code> した時に再生されるのだ、とも。</p>

<p>一方、<a href="http://reactive4java.googlecode.com/svn/trunk/Reactive4Java/docs/javadoc/index.html">reactive4java</a> では、<code>publish</code> は、普通の <code>Observable&lt;T&gt;</code> を返します。Observable には register(.NET の Subscribe に相当)しかないので、これを呼び出した時に再生が開始されます。</p>

<p>特に reactive4java の挙動で困っていませんが、今後のバージョンアップで .NET 側に合わせられるかも知れません。
ConnecableObservable という interface は既に用意されていますが、使われていないようです。</p>

<h2>参考</h2>

<ul>
<li><a href="http://xin9le.net/archives/104">Rx入門 (14) – Cold to Hot変換 : xin9le note</a></li>
<li><a href="http://d.hatena.ne.jp/okazuki/20120212/1329059831">Reactive Extensions再入門 その３６「ColdからHotへ！Publishメソッドと参照カウンタ？RefCountメソッド」 - かずきのBlog@Hatena</a></li>
<li><a href="http://neue.cc/2010/06/24_263.html">neue cc - Reactive Extensions for .NET (Rx) メソッド探訪第7回:IEnumerable vs IObservable</a></li>
</ul>


<p>Rx の神々のみなさんが懇切丁寧に解説してくださってるのに、失敗しないと気づかない自分のバカバカ！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[reactive4java で位置を取得し続ける]]></title>
    <link href="http://amay077.github.io/blog/2012/10/03/locate-using-reactive4java/"/>
    <updated>2012-10-03T15:21:00+09:00</updated>
    <id>http://amay077.github.io/blog/2012/10/03/locate-using-reactive4java</id>
    <content type="html"><![CDATA[<p><a href="http://qiita.com/items/07762776102dbc84b1c7">前回</a>に続き、 reactive4java ネタ。
調子に乗って Android で位置を取得し続けるのを reactive4java を使ってやってみた。</p>

<!--more-->


<p>```java LocationFunctions.java
/<em>*
 * 位置を取得し続ける(finish は呼ばれない)
 </em>/
public static Observable<Location> getCurrentLocationAsObservable(</p>

<pre><code>    final Context context, final String provider) {
return Reactive.createWithCloseable(new Func1&lt;Observer&lt;? super Location&gt;, Closeable&gt;() {
    private volatile boolean _stop = false;

    @Override
    public Closeable invoke(final Observer&lt;? super Location&gt; observer) {
        final LocationManager locMan = (LocationManager)context.getSystemService(Context.LOCATION_SERVICE);

        final LocationListener listener = new LocationListener() {

            @Override
            public void onStatusChanged(String provider, int status, Bundle extras) { }

            @Override
            public void onProviderEnabled(String provider) { }

            @Override
            public void onProviderDisabled(String provider) {
                observer.error(
                    new InvalidParameterException("LocationProvider disabled."));
            }

            @Override
            public void onLocationChanged(Location location) {
                if (_stop) {
                    return;
                }

                // 発火
                observer.next(location);
            }
        };

        // 位置取得開始
        locMan.requestLocationUpdates(provider, 0, 0, listener, Looper.getMainLooper());

        return new Closeable() {
            @Override
            public void close() throws IOException {
                if (_stop) {
                    return;
                }
                _stop = true;
                locMan.removeUpdates(listener);
                observer.finish();
            }
        };
    }
});
</code></pre>

<p>}
```</p>

<p>使い方は、方位の時とほとんど同じ。パラメータが Float から Location に代わっただけ。</p>

<p><code>_stop</code> フラグは、Listener を unregister しても溜まってるデータは流しちゃうんじゃないか、という事で用意した。
方位のやつは AtomicBoolean を使ったけどこっちは volatile でやってる。確かどっかで 'AtomicBoolean の方が確実に Atomic' って言ってた気がするけど、そもそもそんなに神経質になるところじゃないか。</p>

<p>Observable にすることで、「ｎ秒間位置を取得して貯めて、その中で一番精度の良いものを通す」みたいなことも簡単にできる。</p>

<p>Android の場合、購読開始時に registerXXXListener、Close で unregisterXXXEventListener てのがひとつのパターン。
たぶん BroadcastReceiver にも適用できる。</p>

<p>XXXListener も BroadcastReceiver も Observable でラップしちゃえば、その後は同じように扱えるので便利♪</p>

<h2>追記 9.27</h2>

<p>実はこのプログラム、Cold でしたー。というわけで、Hot についての記事を書きました。
* <a href="http://qiita.com/items/3a7bda9d0fdcb9248800">Cold を Hot にできる。そう、Publish ならね。 - Qiita</a></p>

<h2>参考</h2>

<ul>
<li><a href="http://qiita.com/items/07762776102dbc84b1c7">reactive4java で端末の方位を取得しつづける - Qiita</a></li>
<li><a href="http://stackoverflow.com/questions/3786825/java-volatile-boolean-vs-atomicboolean">Java: volatile boolean vs AtomicBoolean - Stack Overflow</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
