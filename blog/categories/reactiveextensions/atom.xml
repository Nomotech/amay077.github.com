<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: reactiveextensions | Experiments Never Fail]]></title>
  <link href="http://blog.amay077.net/blog/categories/reactiveextensions/atom.xml" rel="self"/>
  <link href="http://blog.amay077.net/"/>
  <updated>2014-09-16T00:17:04+09:00</updated>
  <id>http://blog.amay077.net/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Xamarin.Forms と ReactiveProperty で快適MVVM生活]]></title>
    <link href="http://blog.amay077.net/blog/2014/09/09/using-xamarin-forms-with-reactiveproperty/"/>
    <updated>2014-09-09T21:38:29+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/09/09/using-xamarin-forms-with-reactiveproperty</id>
    <content type="html"><![CDATA[<p>　<a href="http://www.buildinsider.net/mobile/xamarintips/0005">Xamarin.Forms</a> は、Xamarin に新たに搭載されたクロスプラットフォームUIフレームワーク＆MVVMフレームワークです。</p>

<!--more-->


<p>　<a href="http://okazuki.hatenablog.com/entry/2014/05/07/014133">ReactiveProperty</a> は、MVVMの(特に ViewModelの)実装を強力にサポートしてくれる、<a href="http://www.atmarkit.co.jp/fdotnet/introrx/index/">Reactive Extensions</a> を基盤としたライブラリです。</p>

<p> 両者を組み合わせると、Android/iOSアプリが COOL な感じで書けるんじゃないか、という事で試してみました。</p>

<h2>0. 環境など</h2>

<p>Mac + Xamarin Studio を使いますが、Windows + Visual Studio + Xamarin-Addin でもイケると思います。</p>

<h2>1. 導入</h2>

<h3>プロジェクトの作成</h3>

<p>新規ソリューションを、［C#］−［Mobile Apps］−［Blank App(Xamarin.Forms Portable)］で作成します。</p>

<h3>PCL の Profile を変更</h3>

<p>　作成されたソリューションの一番上にあるプロジェクト(.Android とか .iOS が付いていないやつ)のプロジェクト設定を開いて Profile を <strong>PCL 4.5 &ndash; Profile49</strong> に変更します。元々の Profile78 では ReactiveProperty が Nuget からインストールできないためです。最近のプラットフォームを対象にするなら、あまり影響はなさそうです。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/using_xamarin_forms_with_reactiveproperty_01.png" alt="" /></p>

<h3>Nuget で Reactive Extensions と ReactiveProperty を追加</h3>

<p>　メニューの［プロジェクト］ー［Add Packages］で Nuget のダイアログを開き、図のように 「Reactive Extensions &ndash; Main Library」と「ReactiveProperty Portable」を追加します。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/using_xamarin_forms_with_reactiveproperty_02.png" alt="" /></p>

<p>（Reactive Extensions の追加の際、なにやらWarningが出るようですが、とりあえず進めます。）</p>

<h2>2. ViewModel の実装</h2>

<p>　PCL のプロジェクトに、<code>FirstViewModel.cs</code> を作成します。
　<code>FirstViewModel</code> は、以下のようなプロパティとコマンドを持ちます。</p>

<ul>
<li>InputTextプロパティ : EditBox の入力に応じて更新</li>
<li>DisplayTextプロパティ : InputText の変化から1秒後に、InputText を大文字にして更新</li>
<li>Clearコマンド : InputText が &lsquo;clear&rsquo; の時のみ有効。実行すると InputText を空にする。</li>
</ul>


<p>これらの実装が下のようになります。</p>

<p>```csharp FirstViewModel.cs
using System;
using Codeplex.Reactive;
using System.Reactive.Linq;</p>

<p>namespace FormsWithRxProperty.ViewModels
{</p>

<pre><code>public class FirstViewModel
{
    private readonly ReactiveProperty&lt;string&gt; _inputText = 
        new ReactiveProperty&lt;string&gt;("Hoge");
    public ReactiveProperty&lt;string&gt; InputText 
    { 
        get { return _inputText; }
    }

    public ReactiveProperty&lt;string&gt; DisplayText
    {
        get; private set;
    }

    public ReactiveCommand Clear
    {
        get; private set;
    }

    public FirstViewModel()
    {
        // DisplayText は、InputText の変更から1秒後に大文字にして更新
        this.DisplayText = _inputText
            .Delay(TimeSpan.FromSeconds(1))
            .Select(x =&gt; x.ToUpper())
            .ToReactiveProperty();

        // InputText が `clear` の時に実装可能
        this.Clear = _inputText
            .Select(x =&gt; x.Equals("clear"))
            .ToReactiveCommand();
        // 実行されたら、InputText を空にする
        this.Clear.Subscribe(_ =&gt; _inputText.Value = String.Empty);
    }

}
</code></pre>

<p>}
```</p>

<p>　面倒な <code>INotifyPropertyChanged</code> の実装が必要なく、すっきりと記述できます。
　また、他のプロパティに関連して(反応して)値が変化するプロパティや、コマンドの利用可否などが、Reactive Extensions の機能により、流れるように記述できます。</p>

<h2>3. 画面及び ViewModel との Binding の実装</h2>

<p>　画面(UI)は、Xamarin.Forms の恩恵で、Android/iOS 共通で実装できます。XAML も使えますが、よく知らないのでコードでUIを記述します。</p>

<p>　PCL のプロジェクトに、 <code>FirstPage.cs</code> を作成し、以下のように実装します。</p>

<p>```csharp FirstPage.cs
using System;
using Xamarin.Forms;
using FormsWithRxProperty.ViewModels;</p>

<p>namespace FormsWithRxProperty.Pages
{</p>

<pre><code>public class FirstPage : ContentPage
{
    public FirstPage()
    {
        // UI
        var entry = new Entry
        {
            Text = "Hello, Forms!",
            VerticalOptions = LayoutOptions.Center,
            HorizontalOptions = LayoutOptions.FillAndExpand,
        };

        var label = new Label
        {
            VerticalOptions = LayoutOptions.Center,
            HorizontalOptions = LayoutOptions.CenterAndExpand,
        };

        var button = new Button
        {
            Text = "Clear (type 'clear' to enable)",
            VerticalOptions = LayoutOptions.Center,
            HorizontalOptions = LayoutOptions.FillAndExpand,
        };

        this.Content = new StackLayout
        {
            Padding = new Thickness(50f),
            VerticalOptions = LayoutOptions.Start,
            HorizontalOptions = LayoutOptions.Fill,
            Orientation = StackOrientation.Vertical,
            Children =
            {
                entry,
                label,
                button
            }
        };

        // ViewModel との Binding
        this.BindingContext = new FirstViewModel();
        entry.SetBinding&lt;FirstViewModel&gt;(Entry.TextProperty, vm=&gt;vm.InputText.Value);
        label.SetBinding&lt;FirstViewModel&gt;(Label.TextProperty, vm=&gt;vm.DisplayText.Value);
        button.SetBinding&lt;FirstViewModel&gt;(Button.CommandProperty, vm=&gt;vm.Clear);
    }
}
</code></pre>

<p>}
```</p>

<p>　ちょっと長いですが、画面に「エディットボックス」「ラベル」「ボタン」が縦に並んでいるだけです。</p>

<p>　下部の４行で、<code>FirstViewModel</code> の各プロパティ、コマンドと Bind しています。</p>

<p>　もともとあった <code>App.cs</code> は、<code>FirstPage</code> を生成するだけにします。</p>

<p>```csharp App.cs
using System;
using Xamarin.Forms;
using FormsWithRxProperty.Pages;</p>

<p>namespace FormsWithRxProperty
{</p>

<pre><code>public class App
{
    public static Page GetMainPage()
    {   
        return new FirstPage();
    }
}
</code></pre>

<p>}
```</p>

<h2>動かす！</h2>

<p> .Android か .iOS の付いたプロジェクトをスタートアップにして、実行します。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/using_xamarin_forms_with_reactiveproperty_03.gif" alt="" /></p>

<h3>追記 2014.9.10</h3>

<p>実機で動作確認するの忘れてました（実機はAOTなのに対してiOSシミュレータはJITなのでリフレクションとかが普通に動いてしまう）。
実機でも問題なく動作しました！</p>

<h2>追記 2014.9.11 INotifyPropertyChanged の利用</h2>

<p>ViewModel は <code>INotifyPropertyChanged</code> を実装して作成するのが一般的です。既にそのようにして作られた ViewModel でも <code>IObservable</code> 化して、ReactiveProperty で利用できます。</p>

<p>```csharp SecondViewModel.cs
public class SecondViewModel : INotifyPropertyChanged
{</p>

<pre><code>public ReactiveProperty&lt;string&gt; ValidationAttr { get; private set; }
public event PropertyChangedEventHandler PropertyChanged;

private string _myName = "HoGe";
public string MyName 
{
    get { return _myName; }
    set 
    { 
        if (_myName == value) return;

        _myName = value;
        PropertyChanged(this, new PropertyChangedEventArgs("MyName"));
    }
}

public ReactiveProperty&lt;string&gt; LowerText { get; private set; }

private ICommand _resetCommand;
public ICommand ResetCommand
{
    get
    {
        return _resetCommand ?? (_resetCommand = 
            new Xamarin.Forms.Command(() =&gt; MyName = "XAAAAMAAARIN!!"));
    }
}

public SecondViewModel()
{
    this.LowerText = this.ObserveProperty(x =&gt; x.MyName)
        .Select(x =&gt; x.ToLower())
        .ToReactiveProperty();
}
</code></pre>

<p>}
```</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/using_xamarin_forms_with_reactiveproperty_04.png" alt="" /></p>

<h2>まとめ</h2>

<p>　Reactive Extensions のメリットを活かして MVVM を構築できる ReactiveProperty と、ワンソースで Android/iOS の画面を定義でき、さらに Binding までも共通にできる Xamarin.Forms の組み合わせは、今後のモバイルアプリケーション開発をとても効率的にしてくれます、 <strong>そしてなにより楽しい！</strong></p>

<p>　今回のサンプルプログラムは</p>

<ul>
<li><a href="https://github.com/amay077/XamarinFormsWithReactivePropertySample/tree/master">amay077/XamarinFormsWithReactivePropertySample</a></li>
</ul>


<p>　に置きましたので、是非試してみてください。</p>

<h3>ReactiveProperty</h3>

<ul>
<li><a href="http://okazuki.hatenablog.com/entry/2014/05/07/014133">ReactiveProperty オーバービュー &ndash; かずきのBlog@hatena</a></li>
<li><a href="https://reactiveproperty.codeplex.com/releases/view/132232">ReactiveProperty &ndash; MVVM Extensions for Rx &ndash; Download: ReactiveProperty v1.0</a></li>
<li><a href="http://neue.cc/2011/08/26_341.html">neue cc &ndash; ReactiveProperty : Rx + MVVMへの試み</a></li>
<li><a href="http://yone64.wordpress.com/2014/06/20/reactiveproperty%E3%82%92%E4%BD%BF%E3%81%84%E3%81%9F%E3%81%84%E4%BA%BA%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%80%81reactiveextensions%E5%85%A5%E9%96%80%EF%BC%88%E3%81%9D%E3%81%AE%EF%BC%91%EF%BC%89/">ReactivePropertyを使いたい人のための、ReactiveExtensions入門（その１） | 泥庭</a></li>
</ul>


<h3>Xamarin.Forms</h3>

<ul>
<li><a href="http://developer.xamarin.com/guides/cross-platform/xamarin-forms/">Xamarin.Forms | Xamarin</a></li>
<li><a href="http://www.buildinsider.net/mobile/insidexamarin/14">Xamarin.Formsの基本構想と仕組み &ndash; Build Insider</a></li>
<li><a href="http://www.buildinsider.net/tagcloud?tag=Xamarin.Forms">Xamarin.Forms &ndash; Build Insider</a></li>
<li><a href="http://furuya02.hatenablog.com/entry/2014/08/08/003036">Xamarin.Forms ListViewでTwitter風のレイアウトを作成してみました（機種依存コードなし） &ndash; SIN@SAPPOROWORKSの覚書</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rx で Chain of Responsibility]]></title>
    <link href="http://blog.amay077.net/blog/2014/05/13/chain-of-resposibility-using-rx/"/>
    <updated>2014-05-13T15:24:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/05/13/chain-of-resposibility-using-rx</id>
    <content type="html"><![CDATA[<p>今さらだけど GoF の Chain of Responsibility パターン。「自分に処理できないタスクは上へ投げる」ってやつ。Reactive な感じでやるとこんな感じかなあと思って書いてみた。</p>

<!--more-->


<p>```csharp
void Main()
{</p>

<pre><code>var document = "有給届";

var kakariCho = CreateManager("係長", document, d =&gt; String.Equals(document, "遅刻届"));
var kaCho = CreateManager("課長", document, d =&gt; String.Equals(document, "有給届"));
var buCho = CreateManager("部長", document, d =&gt; String.Equals(document, "退職届"));

Observable.Concat(new [] { 
    kakariCho,  // 係長
    kaCho,      // 課長
    buCho       // 部長
})
.FirstOrDefault() // 最初の１人に承認されたら終了
.Timeout(TimeSpan.FromDays(1)) // 猶予１日
.Subscribe(x =&gt; Debug.WriteLine(String.IsNullOrEmpty(x) 
    ? "あなたの届書は却下されました" 
    : x + "が承認しました"));
</code></pre>

<p>}</p>

<p>/// 管理職を作成する（役職名、渡された届書、自分に承認できる届書）
IObservable<string> CreateManager(string managerTitle, string document, Predicate<string> canIAccept)
{</p>

<pre><code>return Observable.Create&lt;string&gt;(o =&gt; Task.Run(() =&gt; 
{
    if (canIAccept(document)) 
    {
        o.OnNext(managerTitle); // 承認
    }
    o.OnCompleted();
}));
</code></pre>

<p>}
```</p>

<p>管理職の人を <code>IObservable</code> に見立てて、自分が処理できるなら <code>OnNext</code> を呼ぶ、処理できないなら <code>OnNext</code> は呼ばずに <code>OnComplete</code> しちゃう。
で、係長・課長・部長の IObservable を <code>Concat</code> で役職の低い順につなげて、 <code>FirstOrDefault()</code> で最初の承認がもらえるまで待つ、みたいな。</p>

<p>係長・課長・部長が誰も承認しなかった時、タイムアウトするまで待ちが発生しちゃうのが難点。→ <code>Take(1)</code> じゃなくて <code>FirstOrDefault</code> すればいいみたい。誰も承認しなかった場合 <code>default(string)</code> つまり空文字が流れてくる。</p>

<p>あと、係長→課長→部長と管理職のハンコリレーが必要な場合に対応できていない、Concat なので係長の結果を課長に引き継いでないから。</p>

<p>んーどうしようか。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.iOS で FromEventPattern を使うときの注意点]]></title>
    <link href="http://blog.amay077.net/blog/2014/04/03/notice-for-fromeventpattern-in-xamarin-ios/"/>
    <updated>2014-04-03T15:29:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/04/03/notice-for-fromeventpattern-in-xamarin-ios</id>
    <content type="html"><![CDATA[<p>Reactive Extensions の <code>FromEventPattern</code> を使うと、イベントを <code>IObservable</code> に変換できて、複数のイベントに時系列な関係を与えたり、他のストリーム処理とシームレスに扱えたりします。</p>

<!--more-->


<ul>
<li><a href="http://www.atmarkit.co.jp/fdotnet/introrx/introrx_02/introrx_02_02.html">イベント・プログラミングとRx － ＠IT</a></li>
</ul>


<p>Xamarin .iOS でも .Android でもこの機能を使うことができて大変便利ですが、Xamarin.iOS の場合 AOT による制限に気をつける必要があります。</p>

<p>以下は、なんの変哲もない、「ボタンを押したらタイトルを ”Clicked!” に変える」コードです。</p>

<p><code>csharp
MyButton.TouchUpInside += (s, e) =&gt; MyButton.SetTitle("Clicked!", UIControlState.Normal);
</code></p>

<p>これを FromEventPattern を使うとこう書けます。</p>

<p><code>csharp DoesNotWorkOnDevice.cs
Observable.FromEventPattern(MyButton, "TouchUpInside")
.Subscribe(x =&gt; MyButton.SetTitle("Clicked!", UIControlState.Normal));
</code></p>

<p>このコード、iOSシミュレータでは正常に動作しますが、 <strong>実機では、ビルドは通りますが動作しません。</strong> 実行時にこんなエラーがでます。</p>

<blockquote><p>System.InvalidOperationException: Could not find event &lsquo;TouchUpInside&rsquo; on object of type &lsquo;MonoTouch.UIKit.UIButton&rsquo;.</p></blockquote>

<p><code>TouchUpInside</code> が無いと言われます。</p>

<p>これは AOT により生成されたコードに、このイベントが含まれないのだと推測します。イベント名を文字列リテラルで指定しているので、そこまでの解析は期待できないですよね。</p>

<p>シミュレータで動作したのは、この場合は AOT でなく JIT で動作しているため。以下でも言及されています。</p>

<ul>
<li><a href="http://www.buildinsider.net/mobile/insidexamarin/05">Xamarin.iOSの仕組みとアプリケーションの構成 &ndash; Build Insider</a></li>
</ul>


<blockquote><p>対象がiOSシミュレーターである場合と、iOSデバイスである場合とで、大きく異なる。iOSシミュレーターは、エミュレーターではなく、あくまでMac OS Xが動作しているx86 CPUの上で動作している仮想マシンであり、アプリケーションはJITによって動作する。iOSデバイスはARMであり、iOSデバイス用にビルドされたアプリケーションはAOTによってARMのCPU命令に変換されており、ARM上でしか動作しない。</p></blockquote>

<p>Xamarin.iOS では実機で動作させないと安心ならないと言われる所以です。</p>

<p>さて、このケースでは、FromEventPattern の別なオーバーロードを使うことで解決です。</p>

<p><code>csharp WorkOnDevice.cs
Observable.FromEventPattern(
  h =&gt; MyButton.TouchUpInside+=h,
  h =&gt; MyButton.TouchUpInside-=h)
.Subscribe(x =&gt; MyButton.SetTitle("Clicked!", UIControlState.Normal));
</code></p>

<p>Xamarin.iOS の制限事項は以下に。</p>

<ul>
<li><a href="http://docs.xamarin.com/guides/ios/advanced_topics/limitations/">Limitations | Xamarin</a></li>
</ul>


<p>これまでこの制限に引っかかった事がなかったのですが、初めて引っかかりました。</p>

<p>メソッドを文字列リテラルで書いた時点で私の負けです、本当にありがとうございました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin に Reactive Extensions を導入する]]></title>
    <link href="http://blog.amay077.net/blog/2013/12/12/installing-rx-in-xamarin/"/>
    <updated>2013-12-12T00:00:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2013/12/12/installing-rx-in-xamarin</id>
    <content type="html"><![CDATA[<p>昨日の <a href="http://qiita.com/amay077/items/49681b2de5d8cf208112">ポスト</a> を使ったのに、肝心の導入部分を説明するのを忘れていました。まあ Components から追加するだけなのですが。他のアドベントカレンダーとの掛け持ちで疲れたので、今日は軽く書いて済ませます。</p>

<!--more-->


<h2>Reactive Extensions を導入する</h2>

<p>Components で右クリック → Get more components → Reactive とかで検索 → 見つけたら Add to App で OK です。あ、この手順は .iOS でも .Android でも同じです。</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/install_rx_to_xamarin_ios_01.gif" alt="" /></p>

<h2>使ってみましょうか</h2>

<p>イベントを Stream に変換する例を示してお茶を濁します。</p>

<p>まずこんな感じのどうでもいい画面を用意しまして、</p>

<p><img src="https://dl.dropboxusercontent.com/u/264530/qiita/install_rx_to_xamarin_ios_02.png" alt="" /></p>

<p><code>UIButton.TouchUpInside</code> を <code>IObservable</code> に変換する拡張メソッドを用意します。</p>

<p>```csharp UIButtonExtensions.cs
public static class UIButtonExtensions
{</p>

<pre><code>public static IObservable&lt;string&gt; ClickAsObservable(this UIButton button)
{
    return Observable.FromEventPattern&lt;EventArgs&gt;(button, "TouchUpInside")
            .Select(e =&gt; ((UIButton)e.Sender).TitleLabel.Text);
}
</code></pre>

<p>}
```</p>

<p>で、こんなコードを書きます。</p>

<p>```csharp MainViewController_amb.cs
public override void ViewDidLoad()
{</p>

<pre><code>base.ViewDidLoad();

Button1.ClickAsObservable()
    .Publish(_ =&gt; 
        Button2.ClickAsObservable()
        .Amb(
            Button3.ClickAsObservable()))
    .Subscribe(btnName =&gt; InvokeOnMainThread(() =&gt; 
        Label1.Text = btnName + " Clicked"));
</code></pre>

<p>}
```</p>

<h3>Observable.Amb (先にきた値を流す)</h3>

<p>Button1 を押すと処理の開始です。
Publish で分配して <strong>Amb</strong> は Button2 のクリックと Button3 のクリックで先に行われた方を Label1 に表示します。</p>

<h3>Observable.Zip (どちらの値も待つ)</h3>

<p>Amb を Zip に変えてみます。</p>

<p>```csharp MainViewController_zip.cs</p>

<pre><code>Button1.ClickAsObservable()
    .Publish(_ =&gt; 
        Button2.ClickAsObservable()
        .Zip(
            Button3.ClickAsObservable(), (l,r) =&gt; new {l, r}))
    .Subscribe(p =&gt; InvokeOnMainThread(() =&gt; 
        Label1.Text = p.l + " and " + p.r + "Clicked"));
</code></pre>

<p>```</p>

<p>Zip は2つのシーケンスの結果を待ってから後続へ流します。
なので、Button2 と Button3 の両方が押されると、Label1 に表示されます。</p>

<p>どちらもフツーに書くとフラグ変数なんか使って実現すると思うんですけど、Rx を使うと読みやすいコードになると思います。</p>

<p>あと、私は Android-Java の開発では <a href="https://code.google.com/p/reactive4java/">reactive4Java</a> を使ってるんですが、あれには <code>Observable.FromEventPattern</code> が無い(Java のイベントの Listener はイベントのマルチキャストに対応してないから仕方ない)ので、Xamarin にすることで「完全な」Rx を使うことができて、こりゃ勉強のしがいがあるなあと思ったのでした。</p>

<p>何の記事でしたっけ？という感じですけど Xamarin なら Linq も Rx も使えてハッピーという事で、今日は以上です。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xamarin.Android で GPS を使う(Reactive Extensions版)]]></title>
    <link href="http://blog.amay077.net/blog/2013/03/17/xamarin-android-using-gps-by-rx/"/>
    <updated>2013-03-17T00:42:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2013/03/17/xamarin-android-using-gps-by-rx</id>
    <content type="html"><![CDATA[<p>RxM4A により <a href="http://amay077.github.com/blog/2013/03/01/how-to-use-rx-in-xamarin/">Reactive Extensions が使えるようになった</a> ので、以前に <a href="http://amay077.github.com/blog/2012/10/03/locate-using-reactive4java/">Android+reactive4Java でやったコレ</a> を Xamarin.Android でやってみます。</p>

<!--more-->


<p>```c# LocationManager.Extenstion.cs
namespace Amay077.Android.Locations
{</p>

<pre><code>static class LocationManagerExtenstion
{
    // 渡した Action&lt;Location&gt; を OnLocationChanged で実行されるようにしただけ
    class LocationListener : Java.Lang.Object, ILocationListener
    {
        private readonly Action&lt;Location&gt; _locationChangedHandler;

        public LocationListener(Action&lt;Location&gt; locationChangedHandler)
        {
            _locationChangedHandler = locationChangedHandler;
        }

        #region ILocationListener implementation
        public void OnLocationChanged(Location location)
        {
            _locationChangedHandler(location);
        }

        public void OnProviderDisabled(string provider) { }
        public void OnProviderEnabled(string provider) { }
        public void OnStatusChanged(string provider, Availability status, Bundle extras) { }
        #endregion
    }

    public static IConnectableObservable&lt;Location&gt; RequestLocationAsObservable(
        this LocationManager locMan,
        string provider)
    {
        return Observable.Create&lt;Location&gt;(o =&gt; 
        {
            try {
                var isStop = false; // RemoveUpdates してもすぐ止まるか分からんので一応フラグ持っとく

                var listener = new LocationListener(l =&gt; 
                {
                    if (isStop) return;
                    o.OnNext(l);
                });

                // 位置取得開始
                locMan.RequestLocationUpdates(provider, 0, 0, listener);

                return () =&gt; // Dispose() した時に停止
                {
                    if (isStop) return;
                    isStop = true;
                    locMan.RemoveUpdates(listener);
                    o.OnCompleted();
                };

            } catch (Exception ex) {
                o.OnError(ex);
                return () =&gt; { /* empty */ };
            }
        }).Publish(); // Hot な Observable に
    }
}
</code></pre>

<p>}
```</p>

<p><code>LocationManager</code> の拡張メソッドにしたいので、クラス名を慣例に習って <code>LocationManager.Extenstion.cs</code> に、メソッド <code>RequestLocationAsObservable</code> の第一引数に <code>this</code> を付けてます。</p>

<p><code>LocationListener</code> Inner クラスは、C# では匿名クラスが使えないので、コンストラクタで指定した <code>Action</code> が <code>OnLocationChanged</code> で呼ばれるようにしただけです。</p>

<p><code>RequestLocationAsObservable</code> メソッドがメイン。やってることは reactive4Java と同じです。Hot な Observable にしたので、最後に <code>.Publish()</code> してるので、返値が <code>IConnectableObservable</code> になってます。</p>

<p>さて使う方。</p>

<p>```c# Howtouse.cs
using Amay077.Android.Locations; // 拡張メソッドを使えるように</p>

<p>&lt;省略></p>

<p>// LocationManager を得る
var locationMan = (LocationManager)context.GetSystemService(Context.LocationService);
// RequestLocationAsObservable があたかも LocationManager のメンバのよ(ry
var observable = locationMan.RequestLocationAsObservable(LocationManager.GpsProvider);
observable.Take(3) // 3回取得
.Timeout(new TimeSpan(10000)) // 10秒待って取得できなかったらタイムアウト
.Subscribe(</p>

<pre><code>l =&gt; { Android.Util.Log.Debug(TAG, 
          String.Format("received: {0}/{1}", 
            l.Latitude, l.Longitude)); }, // 位置が取得される度に呼ばれる
e =&gt; Android.Util.Log.Debug(TAG, "error:" + e.Message), // エラー(タイムアウト含む)の時呼ばれる
() =&gt; Android.Util.Log.Debug(TAG, "finished.")); // 全部終わったら呼ばれる
</code></pre>

<p>observable.Connect(); // 接続開始
```</p>

<p>Reactive Extensions と C# の拡張メソッドなどのおかげで、Java よりもずいぶんとすっきり書けました。</p>
]]></content>
  </entry>
  
</feed>
