<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | Experiments Never Fail]]></title>
  <link href="http://blog.amay077.net/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://blog.amay077.net/"/>
  <updated>2016-10-29T02:15:15+09:00</updated>
  <id>http://blog.amay077.net/</id>
  <author>
    <name><![CDATA[amay077]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[非同期処理の書き方を Java と Swift と Xamarin で比較する]]></title>
    <link href="http://blog.amay077.net/blog/2016/07/19/comparison_async_logic_with_java_swift_xamarin/"/>
    <updated>2016-07-19T23:59:59+09:00</updated>
    <id>http://blog.amay077.net/blog/2016/07/19/comparison_async_logic_with_java_swift_xamarin</id>
    <content type="html"><![CDATA[<p>「重たい処理を非同期で実行して、結果をメインスレッドで画面に表示」を、</p>

<!--more-->


<ul>
<li>Android-Java</li>
<li>iOS-Swift</li>
<li>Xamarin(Android も iOS も同じ)</li>
</ul>


<p>で比較。</p>

<hr />

<h2>Android</h2>

<p>```java
@Override
public void onClick(View view) {</p>

<pre><code>new AsyncTask&lt;Void, Void, Long&gt;() {
    @Override
    protected Long doInBackground(Void[] p) {
        // ワーカースレッド
        long ret = 0;
        for (long i = 0; i &lt; 1000000000; i++)
            ret += i;
        return ret;
    }

    @Override
    protected void onPostExecute(Long result) {
        // UIスレッド
        text1.setText(String.valueOf(result));
    }
}.execute((Void)null);
</code></pre>

<p>}
```</p>

<hr />

<h2>Swift</h2>

<p>```java
@IBAction func onTouchUpInside(sender: AnyObject) {</p>

<pre><code>weak var weakSelf = self
dispatch_async(dispatch_get_global_queue(
    DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), {
    // ワーカースレッド
    var ret:Int = 0
    for i in 0...1000000000 {
        ret += i
    }

    dispatch_async(dispatch_get_main_queue(), {
        // UIスレッド
        weakSelf?.label1.text = String(ret)
    });
});
</code></pre>

<p>}
```</p>

<hr />

<h2>Xamarin(Android も iOS も)</h2>

<p>```csharp
Task<long> FatProc() => Task.Run<long>(() => {</p>

<pre><code>long ret = 0;
for (long i = 0; i &lt; 1000000000; i++)
    ret += i;
return ret;
</code></pre>

<p>});</p>

<p>button1.TouchUpInside += async (_, e) => {</p>

<pre><code>var ret = await FatProc(); // ワーカースレッド
label1.Text = ret.ToString(); // UIスレッド
</code></pre>

<p>};
```</p>

<hr />

<h2>Xamarin はいいぞ！</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ボタンをタップした時に○○する、を Java と Swift と Xamarin で比較する]]></title>
    <link href="http://blog.amay077.net/blog/2016/07/15/comparison_on_click_with_java_swift_xamarin/"/>
    <updated>2016-07-15T23:59:59+09:00</updated>
    <id>http://blog.amay077.net/blog/2016/07/15/comparison_on_click_with_java_swift_xamarin</id>
    <content type="html"><![CDATA[<p>たぶん一番書くやつを</p>

<!--more-->


<ul>
<li>Android-Java</li>
<li>Android-Xamarin</li>
<li>iOS-Swift</li>
<li>iOS-Xamarin</li>
</ul>


<p>で比較。</p>

<hr />

<h2>Android-Java</h2>

<p>```java MainActivity.java
button1.setOnClickListener(new View.OnClickListener() {</p>

<pre><code>@Override
public void onClick(View view) {
    label1.setText("pushed!!");        
}
</code></pre>

<p>});</p>

<h2>```</h2>

<h2>Xamarin.Android(C#)</h2>

<p>```csharp MainActivity.cs
buttonOk.Click += (_, e)</p>

<pre><code>=&gt; label1.Text = "pushed!!";
</code></pre>

<h2>```</h2>

<h2>iOS-Swift</h2>

<p>```java ViewController.swift
buttonOK.addTarget(self, action:</p>

<pre><code>#selector(ViewController.onTouch(_:)), 
forControlEvents: .TouchUpInside)
</code></pre>

<p>・・・
func onTouch(sender: AnyObject) {</p>

<pre><code>label1.text = "pushed!!"
</code></pre>

<p>}</p>

<h2>```</h2>

<h2>Xamarin.iOS(C#)</h2>

<p>```csharp ViewColtroller.cs
buttonOk.TouchUpInside += (_, e)</p>

<pre><code>=&gt; label1.Text = "pushed!!";
</code></pre>

<h2>```</h2>

<h2>まとめ</h2>

<p><strong>Xamarin はいいぞ！</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift で @autoreleasepool どうやるの？]]></title>
    <link href="http://blog.amay077.net/blog/2014/06/17/autoreleasepool-in-swift/"/>
    <updated>2014-06-17T00:00:00+09:00</updated>
    <id>http://blog.amay077.net/blog/2014/06/17/autoreleasepool-in-swift</id>
    <content type="html"><![CDATA[<p><code>autoreleasepool {  }</code> だそうです。</p>

<!--more-->


<ul>
<li><a href="http://stackoverflow.com/questions/24152050/what-is-the-equivalent-of-autoreleasepool-in-swift">automatic ref counting &ndash; What is the equivalent of @autoreleasepool in Swift? &ndash; Stack Overflow</a></li>
</ul>


<p>こんな感じで使うようです。</p>

<p>```
for i in 1&hellip;10000 {
  autoreleasepool {</p>

<pre><code>// do heavy work
</code></pre>

<p>  }
}
```</p>

<p><a href="http://qiita.com/amay077/items/95a4139e6f553d8a56a1">iOS &ndash; ARC のメモリ解放タイミングを調べた</a> は Swift でも有効なようで。</p>

<p><del><a href="http://swift-lang.org/tryswift/">http://swift-lang.org/tryswift/</a> で試してみたら &ldquo;unexpected token: autoreleasepool&rdquo; で怒られた。。。Xcode6 を入れないと動かせないんですかね。</del></p>
]]></content>
  </entry>
  
</feed>
